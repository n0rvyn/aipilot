---
description: "AI 自检清单（每次会话必读）"
scopes: [chat, edit]
tags: [ai-checklist, self-check]
priority: 3
globs: ["**/*.ts", "**/*.js"]
alwaysApply: true
---

# AI 自检清单

> **重要性**: ⭐⭐⭐⭐⭐ 最高优先级  
> **加载方式**: Always Applied  
> **用途**: 指导 AI 正确工作流程  

---

## 📋 每次会话开始时

### 必须执行的检查

- [ ] ✅ 读取 `000-critical-rules.mdc`（核心铁律）
- [ ] ✅ 读取 `001-project-context.mdc`（项目状态）
- [ ] ✅ 读取 `002-ai-checklist.mdc`（本文件）
- [ ] ✅ 读取 `docs/README.md`（文档中心）

### 必须在回复开头确认

```markdown
✅ 已读取核心铁律 + AIPilot 项目状态
✅ 已了解项目技术栈：TypeScript + Obsidian Plugin
✅ 已查看文档结构

---

[开始回答用户问题]
```

---

## 🎯 接到任务时

### 场景识别（自动加载）

当编辑以下文件时，Cursor 会**自动加载**对应的场景规则：

| 场景 | 文件模式 | 自动加载规则 |
|------|---------|-------------|
| **Obsidian 插件** | `**/*.ts`, `**/*.js` | 100-obsidian-plugin-checklist.mdc |
| **TypeScript** | `**/*.ts` | 101-typescript-checklist.mdc |
| **Markdown 渲染** | `**/MarkdownRenderer.ts`, `**/ChatView.ts` | 102-markdown-rendering-checklist.mdc |

**注意**：
- ✅ 场景规则会在你打开对应文件时**自动加载**，无需手动引用
- ✅ 只在需要时加载，节省 token
- ⚠️ 如果需要其他场景的规则，在 Chat 中提及文件名即可加载

### 任务类型判断

#### 类型 1：简单问题（不需要代码变更）

**特征**：
- 用户只是询问
- 不需要修改代码
- 不需要执行命令

**流程**：
1. 直接回答
2. 引用相关文档（如果需要）
3. 提供示例代码（如果有帮助）

#### 类型 1.5：复杂问题分析（需要结构化决策）⭐

**特征**（满足任一即可）：
- 用户问题包含 2+ 个不确定因素
- 需要对比多个方案（关键词：对比、选择、哪个更好）
- 涉及架构级决策或技术选型
- 用户明确说"有几个疑点"、"不确定怎么选"

**识别信号**：
```markdown
用户问题包含：
- "对比"、"选择"、"哪个更好"、"优缺点"
- "有几种方案"、"不确定"、"怎么办"
- "A 还是 B"、"应该用 X 还是 Y"
```

**流程**：
1. ⚠️ **主动询问**："我发现这是一个复杂问题，涉及 [X 个疑点]。是否使用结构化决策流程？"
2. 用户确认 → 按 `003-structured-decision-workflow.mdc` 执行
3. 需要深入分析 → 完整的疑点识别和方案对比
4. 完成分析 → 生成决策摘要 + 实施计划

**标准输出**：
- 1️⃣ 疑点识别（2-5 个独立疑点）
- 2️⃣ 方案矩阵（每个疑点 2-3 个方案 + 推荐度）
- 3️⃣ 逐项讨论（一次只讨论 1 个疑点）
- 4️⃣ 综合整合（决策摘要 + 实施计划）

**详细参考**：`003-structured-decision-workflow.mdc`

#### 类型 2：代码变更任务

**特征**：
- 需要修改现有代码
- 需要新增文件
- 需要运行命令

**流程**：
1. ⚠️ **必须先制定计划**（见下方"制定计划"部分）
2. 等待用户批准
3. 开始实施
4. 逐项验收

#### 类型 3：紧急修复

**特征**：
- 编译错误
- 运行时崩溃
- 明显的 bug

**流程**：
1. 可以直接修复（无需计划）
2. 但仍需记录变更
3. 如果涉及架构变更 → 仍需制定计划

---

## 📝 制定计划时

### 何时需要制定计划？

✅ **需要计划**（必须先制定计划，等待批准）：
- 实现新功能
- 重构现有代码（>5 个文件）
- 修改数据结构
- 修改 API 接口
- 任何架构级变更

❌ **不需要计划**（可以直接执行）：
- 修复明显的编译错误
- 修复拼写错误
- 添加注释
- 修改日志输出

### 计划的基本结构

```markdown
## 🎯 目标
[简要描述要实现什么]

## 📊 当前问题分析
[为什么需要这个变更]

## 💡 解决方案

### 方案 A [推荐] ⭐
- 优点：...
- 缺点：...
- 实施步骤：
  1. Step 1
  2. Step 2
  3. ...

### 方案 B
- 优点：...
- 缺点：...

## 📋 详细步骤（方案 A）
1. Step 1: [具体操作]
   - 验收标准：[如何验证完成]
2. Step 2: [具体操作]
   - 验收标准：[如何验证完成]
...

## ✅ 成功标准
- [ ] 标准 1
- [ ] 标准 2
...

## ⚠️ 风险与缓解
| 风险 | 可能性 | 影响 | 缓解措施 |
|------|-------|------|---------|
| ... | ... | ... | ... |
```

### 等待用户批准

**明确的批准信号**：
- ✅ "同意"、"批准"、"执行"
- ✅ "Option A"、"方案 A"
- ✅ "开始实施"、"开整"

**不算批准**：
- ❌ 用户只是回复了其他内容
- ❌ 用户沉默
- ❌ 用户说"看起来不错"（但没明确说执行）

---

## ⚙️ 执行计划时

### 核心原则：任务执行红线

> **完整版**: 见 `000-critical-rules.mdc` 或 `207-task-execution-detailed.mdc`

#### 1️⃣ 必须逐项完成并验收

```markdown
✅ 正确流程：
Step 1 → 完成 → 验收通过 → Step 2 → 完成 → 验收通过 → Step 3

❌ 错误流程：
Step 1 → 失败 → 跳过 → Step 2 继续
Step 1 → 部分完成 → "回头再补" → Step 2 继续
```

#### 2️⃣ 失败时必须停止

```markdown
任务失败时：
1. 🛑 立即停止所有工作
2. 报告："Step X 失败了（具体原因）"
3. 询问："是否需要：
   - A. 重试该步骤
   - B. 检查问题原因
   - C. 继续下一步（说明风险）"
4. ⏸️  等待用户明确指示

❌ 禁止行为：
- 自己决定"先做其他的"
- 标记为 "pending" 就继续
- 假设"用户可能想..."
```

#### 3️⃣ 验收标准必须明确

**编译验证**：
```bash
# ✅ 必须实际运行
npm run build

# ✅ 必须看到
Build succeeded

# ❌ 不算验收通过：
- "linter 没报错"
- "应该没问题"
- "上次能过"
```

**功能测试**：
```markdown
✅ 必须：
- 在 Obsidian 中实际测试
- 验证功能是否正常
- 检查控制台无错误
- 测试边界情况

❌ 禁止：
- 跳过测试
- 假设"应该可以"
- 自己声称"测试通过"
```

#### 4️⃣ 等待明确允许

**何时必须停止并等待**：
- 需要用户在 Obsidian 中测试功能
- 需要用户确认 UI 效果
- 需要用户提供 API key
- 任何需要用户决策的地方

**报告模板**：
```markdown
"Step X 需要您的操作：
 - 具体操作：[详细步骤]
 - 预计时间：[X 分钟]
 - 完成后请反馈结果，我再继续后续步骤"

⏸️  等待用户反馈...
```

---

## 📄 完成任务后

### 必须更新文档

#### 1. 更新项目结构（如果新增文件）

**文件**: `docs/STRUCTURE.md`

```markdown
- 标记新增/修改的文件
- 说明文件职责
- 更新目录树
```

#### 2. 重大变更更新相关文档

**涉及的文档**：
- `docs/architecture/` - 架构变更
- `docs/api/` - API 变更
- `docs/guides/` - 使用方式变更
- `README.md` - 功能列表变更

#### 3. 提交信息规范

**格式**：
```bash
feat(module): add new feature
fix(module): fix bug description
refactor(module): refactor code
docs(module): update documentation
```

---

## 🤔 遇到不确定问题时

### 辨证思考铁律

> **完整版**: 见 `000-critical-rules.mdc` 的 "AI 工作原则：辨证思考铁律"

#### 核心原则

**1. 区分"不知道"和"知道不存在"**

```markdown
❌ 错误："我找不到文档，所以这个功能不存在"
✅ 正确："我找不到文档，建议测试验证"
```

**2. 优先实验验证**

```markdown
证据层级（从高到低）：
1. ⭐⭐⭐ 实际测试结果
2. ⭐⭐ 官方文档明确说明
3. ⭐ 社区最佳实践（需验证）
4. ❌ 推测、假设

找不到文档时 → 设计实验验证 → 得出结论（不要纯推测）
```

**3. 承认错误**

```markdown
发现错误时：
1. ✅ 立即承认："我错了，[具体错在哪]"
2. ✅ 说明原因："因为我[错误的假设/推理]"
3. ✅ 更新规则："我会记住[教训]，避免重复"

❌ 不要辩解或找借口
```

**4. 用户也可能错**

```markdown
✅ 礼貌但明确地指出："我发现了一个潜在问题..."
✅ 提供证据："因为[具体原因/数据]"
✅ 建议验证："建议我们先测试一下[具体步骤]"

❌ 不要因为"怕得罪用户"就不指出错误
```

**5. 禁止模棱两可**

```markdown
❌ 禁用词汇：
- "可能"、"大概"、"应该"、"也许"
- "需要进一步查证"（然后就不管了）
- "理论上"、"一般来说"

✅ 替代表述：
- "我不知道这个机制是否支持。建议通过 [具体测试步骤] 验证。"
- "根据 [证据来源]，这个方案可行。但为了确保，建议先做 [小范围测试]。"
- "这取决于 [具体因素]。请告诉我 [需要的信息]，我才能给出准确建议。"
```

---

## 📚 需要详细参考时

### 何时查阅详细文档？

| 场景 | 查阅文档 |
|------|---------|
| 新会话开始，不了解项目 | 200-project-overview-detailed.mdc |
| 设计新功能，防止过度设计 | 204-anti-overengineering-detailed.mdc |
| 执行复杂任务，确认验收标准 | 207-task-execution-detailed.mdc |

### 如何加载详细文档？

**方式 1：直接提及文件名**
```markdown
"请参考 204-anti-overengineering-detailed.mdc"
```

**方式 2：询问 AI**
```markdown
"我需要查看防止过度设计的详细文档"
→ AI 会加载 204-anti-overengineering-detailed.mdc
```

---

## ✅ 快速自检清单

### 每次回复前，问自己：

- [ ] 是否读取了核心铁律？
- [ ] 是否了解项目技术栈（TypeScript + Obsidian）？
- [ ] 如果涉及代码变更，是否制定了计划？
- [ ] 如果执行计划，是否逐项完成并验收？
- [ ] 遇到失败，是否立即停止并询问？
- [ ] 遇到不确定问题，是否建议验证而非推测？
- [ ] 是否避免使用"可能"、"大概"等模棱两可的词汇？
- [ ] 任务完成后，是否更新了文档（如需要）？

---

**最后更新**: 2025-11-09  
**版本**: 1.0  
**Token 估算**: ~2,000 tokens  
**加载方式**: Always Applied  
**优先级**: 3
