/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// src/main.ts
var main_exports = {};
__export(main_exports, {
  DEFAULT_SETTINGS: () => DEFAULT_SETTINGS,
  LoadingModal: () => LoadingModal2,
  PolishResultModal: () => PolishResultModal,
  default: () => AIPilotPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian6 = require("obsidian");

// src/ChatView.ts
var import_obsidian2 = require("obsidian");

// node_modules/marked/lib/marked.esm.js
function _getDefaults() {
  return {
    async: false,
    breaks: false,
    extensions: null,
    gfm: true,
    hooks: null,
    pedantic: false,
    renderer: null,
    silent: false,
    tokenizer: null,
    walkTokens: null
  };
}
var _defaults = _getDefaults();
function changeDefaults(newDefaults) {
  _defaults = newDefaults;
}
var noopTest = { exec: () => null };
function edit(regex, opt = "") {
  let source = typeof regex === "string" ? regex : regex.source;
  const obj = {
    replace: (name, val) => {
      let valSource = typeof val === "string" ? val : val.source;
      valSource = valSource.replace(other.caret, "$1");
      source = source.replace(name, valSource);
      return obj;
    },
    getRegex: () => {
      return new RegExp(source, opt);
    }
  };
  return obj;
}
var other = {
  codeRemoveIndent: /^(?: {1,4}| {0,3}\t)/gm,
  outputLinkReplace: /\\([\[\]])/g,
  indentCodeCompensation: /^(\s+)(?:```)/,
  beginningSpace: /^\s+/,
  endingHash: /#$/,
  startingSpaceChar: /^ /,
  endingSpaceChar: / $/,
  nonSpaceChar: /[^ ]/,
  newLineCharGlobal: /\n/g,
  tabCharGlobal: /\t/g,
  multipleSpaceGlobal: /\s+/g,
  blankLine: /^[ \t]*$/,
  doubleBlankLine: /\n[ \t]*\n[ \t]*$/,
  blockquoteStart: /^ {0,3}>/,
  blockquoteSetextReplace: /\n {0,3}((?:=+|-+) *)(?=\n|$)/g,
  blockquoteSetextReplace2: /^ {0,3}>[ \t]?/gm,
  listReplaceTabs: /^\t+/,
  listReplaceNesting: /^ {1,4}(?=( {4})*[^ ])/g,
  listIsTask: /^\[[ xX]\] /,
  listReplaceTask: /^\[[ xX]\] +/,
  anyLine: /\n.*\n/,
  hrefBrackets: /^<(.*)>$/,
  tableDelimiter: /[:|]/,
  tableAlignChars: /^\||\| *$/g,
  tableRowBlankLine: /\n[ \t]*$/,
  tableAlignRight: /^ *-+: *$/,
  tableAlignCenter: /^ *:-+: *$/,
  tableAlignLeft: /^ *:-+ *$/,
  startATag: /^<a /i,
  endATag: /^<\/a>/i,
  startPreScriptTag: /^<(pre|code|kbd|script)(\s|>)/i,
  endPreScriptTag: /^<\/(pre|code|kbd|script)(\s|>)/i,
  startAngleBracket: /^</,
  endAngleBracket: />$/,
  pedanticHrefTitle: /^([^'"]*[^\s])\s+(['"])(.*)\2/,
  unicodeAlphaNumeric: /[\p{L}\p{N}]/u,
  escapeTest: /[&<>"']/,
  escapeReplace: /[&<>"']/g,
  escapeTestNoEncode: /[<>"']|&(?!(#\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\w+);)/,
  escapeReplaceNoEncode: /[<>"']|&(?!(#\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\w+);)/g,
  unescapeTest: /&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/ig,
  caret: /(^|[^\[])\^/g,
  percentDecode: /%25/g,
  findPipe: /\|/g,
  splitPipe: / \|/,
  slashPipe: /\\\|/g,
  carriageReturn: /\r\n|\r/g,
  spaceLine: /^ +$/gm,
  notSpaceStart: /^\S*/,
  endingNewline: /\n$/,
  listItemRegex: (bull) => new RegExp(`^( {0,3}${bull})((?:[	 ][^\\n]*)?(?:\\n|$))`),
  nextBulletRegex: (indent) => new RegExp(`^ {0,${Math.min(3, indent - 1)}}(?:[*+-]|\\d{1,9}[.)])((?:[ 	][^\\n]*)?(?:\\n|$))`),
  hrRegex: (indent) => new RegExp(`^ {0,${Math.min(3, indent - 1)}}((?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$)`),
  fencesBeginRegex: (indent) => new RegExp(`^ {0,${Math.min(3, indent - 1)}}(?:\`\`\`|~~~)`),
  headingBeginRegex: (indent) => new RegExp(`^ {0,${Math.min(3, indent - 1)}}#`),
  htmlBeginRegex: (indent) => new RegExp(`^ {0,${Math.min(3, indent - 1)}}<(?:[a-z].*>|!--)`, "i")
};
var newline = /^(?:[ \t]*(?:\n|$))+/;
var blockCode = /^((?: {4}| {0,3}\t)[^\n]+(?:\n(?:[ \t]*(?:\n|$))*)?)+/;
var fences = /^ {0,3}(`{3,}(?=[^`\n]*(?:\n|$))|~{3,})([^\n]*)(?:\n|$)(?:|([\s\S]*?)(?:\n|$))(?: {0,3}\1[~`]* *(?=\n|$)|$)/;
var hr = /^ {0,3}((?:-[\t ]*){3,}|(?:_[ \t]*){3,}|(?:\*[ \t]*){3,})(?:\n+|$)/;
var heading = /^ {0,3}(#{1,6})(?=\s|$)(.*)(?:\n+|$)/;
var bullet = /(?:[*+-]|\d{1,9}[.)])/;
var lheadingCore = /^(?!bull |blockCode|fences|blockquote|heading|html|table)((?:.|\n(?!\s*?\n|bull |blockCode|fences|blockquote|heading|html|table))+?)\n {0,3}(=+|-+) *(?:\n+|$)/;
var lheading = edit(lheadingCore).replace(/bull/g, bullet).replace(/blockCode/g, /(?: {4}| {0,3}\t)/).replace(/fences/g, / {0,3}(?:`{3,}|~{3,})/).replace(/blockquote/g, / {0,3}>/).replace(/heading/g, / {0,3}#{1,6}/).replace(/html/g, / {0,3}<[^\n>]+>\n/).replace(/\|table/g, "").getRegex();
var lheadingGfm = edit(lheadingCore).replace(/bull/g, bullet).replace(/blockCode/g, /(?: {4}| {0,3}\t)/).replace(/fences/g, / {0,3}(?:`{3,}|~{3,})/).replace(/blockquote/g, / {0,3}>/).replace(/heading/g, / {0,3}#{1,6}/).replace(/html/g, / {0,3}<[^\n>]+>\n/).replace(/table/g, / {0,3}\|?(?:[:\- ]*\|)+[\:\- ]*\n/).getRegex();
var _paragraph = /^([^\n]+(?:\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\n)[^\n]+)*)/;
var blockText = /^[^\n]+/;
var _blockLabel = /(?!\s*\])(?:\\.|[^\[\]\\])+/;
var def = edit(/^ {0,3}\[(label)\]: *(?:\n[ \t]*)?([^<\s][^\s]*|<.*?>)(?:(?: +(?:\n[ \t]*)?| *\n[ \t]*)(title))? *(?:\n+|$)/).replace("label", _blockLabel).replace("title", /(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/).getRegex();
var list = edit(/^( {0,3}bull)([ \t][^\n]+?)?(?:\n|$)/).replace(/bull/g, bullet).getRegex();
var _tag = "address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option|p|param|search|section|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul";
var _comment = /<!--(?:-?>|[\s\S]*?(?:-->|$))/;
var html = edit("^ {0,3}(?:<(script|pre|style|textarea)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)|comment[^\\n]*(\\n+|$)|<\\?[\\s\\S]*?(?:\\?>\\n*|$)|<![A-Z][\\s\\S]*?(?:>\\n*|$)|<!\\[CDATA\\[[\\s\\S]*?(?:\\]\\]>\\n*|$)|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:(?:\\n[ 	]*)+\\n|$)|<(?!script|pre|style|textarea)([a-z][\\w-]*)(?:attribute)*? */?>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n[ 	]*)+\\n|$)|</(?!script|pre|style|textarea)[a-z][\\w-]*\\s*>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n[ 	]*)+\\n|$))", "i").replace("comment", _comment).replace("tag", _tag).replace("attribute", / +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/).getRegex();
var paragraph = edit(_paragraph).replace("hr", hr).replace("heading", " {0,3}#{1,6}(?:\\s|$)").replace("|lheading", "").replace("|table", "").replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", _tag).getRegex();
var blockquote = edit(/^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/).replace("paragraph", paragraph).getRegex();
var blockNormal = {
  blockquote,
  code: blockCode,
  def,
  fences,
  heading,
  hr,
  html,
  lheading,
  list,
  newline,
  paragraph,
  table: noopTest,
  text: blockText
};
var gfmTable = edit("^ *([^\\n ].*)\\n {0,3}((?:\\| *)?:?-+:? *(?:\\| *:?-+:? *)*(?:\\| *)?)(?:\\n((?:(?! *\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)").replace("hr", hr).replace("heading", " {0,3}#{1,6}(?:\\s|$)").replace("blockquote", " {0,3}>").replace("code", "(?: {4}| {0,3}	)[^\\n]").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", _tag).getRegex();
var blockGfm = __spreadProps(__spreadValues({}, blockNormal), {
  lheading: lheadingGfm,
  table: gfmTable,
  paragraph: edit(_paragraph).replace("hr", hr).replace("heading", " {0,3}#{1,6}(?:\\s|$)").replace("|lheading", "").replace("table", gfmTable).replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", _tag).getRegex()
});
var blockPedantic = __spreadProps(__spreadValues({}, blockNormal), {
  html: edit(`^ *(?:comment *(?:\\n|\\s*$)|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)|<tag(?:"[^"]*"|'[^']*'|\\s[^'"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))`).replace("comment", _comment).replace(/tag/g, "(?!(?:a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)\\b)\\w+(?!:|[^\\w\\s@]*@)\\b").getRegex(),
  def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/,
  heading: /^(#{1,6})(.*)(?:\n+|$)/,
  fences: noopTest,
  // fences not supported
  lheading: /^(.+?)\n {0,3}(=+|-+) *(?:\n+|$)/,
  paragraph: edit(_paragraph).replace("hr", hr).replace("heading", " *#{1,6} *[^\n]").replace("lheading", lheading).replace("|table", "").replace("blockquote", " {0,3}>").replace("|fences", "").replace("|list", "").replace("|html", "").replace("|tag", "").getRegex()
});
var escape$1 = /^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/;
var inlineCode = /^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/;
var br = /^( {2,}|\\)\n(?!\s*$)/;
var inlineText = /^(`+|[^`])(?:(?= {2,}\n)|[\s\S]*?(?:(?=[\\<!\[`*_]|\b_|$)|[^ ](?= {2,}\n)))/;
var _punctuation = /[\p{P}\p{S}]/u;
var _punctuationOrSpace = /[\s\p{P}\p{S}]/u;
var _notPunctuationOrSpace = /[^\s\p{P}\p{S}]/u;
var punctuation = edit(/^((?![*_])punctSpace)/, "u").replace(/punctSpace/g, _punctuationOrSpace).getRegex();
var _punctuationGfmStrongEm = /(?!~)[\p{P}\p{S}]/u;
var _punctuationOrSpaceGfmStrongEm = /(?!~)[\s\p{P}\p{S}]/u;
var _notPunctuationOrSpaceGfmStrongEm = /(?:[^\s\p{P}\p{S}]|~)/u;
var blockSkip = /\[[^[\]]*?\]\((?:\\.|[^\\\(\)]|\((?:\\.|[^\\\(\)])*\))*\)|`[^`]*?`|<[^<>]*?>/g;
var emStrongLDelimCore = /^(?:\*+(?:((?!\*)punct)|[^\s*]))|^_+(?:((?!_)punct)|([^\s_]))/;
var emStrongLDelim = edit(emStrongLDelimCore, "u").replace(/punct/g, _punctuation).getRegex();
var emStrongLDelimGfm = edit(emStrongLDelimCore, "u").replace(/punct/g, _punctuationGfmStrongEm).getRegex();
var emStrongRDelimAstCore = "^[^_*]*?__[^_*]*?\\*[^_*]*?(?=__)|[^*]+(?=[^*])|(?!\\*)punct(\\*+)(?=[\\s]|$)|notPunctSpace(\\*+)(?!\\*)(?=punctSpace|$)|(?!\\*)punctSpace(\\*+)(?=notPunctSpace)|[\\s](\\*+)(?!\\*)(?=punct)|(?!\\*)punct(\\*+)(?!\\*)(?=punct)|notPunctSpace(\\*+)(?=notPunctSpace)";
var emStrongRDelimAst = edit(emStrongRDelimAstCore, "gu").replace(/notPunctSpace/g, _notPunctuationOrSpace).replace(/punctSpace/g, _punctuationOrSpace).replace(/punct/g, _punctuation).getRegex();
var emStrongRDelimAstGfm = edit(emStrongRDelimAstCore, "gu").replace(/notPunctSpace/g, _notPunctuationOrSpaceGfmStrongEm).replace(/punctSpace/g, _punctuationOrSpaceGfmStrongEm).replace(/punct/g, _punctuationGfmStrongEm).getRegex();
var emStrongRDelimUnd = edit("^[^_*]*?\\*\\*[^_*]*?_[^_*]*?(?=\\*\\*)|[^_]+(?=[^_])|(?!_)punct(_+)(?=[\\s]|$)|notPunctSpace(_+)(?!_)(?=punctSpace|$)|(?!_)punctSpace(_+)(?=notPunctSpace)|[\\s](_+)(?!_)(?=punct)|(?!_)punct(_+)(?!_)(?=punct)", "gu").replace(/notPunctSpace/g, _notPunctuationOrSpace).replace(/punctSpace/g, _punctuationOrSpace).replace(/punct/g, _punctuation).getRegex();
var anyPunctuation = edit(/\\(punct)/, "gu").replace(/punct/g, _punctuation).getRegex();
var autolink = edit(/^<(scheme:[^\s\x00-\x1f<>]*|email)>/).replace("scheme", /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/).replace("email", /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/).getRegex();
var _inlineComment = edit(_comment).replace("(?:-->|$)", "-->").getRegex();
var tag = edit("^comment|^</[a-zA-Z][\\w:-]*\\s*>|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>|^<\\?[\\s\\S]*?\\?>|^<![a-zA-Z]+\\s[\\s\\S]*?>|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>").replace("comment", _inlineComment).replace("attribute", /\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/).getRegex();
var _inlineLabel = /(?:\[(?:\\.|[^\[\]\\])*\]|\\.|`[^`]*`|[^\[\]\\`])*?/;
var link = edit(/^!?\[(label)\]\(\s*(href)(?:\s+(title))?\s*\)/).replace("label", _inlineLabel).replace("href", /<(?:\\.|[^\n<>\\])+>|[^\s\x00-\x1f]*/).replace("title", /"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/).getRegex();
var reflink = edit(/^!?\[(label)\]\[(ref)\]/).replace("label", _inlineLabel).replace("ref", _blockLabel).getRegex();
var nolink = edit(/^!?\[(ref)\](?:\[\])?/).replace("ref", _blockLabel).getRegex();
var reflinkSearch = edit("reflink|nolink(?!\\()", "g").replace("reflink", reflink).replace("nolink", nolink).getRegex();
var inlineNormal = {
  _backpedal: noopTest,
  // only used for GFM url
  anyPunctuation,
  autolink,
  blockSkip,
  br,
  code: inlineCode,
  del: noopTest,
  emStrongLDelim,
  emStrongRDelimAst,
  emStrongRDelimUnd,
  escape: escape$1,
  link,
  nolink,
  punctuation,
  reflink,
  reflinkSearch,
  tag,
  text: inlineText,
  url: noopTest
};
var inlinePedantic = __spreadProps(__spreadValues({}, inlineNormal), {
  link: edit(/^!?\[(label)\]\((.*?)\)/).replace("label", _inlineLabel).getRegex(),
  reflink: edit(/^!?\[(label)\]\s*\[([^\]]*)\]/).replace("label", _inlineLabel).getRegex()
});
var inlineGfm = __spreadProps(__spreadValues({}, inlineNormal), {
  emStrongRDelimAst: emStrongRDelimAstGfm,
  emStrongLDelim: emStrongLDelimGfm,
  url: edit(/^((?:ftp|https?):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/, "i").replace("email", /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/).getRegex(),
  _backpedal: /(?:[^?!.,:;*_'"~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_'"~)]+(?!$))+/,
  del: /^(~~?)(?=[^\s~])((?:\\.|[^\\])*?(?:\\.|[^\s~\\]))\1(?=[^~]|$)/,
  text: /^([`~]+|[^`~])(?:(?= {2,}\n)|(?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)|[\s\S]*?(?:(?=[\\<!\[`*~_]|\b_|https?:\/\/|ftp:\/\/|www\.|$)|[^ ](?= {2,}\n)|[^a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-](?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)))/
});
var inlineBreaks = __spreadProps(__spreadValues({}, inlineGfm), {
  br: edit(br).replace("{2,}", "*").getRegex(),
  text: edit(inlineGfm.text).replace("\\b_", "\\b_| {2,}\\n").replace(/\{2,\}/g, "*").getRegex()
});
var block = {
  normal: blockNormal,
  gfm: blockGfm,
  pedantic: blockPedantic
};
var inline = {
  normal: inlineNormal,
  gfm: inlineGfm,
  breaks: inlineBreaks,
  pedantic: inlinePedantic
};
var escapeReplacements = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;"
};
var getEscapeReplacement = (ch) => escapeReplacements[ch];
function escape(html2, encode) {
  if (encode) {
    if (other.escapeTest.test(html2)) {
      return html2.replace(other.escapeReplace, getEscapeReplacement);
    }
  } else {
    if (other.escapeTestNoEncode.test(html2)) {
      return html2.replace(other.escapeReplaceNoEncode, getEscapeReplacement);
    }
  }
  return html2;
}
function cleanUrl(href) {
  try {
    href = encodeURI(href).replace(other.percentDecode, "%");
  } catch (e) {
    return null;
  }
  return href;
}
function splitCells(tableRow, count) {
  var _a;
  const row = tableRow.replace(other.findPipe, (match, offset, str) => {
    let escaped = false;
    let curr = offset;
    while (--curr >= 0 && str[curr] === "\\")
      escaped = !escaped;
    if (escaped) {
      return "|";
    } else {
      return " |";
    }
  }), cells = row.split(other.splitPipe);
  let i = 0;
  if (!cells[0].trim()) {
    cells.shift();
  }
  if (cells.length > 0 && !((_a = cells.at(-1)) == null ? void 0 : _a.trim())) {
    cells.pop();
  }
  if (count) {
    if (cells.length > count) {
      cells.splice(count);
    } else {
      while (cells.length < count)
        cells.push("");
    }
  }
  for (; i < cells.length; i++) {
    cells[i] = cells[i].trim().replace(other.slashPipe, "|");
  }
  return cells;
}
function rtrim(str, c, invert) {
  const l = str.length;
  if (l === 0) {
    return "";
  }
  let suffLen = 0;
  while (suffLen < l) {
    const currChar = str.charAt(l - suffLen - 1);
    if (currChar === c && true) {
      suffLen++;
    } else {
      break;
    }
  }
  return str.slice(0, l - suffLen);
}
function findClosingBracket(str, b) {
  if (str.indexOf(b[1]) === -1) {
    return -1;
  }
  let level = 0;
  for (let i = 0; i < str.length; i++) {
    if (str[i] === "\\") {
      i++;
    } else if (str[i] === b[0]) {
      level++;
    } else if (str[i] === b[1]) {
      level--;
      if (level < 0) {
        return i;
      }
    }
  }
  return -1;
}
function outputLink(cap, link2, raw, lexer2, rules) {
  const href = link2.href;
  const title = link2.title || null;
  const text = cap[1].replace(rules.other.outputLinkReplace, "$1");
  if (cap[0].charAt(0) !== "!") {
    lexer2.state.inLink = true;
    const token = {
      type: "link",
      raw,
      href,
      title,
      text,
      tokens: lexer2.inlineTokens(text)
    };
    lexer2.state.inLink = false;
    return token;
  }
  return {
    type: "image",
    raw,
    href,
    title,
    text
  };
}
function indentCodeCompensation(raw, text, rules) {
  const matchIndentToCode = raw.match(rules.other.indentCodeCompensation);
  if (matchIndentToCode === null) {
    return text;
  }
  const indentToCode = matchIndentToCode[1];
  return text.split("\n").map((node) => {
    const matchIndentInNode = node.match(rules.other.beginningSpace);
    if (matchIndentInNode === null) {
      return node;
    }
    const [indentInNode] = matchIndentInNode;
    if (indentInNode.length >= indentToCode.length) {
      return node.slice(indentToCode.length);
    }
    return node;
  }).join("\n");
}
var _Tokenizer = class {
  // set by the lexer
  constructor(options2) {
    __publicField(this, "options");
    __publicField(this, "rules");
    // set by the lexer
    __publicField(this, "lexer");
    this.options = options2 || _defaults;
  }
  space(src) {
    const cap = this.rules.block.newline.exec(src);
    if (cap && cap[0].length > 0) {
      return {
        type: "space",
        raw: cap[0]
      };
    }
  }
  code(src) {
    const cap = this.rules.block.code.exec(src);
    if (cap) {
      const text = cap[0].replace(this.rules.other.codeRemoveIndent, "");
      return {
        type: "code",
        raw: cap[0],
        codeBlockStyle: "indented",
        text: !this.options.pedantic ? rtrim(text, "\n") : text
      };
    }
  }
  fences(src) {
    const cap = this.rules.block.fences.exec(src);
    if (cap) {
      const raw = cap[0];
      const text = indentCodeCompensation(raw, cap[3] || "", this.rules);
      return {
        type: "code",
        raw,
        lang: cap[2] ? cap[2].trim().replace(this.rules.inline.anyPunctuation, "$1") : cap[2],
        text
      };
    }
  }
  heading(src) {
    const cap = this.rules.block.heading.exec(src);
    if (cap) {
      let text = cap[2].trim();
      if (this.rules.other.endingHash.test(text)) {
        const trimmed = rtrim(text, "#");
        if (this.options.pedantic) {
          text = trimmed.trim();
        } else if (!trimmed || this.rules.other.endingSpaceChar.test(trimmed)) {
          text = trimmed.trim();
        }
      }
      return {
        type: "heading",
        raw: cap[0],
        depth: cap[1].length,
        text,
        tokens: this.lexer.inline(text)
      };
    }
  }
  hr(src) {
    const cap = this.rules.block.hr.exec(src);
    if (cap) {
      return {
        type: "hr",
        raw: rtrim(cap[0], "\n")
      };
    }
  }
  blockquote(src) {
    const cap = this.rules.block.blockquote.exec(src);
    if (cap) {
      let lines = rtrim(cap[0], "\n").split("\n");
      let raw = "";
      let text = "";
      const tokens = [];
      while (lines.length > 0) {
        let inBlockquote = false;
        const currentLines = [];
        let i;
        for (i = 0; i < lines.length; i++) {
          if (this.rules.other.blockquoteStart.test(lines[i])) {
            currentLines.push(lines[i]);
            inBlockquote = true;
          } else if (!inBlockquote) {
            currentLines.push(lines[i]);
          } else {
            break;
          }
        }
        lines = lines.slice(i);
        const currentRaw = currentLines.join("\n");
        const currentText = currentRaw.replace(this.rules.other.blockquoteSetextReplace, "\n    $1").replace(this.rules.other.blockquoteSetextReplace2, "");
        raw = raw ? `${raw}
${currentRaw}` : currentRaw;
        text = text ? `${text}
${currentText}` : currentText;
        const top = this.lexer.state.top;
        this.lexer.state.top = true;
        this.lexer.blockTokens(currentText, tokens, true);
        this.lexer.state.top = top;
        if (lines.length === 0) {
          break;
        }
        const lastToken = tokens.at(-1);
        if ((lastToken == null ? void 0 : lastToken.type) === "code") {
          break;
        } else if ((lastToken == null ? void 0 : lastToken.type) === "blockquote") {
          const oldToken = lastToken;
          const newText = oldToken.raw + "\n" + lines.join("\n");
          const newToken = this.blockquote(newText);
          tokens[tokens.length - 1] = newToken;
          raw = raw.substring(0, raw.length - oldToken.raw.length) + newToken.raw;
          text = text.substring(0, text.length - oldToken.text.length) + newToken.text;
          break;
        } else if ((lastToken == null ? void 0 : lastToken.type) === "list") {
          const oldToken = lastToken;
          const newText = oldToken.raw + "\n" + lines.join("\n");
          const newToken = this.list(newText);
          tokens[tokens.length - 1] = newToken;
          raw = raw.substring(0, raw.length - lastToken.raw.length) + newToken.raw;
          text = text.substring(0, text.length - oldToken.raw.length) + newToken.raw;
          lines = newText.substring(tokens.at(-1).raw.length).split("\n");
          continue;
        }
      }
      return {
        type: "blockquote",
        raw,
        tokens,
        text
      };
    }
  }
  list(src) {
    let cap = this.rules.block.list.exec(src);
    if (cap) {
      let bull = cap[1].trim();
      const isordered = bull.length > 1;
      const list2 = {
        type: "list",
        raw: "",
        ordered: isordered,
        start: isordered ? +bull.slice(0, -1) : "",
        loose: false,
        items: []
      };
      bull = isordered ? `\\d{1,9}\\${bull.slice(-1)}` : `\\${bull}`;
      if (this.options.pedantic) {
        bull = isordered ? bull : "[*+-]";
      }
      const itemRegex = this.rules.other.listItemRegex(bull);
      let endsWithBlankLine = false;
      while (src) {
        let endEarly = false;
        let raw = "";
        let itemContents = "";
        if (!(cap = itemRegex.exec(src))) {
          break;
        }
        if (this.rules.block.hr.test(src)) {
          break;
        }
        raw = cap[0];
        src = src.substring(raw.length);
        let line = cap[2].split("\n", 1)[0].replace(this.rules.other.listReplaceTabs, (t) => " ".repeat(3 * t.length));
        let nextLine = src.split("\n", 1)[0];
        let blankLine = !line.trim();
        let indent = 0;
        if (this.options.pedantic) {
          indent = 2;
          itemContents = line.trimStart();
        } else if (blankLine) {
          indent = cap[1].length + 1;
        } else {
          indent = cap[2].search(this.rules.other.nonSpaceChar);
          indent = indent > 4 ? 1 : indent;
          itemContents = line.slice(indent);
          indent += cap[1].length;
        }
        if (blankLine && this.rules.other.blankLine.test(nextLine)) {
          raw += nextLine + "\n";
          src = src.substring(nextLine.length + 1);
          endEarly = true;
        }
        if (!endEarly) {
          const nextBulletRegex = this.rules.other.nextBulletRegex(indent);
          const hrRegex = this.rules.other.hrRegex(indent);
          const fencesBeginRegex = this.rules.other.fencesBeginRegex(indent);
          const headingBeginRegex = this.rules.other.headingBeginRegex(indent);
          const htmlBeginRegex = this.rules.other.htmlBeginRegex(indent);
          while (src) {
            const rawLine = src.split("\n", 1)[0];
            let nextLineWithoutTabs;
            nextLine = rawLine;
            if (this.options.pedantic) {
              nextLine = nextLine.replace(this.rules.other.listReplaceNesting, "  ");
              nextLineWithoutTabs = nextLine;
            } else {
              nextLineWithoutTabs = nextLine.replace(this.rules.other.tabCharGlobal, "    ");
            }
            if (fencesBeginRegex.test(nextLine)) {
              break;
            }
            if (headingBeginRegex.test(nextLine)) {
              break;
            }
            if (htmlBeginRegex.test(nextLine)) {
              break;
            }
            if (nextBulletRegex.test(nextLine)) {
              break;
            }
            if (hrRegex.test(nextLine)) {
              break;
            }
            if (nextLineWithoutTabs.search(this.rules.other.nonSpaceChar) >= indent || !nextLine.trim()) {
              itemContents += "\n" + nextLineWithoutTabs.slice(indent);
            } else {
              if (blankLine) {
                break;
              }
              if (line.replace(this.rules.other.tabCharGlobal, "    ").search(this.rules.other.nonSpaceChar) >= 4) {
                break;
              }
              if (fencesBeginRegex.test(line)) {
                break;
              }
              if (headingBeginRegex.test(line)) {
                break;
              }
              if (hrRegex.test(line)) {
                break;
              }
              itemContents += "\n" + nextLine;
            }
            if (!blankLine && !nextLine.trim()) {
              blankLine = true;
            }
            raw += rawLine + "\n";
            src = src.substring(rawLine.length + 1);
            line = nextLineWithoutTabs.slice(indent);
          }
        }
        if (!list2.loose) {
          if (endsWithBlankLine) {
            list2.loose = true;
          } else if (this.rules.other.doubleBlankLine.test(raw)) {
            endsWithBlankLine = true;
          }
        }
        let istask = null;
        let ischecked;
        if (this.options.gfm) {
          istask = this.rules.other.listIsTask.exec(itemContents);
          if (istask) {
            ischecked = istask[0] !== "[ ] ";
            itemContents = itemContents.replace(this.rules.other.listReplaceTask, "");
          }
        }
        list2.items.push({
          type: "list_item",
          raw,
          task: !!istask,
          checked: ischecked,
          loose: false,
          text: itemContents,
          tokens: []
        });
        list2.raw += raw;
      }
      const lastItem = list2.items.at(-1);
      if (lastItem) {
        lastItem.raw = lastItem.raw.trimEnd();
        lastItem.text = lastItem.text.trimEnd();
      } else {
        return;
      }
      list2.raw = list2.raw.trimEnd();
      for (let i = 0; i < list2.items.length; i++) {
        this.lexer.state.top = false;
        list2.items[i].tokens = this.lexer.blockTokens(list2.items[i].text, []);
        if (!list2.loose) {
          const spacers = list2.items[i].tokens.filter((t) => t.type === "space");
          const hasMultipleLineBreaks = spacers.length > 0 && spacers.some((t) => this.rules.other.anyLine.test(t.raw));
          list2.loose = hasMultipleLineBreaks;
        }
      }
      if (list2.loose) {
        for (let i = 0; i < list2.items.length; i++) {
          list2.items[i].loose = true;
        }
      }
      return list2;
    }
  }
  html(src) {
    const cap = this.rules.block.html.exec(src);
    if (cap) {
      const token = {
        type: "html",
        block: true,
        raw: cap[0],
        pre: cap[1] === "pre" || cap[1] === "script" || cap[1] === "style",
        text: cap[0]
      };
      return token;
    }
  }
  def(src) {
    const cap = this.rules.block.def.exec(src);
    if (cap) {
      const tag2 = cap[1].toLowerCase().replace(this.rules.other.multipleSpaceGlobal, " ");
      const href = cap[2] ? cap[2].replace(this.rules.other.hrefBrackets, "$1").replace(this.rules.inline.anyPunctuation, "$1") : "";
      const title = cap[3] ? cap[3].substring(1, cap[3].length - 1).replace(this.rules.inline.anyPunctuation, "$1") : cap[3];
      return {
        type: "def",
        tag: tag2,
        raw: cap[0],
        href,
        title
      };
    }
  }
  table(src) {
    var _a;
    const cap = this.rules.block.table.exec(src);
    if (!cap) {
      return;
    }
    if (!this.rules.other.tableDelimiter.test(cap[2])) {
      return;
    }
    const headers = splitCells(cap[1]);
    const aligns = cap[2].replace(this.rules.other.tableAlignChars, "").split("|");
    const rows = ((_a = cap[3]) == null ? void 0 : _a.trim()) ? cap[3].replace(this.rules.other.tableRowBlankLine, "").split("\n") : [];
    const item = {
      type: "table",
      raw: cap[0],
      header: [],
      align: [],
      rows: []
    };
    if (headers.length !== aligns.length) {
      return;
    }
    for (const align of aligns) {
      if (this.rules.other.tableAlignRight.test(align)) {
        item.align.push("right");
      } else if (this.rules.other.tableAlignCenter.test(align)) {
        item.align.push("center");
      } else if (this.rules.other.tableAlignLeft.test(align)) {
        item.align.push("left");
      } else {
        item.align.push(null);
      }
    }
    for (let i = 0; i < headers.length; i++) {
      item.header.push({
        text: headers[i],
        tokens: this.lexer.inline(headers[i]),
        header: true,
        align: item.align[i]
      });
    }
    for (const row of rows) {
      item.rows.push(splitCells(row, item.header.length).map((cell, i) => {
        return {
          text: cell,
          tokens: this.lexer.inline(cell),
          header: false,
          align: item.align[i]
        };
      }));
    }
    return item;
  }
  lheading(src) {
    const cap = this.rules.block.lheading.exec(src);
    if (cap) {
      return {
        type: "heading",
        raw: cap[0],
        depth: cap[2].charAt(0) === "=" ? 1 : 2,
        text: cap[1],
        tokens: this.lexer.inline(cap[1])
      };
    }
  }
  paragraph(src) {
    const cap = this.rules.block.paragraph.exec(src);
    if (cap) {
      const text = cap[1].charAt(cap[1].length - 1) === "\n" ? cap[1].slice(0, -1) : cap[1];
      return {
        type: "paragraph",
        raw: cap[0],
        text,
        tokens: this.lexer.inline(text)
      };
    }
  }
  text(src) {
    const cap = this.rules.block.text.exec(src);
    if (cap) {
      return {
        type: "text",
        raw: cap[0],
        text: cap[0],
        tokens: this.lexer.inline(cap[0])
      };
    }
  }
  escape(src) {
    const cap = this.rules.inline.escape.exec(src);
    if (cap) {
      return {
        type: "escape",
        raw: cap[0],
        text: cap[1]
      };
    }
  }
  tag(src) {
    const cap = this.rules.inline.tag.exec(src);
    if (cap) {
      if (!this.lexer.state.inLink && this.rules.other.startATag.test(cap[0])) {
        this.lexer.state.inLink = true;
      } else if (this.lexer.state.inLink && this.rules.other.endATag.test(cap[0])) {
        this.lexer.state.inLink = false;
      }
      if (!this.lexer.state.inRawBlock && this.rules.other.startPreScriptTag.test(cap[0])) {
        this.lexer.state.inRawBlock = true;
      } else if (this.lexer.state.inRawBlock && this.rules.other.endPreScriptTag.test(cap[0])) {
        this.lexer.state.inRawBlock = false;
      }
      return {
        type: "html",
        raw: cap[0],
        inLink: this.lexer.state.inLink,
        inRawBlock: this.lexer.state.inRawBlock,
        block: false,
        text: cap[0]
      };
    }
  }
  link(src) {
    const cap = this.rules.inline.link.exec(src);
    if (cap) {
      const trimmedUrl = cap[2].trim();
      if (!this.options.pedantic && this.rules.other.startAngleBracket.test(trimmedUrl)) {
        if (!this.rules.other.endAngleBracket.test(trimmedUrl)) {
          return;
        }
        const rtrimSlash = rtrim(trimmedUrl.slice(0, -1), "\\");
        if ((trimmedUrl.length - rtrimSlash.length) % 2 === 0) {
          return;
        }
      } else {
        const lastParenIndex = findClosingBracket(cap[2], "()");
        if (lastParenIndex > -1) {
          const start = cap[0].indexOf("!") === 0 ? 5 : 4;
          const linkLen = start + cap[1].length + lastParenIndex;
          cap[2] = cap[2].substring(0, lastParenIndex);
          cap[0] = cap[0].substring(0, linkLen).trim();
          cap[3] = "";
        }
      }
      let href = cap[2];
      let title = "";
      if (this.options.pedantic) {
        const link2 = this.rules.other.pedanticHrefTitle.exec(href);
        if (link2) {
          href = link2[1];
          title = link2[3];
        }
      } else {
        title = cap[3] ? cap[3].slice(1, -1) : "";
      }
      href = href.trim();
      if (this.rules.other.startAngleBracket.test(href)) {
        if (this.options.pedantic && !this.rules.other.endAngleBracket.test(trimmedUrl)) {
          href = href.slice(1);
        } else {
          href = href.slice(1, -1);
        }
      }
      return outputLink(cap, {
        href: href ? href.replace(this.rules.inline.anyPunctuation, "$1") : href,
        title: title ? title.replace(this.rules.inline.anyPunctuation, "$1") : title
      }, cap[0], this.lexer, this.rules);
    }
  }
  reflink(src, links) {
    let cap;
    if ((cap = this.rules.inline.reflink.exec(src)) || (cap = this.rules.inline.nolink.exec(src))) {
      const linkString = (cap[2] || cap[1]).replace(this.rules.other.multipleSpaceGlobal, " ");
      const link2 = links[linkString.toLowerCase()];
      if (!link2) {
        const text = cap[0].charAt(0);
        return {
          type: "text",
          raw: text,
          text
        };
      }
      return outputLink(cap, link2, cap[0], this.lexer, this.rules);
    }
  }
  emStrong(src, maskedSrc, prevChar = "") {
    let match = this.rules.inline.emStrongLDelim.exec(src);
    if (!match)
      return;
    if (match[3] && prevChar.match(this.rules.other.unicodeAlphaNumeric))
      return;
    const nextChar = match[1] || match[2] || "";
    if (!nextChar || !prevChar || this.rules.inline.punctuation.exec(prevChar)) {
      const lLength = [...match[0]].length - 1;
      let rDelim, rLength, delimTotal = lLength, midDelimTotal = 0;
      const endReg = match[0][0] === "*" ? this.rules.inline.emStrongRDelimAst : this.rules.inline.emStrongRDelimUnd;
      endReg.lastIndex = 0;
      maskedSrc = maskedSrc.slice(-1 * src.length + lLength);
      while ((match = endReg.exec(maskedSrc)) != null) {
        rDelim = match[1] || match[2] || match[3] || match[4] || match[5] || match[6];
        if (!rDelim)
          continue;
        rLength = [...rDelim].length;
        if (match[3] || match[4]) {
          delimTotal += rLength;
          continue;
        } else if (match[5] || match[6]) {
          if (lLength % 3 && !((lLength + rLength) % 3)) {
            midDelimTotal += rLength;
            continue;
          }
        }
        delimTotal -= rLength;
        if (delimTotal > 0)
          continue;
        rLength = Math.min(rLength, rLength + delimTotal + midDelimTotal);
        const lastCharLength = [...match[0]][0].length;
        const raw = src.slice(0, lLength + match.index + lastCharLength + rLength);
        if (Math.min(lLength, rLength) % 2) {
          const text2 = raw.slice(1, -1);
          return {
            type: "em",
            raw,
            text: text2,
            tokens: this.lexer.inlineTokens(text2)
          };
        }
        const text = raw.slice(2, -2);
        return {
          type: "strong",
          raw,
          text,
          tokens: this.lexer.inlineTokens(text)
        };
      }
    }
  }
  codespan(src) {
    const cap = this.rules.inline.code.exec(src);
    if (cap) {
      let text = cap[2].replace(this.rules.other.newLineCharGlobal, " ");
      const hasNonSpaceChars = this.rules.other.nonSpaceChar.test(text);
      const hasSpaceCharsOnBothEnds = this.rules.other.startingSpaceChar.test(text) && this.rules.other.endingSpaceChar.test(text);
      if (hasNonSpaceChars && hasSpaceCharsOnBothEnds) {
        text = text.substring(1, text.length - 1);
      }
      return {
        type: "codespan",
        raw: cap[0],
        text
      };
    }
  }
  br(src) {
    const cap = this.rules.inline.br.exec(src);
    if (cap) {
      return {
        type: "br",
        raw: cap[0]
      };
    }
  }
  del(src) {
    const cap = this.rules.inline.del.exec(src);
    if (cap) {
      return {
        type: "del",
        raw: cap[0],
        text: cap[2],
        tokens: this.lexer.inlineTokens(cap[2])
      };
    }
  }
  autolink(src) {
    const cap = this.rules.inline.autolink.exec(src);
    if (cap) {
      let text, href;
      if (cap[2] === "@") {
        text = cap[1];
        href = "mailto:" + text;
      } else {
        text = cap[1];
        href = text;
      }
      return {
        type: "link",
        raw: cap[0],
        text,
        href,
        tokens: [
          {
            type: "text",
            raw: text,
            text
          }
        ]
      };
    }
  }
  url(src) {
    var _a, _b;
    let cap;
    if (cap = this.rules.inline.url.exec(src)) {
      let text, href;
      if (cap[2] === "@") {
        text = cap[0];
        href = "mailto:" + text;
      } else {
        let prevCapZero;
        do {
          prevCapZero = cap[0];
          cap[0] = (_b = (_a = this.rules.inline._backpedal.exec(cap[0])) == null ? void 0 : _a[0]) != null ? _b : "";
        } while (prevCapZero !== cap[0]);
        text = cap[0];
        if (cap[1] === "www.") {
          href = "http://" + cap[0];
        } else {
          href = cap[0];
        }
      }
      return {
        type: "link",
        raw: cap[0],
        text,
        href,
        tokens: [
          {
            type: "text",
            raw: text,
            text
          }
        ]
      };
    }
  }
  inlineText(src) {
    const cap = this.rules.inline.text.exec(src);
    if (cap) {
      const escaped = this.lexer.state.inRawBlock;
      return {
        type: "text",
        raw: cap[0],
        text: cap[0],
        escaped
      };
    }
  }
};
var _Lexer = class __Lexer {
  constructor(options2) {
    __publicField(this, "tokens");
    __publicField(this, "options");
    __publicField(this, "state");
    __publicField(this, "tokenizer");
    __publicField(this, "inlineQueue");
    this.tokens = [];
    this.tokens.links = /* @__PURE__ */ Object.create(null);
    this.options = options2 || _defaults;
    this.options.tokenizer = this.options.tokenizer || new _Tokenizer();
    this.tokenizer = this.options.tokenizer;
    this.tokenizer.options = this.options;
    this.tokenizer.lexer = this;
    this.inlineQueue = [];
    this.state = {
      inLink: false,
      inRawBlock: false,
      top: true
    };
    const rules = {
      other,
      block: block.normal,
      inline: inline.normal
    };
    if (this.options.pedantic) {
      rules.block = block.pedantic;
      rules.inline = inline.pedantic;
    } else if (this.options.gfm) {
      rules.block = block.gfm;
      if (this.options.breaks) {
        rules.inline = inline.breaks;
      } else {
        rules.inline = inline.gfm;
      }
    }
    this.tokenizer.rules = rules;
  }
  /**
   * Expose Rules
   */
  static get rules() {
    return {
      block,
      inline
    };
  }
  /**
   * Static Lex Method
   */
  static lex(src, options2) {
    const lexer2 = new __Lexer(options2);
    return lexer2.lex(src);
  }
  /**
   * Static Lex Inline Method
   */
  static lexInline(src, options2) {
    const lexer2 = new __Lexer(options2);
    return lexer2.inlineTokens(src);
  }
  /**
   * Preprocessing
   */
  lex(src) {
    src = src.replace(other.carriageReturn, "\n");
    this.blockTokens(src, this.tokens);
    for (let i = 0; i < this.inlineQueue.length; i++) {
      const next = this.inlineQueue[i];
      this.inlineTokens(next.src, next.tokens);
    }
    this.inlineQueue = [];
    return this.tokens;
  }
  blockTokens(src, tokens = [], lastParagraphClipped = false) {
    var _a, _b, _c;
    if (this.options.pedantic) {
      src = src.replace(other.tabCharGlobal, "    ").replace(other.spaceLine, "");
    }
    while (src) {
      let token;
      if ((_b = (_a = this.options.extensions) == null ? void 0 : _a.block) == null ? void 0 : _b.some((extTokenizer) => {
        if (token = extTokenizer.call({ lexer: this }, src, tokens)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          return true;
        }
        return false;
      })) {
        continue;
      }
      if (token = this.tokenizer.space(src)) {
        src = src.substring(token.raw.length);
        const lastToken = tokens.at(-1);
        if (token.raw.length === 1 && lastToken !== void 0) {
          lastToken.raw += "\n";
        } else {
          tokens.push(token);
        }
        continue;
      }
      if (token = this.tokenizer.code(src)) {
        src = src.substring(token.raw.length);
        const lastToken = tokens.at(-1);
        if ((lastToken == null ? void 0 : lastToken.type) === "paragraph" || (lastToken == null ? void 0 : lastToken.type) === "text") {
          lastToken.raw += "\n" + token.raw;
          lastToken.text += "\n" + token.text;
          this.inlineQueue.at(-1).src = lastToken.text;
        } else {
          tokens.push(token);
        }
        continue;
      }
      if (token = this.tokenizer.fences(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.heading(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.hr(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.blockquote(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.list(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.html(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.def(src)) {
        src = src.substring(token.raw.length);
        const lastToken = tokens.at(-1);
        if ((lastToken == null ? void 0 : lastToken.type) === "paragraph" || (lastToken == null ? void 0 : lastToken.type) === "text") {
          lastToken.raw += "\n" + token.raw;
          lastToken.text += "\n" + token.raw;
          this.inlineQueue.at(-1).src = lastToken.text;
        } else if (!this.tokens.links[token.tag]) {
          this.tokens.links[token.tag] = {
            href: token.href,
            title: token.title
          };
        }
        continue;
      }
      if (token = this.tokenizer.table(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.lheading(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      let cutSrc = src;
      if ((_c = this.options.extensions) == null ? void 0 : _c.startBlock) {
        let startIndex = Infinity;
        const tempSrc = src.slice(1);
        let tempStart;
        this.options.extensions.startBlock.forEach((getStartIndex) => {
          tempStart = getStartIndex.call({ lexer: this }, tempSrc);
          if (typeof tempStart === "number" && tempStart >= 0) {
            startIndex = Math.min(startIndex, tempStart);
          }
        });
        if (startIndex < Infinity && startIndex >= 0) {
          cutSrc = src.substring(0, startIndex + 1);
        }
      }
      if (this.state.top && (token = this.tokenizer.paragraph(cutSrc))) {
        const lastToken = tokens.at(-1);
        if (lastParagraphClipped && (lastToken == null ? void 0 : lastToken.type) === "paragraph") {
          lastToken.raw += "\n" + token.raw;
          lastToken.text += "\n" + token.text;
          this.inlineQueue.pop();
          this.inlineQueue.at(-1).src = lastToken.text;
        } else {
          tokens.push(token);
        }
        lastParagraphClipped = cutSrc.length !== src.length;
        src = src.substring(token.raw.length);
        continue;
      }
      if (token = this.tokenizer.text(src)) {
        src = src.substring(token.raw.length);
        const lastToken = tokens.at(-1);
        if ((lastToken == null ? void 0 : lastToken.type) === "text") {
          lastToken.raw += "\n" + token.raw;
          lastToken.text += "\n" + token.text;
          this.inlineQueue.pop();
          this.inlineQueue.at(-1).src = lastToken.text;
        } else {
          tokens.push(token);
        }
        continue;
      }
      if (src) {
        const errMsg = "Infinite loop on byte: " + src.charCodeAt(0);
        if (this.options.silent) {
          console.error(errMsg);
          break;
        } else {
          throw new Error(errMsg);
        }
      }
    }
    this.state.top = true;
    return tokens;
  }
  inline(src, tokens = []) {
    this.inlineQueue.push({ src, tokens });
    return tokens;
  }
  /**
   * Lexing/Compiling
   */
  inlineTokens(src, tokens = []) {
    var _a, _b, _c;
    let maskedSrc = src;
    let match = null;
    if (this.tokens.links) {
      const links = Object.keys(this.tokens.links);
      if (links.length > 0) {
        while ((match = this.tokenizer.rules.inline.reflinkSearch.exec(maskedSrc)) != null) {
          if (links.includes(match[0].slice(match[0].lastIndexOf("[") + 1, -1))) {
            maskedSrc = maskedSrc.slice(0, match.index) + "[" + "a".repeat(match[0].length - 2) + "]" + maskedSrc.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex);
          }
        }
      }
    }
    while ((match = this.tokenizer.rules.inline.blockSkip.exec(maskedSrc)) != null) {
      maskedSrc = maskedSrc.slice(0, match.index) + "[" + "a".repeat(match[0].length - 2) + "]" + maskedSrc.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);
    }
    while ((match = this.tokenizer.rules.inline.anyPunctuation.exec(maskedSrc)) != null) {
      maskedSrc = maskedSrc.slice(0, match.index) + "++" + maskedSrc.slice(this.tokenizer.rules.inline.anyPunctuation.lastIndex);
    }
    let keepPrevChar = false;
    let prevChar = "";
    while (src) {
      if (!keepPrevChar) {
        prevChar = "";
      }
      keepPrevChar = false;
      let token;
      if ((_b = (_a = this.options.extensions) == null ? void 0 : _a.inline) == null ? void 0 : _b.some((extTokenizer) => {
        if (token = extTokenizer.call({ lexer: this }, src, tokens)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          return true;
        }
        return false;
      })) {
        continue;
      }
      if (token = this.tokenizer.escape(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.tag(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.link(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.reflink(src, this.tokens.links)) {
        src = src.substring(token.raw.length);
        const lastToken = tokens.at(-1);
        if (token.type === "text" && (lastToken == null ? void 0 : lastToken.type) === "text") {
          lastToken.raw += token.raw;
          lastToken.text += token.text;
        } else {
          tokens.push(token);
        }
        continue;
      }
      if (token = this.tokenizer.emStrong(src, maskedSrc, prevChar)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.codespan(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.br(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.del(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.autolink(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (!this.state.inLink && (token = this.tokenizer.url(src))) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      let cutSrc = src;
      if ((_c = this.options.extensions) == null ? void 0 : _c.startInline) {
        let startIndex = Infinity;
        const tempSrc = src.slice(1);
        let tempStart;
        this.options.extensions.startInline.forEach((getStartIndex) => {
          tempStart = getStartIndex.call({ lexer: this }, tempSrc);
          if (typeof tempStart === "number" && tempStart >= 0) {
            startIndex = Math.min(startIndex, tempStart);
          }
        });
        if (startIndex < Infinity && startIndex >= 0) {
          cutSrc = src.substring(0, startIndex + 1);
        }
      }
      if (token = this.tokenizer.inlineText(cutSrc)) {
        src = src.substring(token.raw.length);
        if (token.raw.slice(-1) !== "_") {
          prevChar = token.raw.slice(-1);
        }
        keepPrevChar = true;
        const lastToken = tokens.at(-1);
        if ((lastToken == null ? void 0 : lastToken.type) === "text") {
          lastToken.raw += token.raw;
          lastToken.text += token.text;
        } else {
          tokens.push(token);
        }
        continue;
      }
      if (src) {
        const errMsg = "Infinite loop on byte: " + src.charCodeAt(0);
        if (this.options.silent) {
          console.error(errMsg);
          break;
        } else {
          throw new Error(errMsg);
        }
      }
    }
    return tokens;
  }
};
var _Renderer = class {
  // set by the parser
  constructor(options2) {
    __publicField(this, "options");
    __publicField(this, "parser");
    this.options = options2 || _defaults;
  }
  space(token) {
    return "";
  }
  code({ text, lang, escaped }) {
    var _a;
    const langString = (_a = (lang || "").match(other.notSpaceStart)) == null ? void 0 : _a[0];
    const code = text.replace(other.endingNewline, "") + "\n";
    if (!langString) {
      return "<pre><code>" + (escaped ? code : escape(code, true)) + "</code></pre>\n";
    }
    return '<pre><code class="language-' + escape(langString) + '">' + (escaped ? code : escape(code, true)) + "</code></pre>\n";
  }
  blockquote({ tokens }) {
    const body = this.parser.parse(tokens);
    return `<blockquote>
${body}</blockquote>
`;
  }
  html({ text }) {
    return text;
  }
  heading({ tokens, depth }) {
    return `<h${depth}>${this.parser.parseInline(tokens)}</h${depth}>
`;
  }
  hr(token) {
    return "<hr>\n";
  }
  list(token) {
    const ordered = token.ordered;
    const start = token.start;
    let body = "";
    for (let j = 0; j < token.items.length; j++) {
      const item = token.items[j];
      body += this.listitem(item);
    }
    const type = ordered ? "ol" : "ul";
    const startAttr = ordered && start !== 1 ? ' start="' + start + '"' : "";
    return "<" + type + startAttr + ">\n" + body + "</" + type + ">\n";
  }
  listitem(item) {
    var _a;
    let itemBody = "";
    if (item.task) {
      const checkbox = this.checkbox({ checked: !!item.checked });
      if (item.loose) {
        if (((_a = item.tokens[0]) == null ? void 0 : _a.type) === "paragraph") {
          item.tokens[0].text = checkbox + " " + item.tokens[0].text;
          if (item.tokens[0].tokens && item.tokens[0].tokens.length > 0 && item.tokens[0].tokens[0].type === "text") {
            item.tokens[0].tokens[0].text = checkbox + " " + escape(item.tokens[0].tokens[0].text);
            item.tokens[0].tokens[0].escaped = true;
          }
        } else {
          item.tokens.unshift({
            type: "text",
            raw: checkbox + " ",
            text: checkbox + " ",
            escaped: true
          });
        }
      } else {
        itemBody += checkbox + " ";
      }
    }
    itemBody += this.parser.parse(item.tokens, !!item.loose);
    return `<li>${itemBody}</li>
`;
  }
  checkbox({ checked }) {
    return "<input " + (checked ? 'checked="" ' : "") + 'disabled="" type="checkbox">';
  }
  paragraph({ tokens }) {
    return `<p>${this.parser.parseInline(tokens)}</p>
`;
  }
  table(token) {
    let header = "";
    let cell = "";
    for (let j = 0; j < token.header.length; j++) {
      cell += this.tablecell(token.header[j]);
    }
    header += this.tablerow({ text: cell });
    let body = "";
    for (let j = 0; j < token.rows.length; j++) {
      const row = token.rows[j];
      cell = "";
      for (let k = 0; k < row.length; k++) {
        cell += this.tablecell(row[k]);
      }
      body += this.tablerow({ text: cell });
    }
    if (body)
      body = `<tbody>${body}</tbody>`;
    return "<table>\n<thead>\n" + header + "</thead>\n" + body + "</table>\n";
  }
  tablerow({ text }) {
    return `<tr>
${text}</tr>
`;
  }
  tablecell(token) {
    const content = this.parser.parseInline(token.tokens);
    const type = token.header ? "th" : "td";
    const tag2 = token.align ? `<${type} align="${token.align}">` : `<${type}>`;
    return tag2 + content + `</${type}>
`;
  }
  /**
   * span level renderer
   */
  strong({ tokens }) {
    return `<strong>${this.parser.parseInline(tokens)}</strong>`;
  }
  em({ tokens }) {
    return `<em>${this.parser.parseInline(tokens)}</em>`;
  }
  codespan({ text }) {
    return `<code>${escape(text, true)}</code>`;
  }
  br(token) {
    return "<br>";
  }
  del({ tokens }) {
    return `<del>${this.parser.parseInline(tokens)}</del>`;
  }
  link({ href, title, tokens }) {
    const text = this.parser.parseInline(tokens);
    const cleanHref = cleanUrl(href);
    if (cleanHref === null) {
      return text;
    }
    href = cleanHref;
    let out = '<a href="' + href + '"';
    if (title) {
      out += ' title="' + escape(title) + '"';
    }
    out += ">" + text + "</a>";
    return out;
  }
  image({ href, title, text }) {
    const cleanHref = cleanUrl(href);
    if (cleanHref === null) {
      return escape(text);
    }
    href = cleanHref;
    let out = `<img src="${href}" alt="${text}"`;
    if (title) {
      out += ` title="${escape(title)}"`;
    }
    out += ">";
    return out;
  }
  text(token) {
    return "tokens" in token && token.tokens ? this.parser.parseInline(token.tokens) : "escaped" in token && token.escaped ? token.text : escape(token.text);
  }
};
var _TextRenderer = class {
  // no need for block level renderers
  strong({ text }) {
    return text;
  }
  em({ text }) {
    return text;
  }
  codespan({ text }) {
    return text;
  }
  del({ text }) {
    return text;
  }
  html({ text }) {
    return text;
  }
  text({ text }) {
    return text;
  }
  link({ text }) {
    return "" + text;
  }
  image({ text }) {
    return "" + text;
  }
  br() {
    return "";
  }
};
var _Parser = class __Parser {
  constructor(options2) {
    __publicField(this, "options");
    __publicField(this, "renderer");
    __publicField(this, "textRenderer");
    this.options = options2 || _defaults;
    this.options.renderer = this.options.renderer || new _Renderer();
    this.renderer = this.options.renderer;
    this.renderer.options = this.options;
    this.renderer.parser = this;
    this.textRenderer = new _TextRenderer();
  }
  /**
   * Static Parse Method
   */
  static parse(tokens, options2) {
    const parser2 = new __Parser(options2);
    return parser2.parse(tokens);
  }
  /**
   * Static Parse Inline Method
   */
  static parseInline(tokens, options2) {
    const parser2 = new __Parser(options2);
    return parser2.parseInline(tokens);
  }
  /**
   * Parse Loop
   */
  parse(tokens, top = true) {
    var _a, _b;
    let out = "";
    for (let i = 0; i < tokens.length; i++) {
      const anyToken = tokens[i];
      if ((_b = (_a = this.options.extensions) == null ? void 0 : _a.renderers) == null ? void 0 : _b[anyToken.type]) {
        const genericToken = anyToken;
        const ret = this.options.extensions.renderers[genericToken.type].call({ parser: this }, genericToken);
        if (ret !== false || !["space", "hr", "heading", "code", "table", "blockquote", "list", "html", "paragraph", "text"].includes(genericToken.type)) {
          out += ret || "";
          continue;
        }
      }
      const token = anyToken;
      switch (token.type) {
        case "space": {
          out += this.renderer.space(token);
          continue;
        }
        case "hr": {
          out += this.renderer.hr(token);
          continue;
        }
        case "heading": {
          out += this.renderer.heading(token);
          continue;
        }
        case "code": {
          out += this.renderer.code(token);
          continue;
        }
        case "table": {
          out += this.renderer.table(token);
          continue;
        }
        case "blockquote": {
          out += this.renderer.blockquote(token);
          continue;
        }
        case "list": {
          out += this.renderer.list(token);
          continue;
        }
        case "html": {
          out += this.renderer.html(token);
          continue;
        }
        case "paragraph": {
          out += this.renderer.paragraph(token);
          continue;
        }
        case "text": {
          let textToken = token;
          let body = this.renderer.text(textToken);
          while (i + 1 < tokens.length && tokens[i + 1].type === "text") {
            textToken = tokens[++i];
            body += "\n" + this.renderer.text(textToken);
          }
          if (top) {
            out += this.renderer.paragraph({
              type: "paragraph",
              raw: body,
              text: body,
              tokens: [{ type: "text", raw: body, text: body, escaped: true }]
            });
          } else {
            out += body;
          }
          continue;
        }
        default: {
          const errMsg = 'Token with "' + token.type + '" type was not found.';
          if (this.options.silent) {
            console.error(errMsg);
            return "";
          } else {
            throw new Error(errMsg);
          }
        }
      }
    }
    return out;
  }
  /**
   * Parse Inline Tokens
   */
  parseInline(tokens, renderer = this.renderer) {
    var _a, _b;
    let out = "";
    for (let i = 0; i < tokens.length; i++) {
      const anyToken = tokens[i];
      if ((_b = (_a = this.options.extensions) == null ? void 0 : _a.renderers) == null ? void 0 : _b[anyToken.type]) {
        const ret = this.options.extensions.renderers[anyToken.type].call({ parser: this }, anyToken);
        if (ret !== false || !["escape", "html", "link", "image", "strong", "em", "codespan", "br", "del", "text"].includes(anyToken.type)) {
          out += ret || "";
          continue;
        }
      }
      const token = anyToken;
      switch (token.type) {
        case "escape": {
          out += renderer.text(token);
          break;
        }
        case "html": {
          out += renderer.html(token);
          break;
        }
        case "link": {
          out += renderer.link(token);
          break;
        }
        case "image": {
          out += renderer.image(token);
          break;
        }
        case "strong": {
          out += renderer.strong(token);
          break;
        }
        case "em": {
          out += renderer.em(token);
          break;
        }
        case "codespan": {
          out += renderer.codespan(token);
          break;
        }
        case "br": {
          out += renderer.br(token);
          break;
        }
        case "del": {
          out += renderer.del(token);
          break;
        }
        case "text": {
          out += renderer.text(token);
          break;
        }
        default: {
          const errMsg = 'Token with "' + token.type + '" type was not found.';
          if (this.options.silent) {
            console.error(errMsg);
            return "";
          } else {
            throw new Error(errMsg);
          }
        }
      }
    }
    return out;
  }
};
var _Hooks = class {
  constructor(options2) {
    __publicField(this, "options");
    __publicField(this, "block");
    this.options = options2 || _defaults;
  }
  /**
   * Process markdown before marked
   */
  preprocess(markdown) {
    return markdown;
  }
  /**
   * Process HTML after marked is finished
   */
  postprocess(html2) {
    return html2;
  }
  /**
   * Process all tokens before walk tokens
   */
  processAllTokens(tokens) {
    return tokens;
  }
  /**
   * Provide function to tokenize markdown
   */
  provideLexer() {
    return this.block ? _Lexer.lex : _Lexer.lexInline;
  }
  /**
   * Provide function to parse tokens
   */
  provideParser() {
    return this.block ? _Parser.parse : _Parser.parseInline;
  }
};
__publicField(_Hooks, "passThroughHooks", /* @__PURE__ */ new Set([
  "preprocess",
  "postprocess",
  "processAllTokens"
]));
var Marked = class {
  constructor(...args) {
    __publicField(this, "defaults", _getDefaults());
    __publicField(this, "options", this.setOptions);
    __publicField(this, "parse", this.parseMarkdown(true));
    __publicField(this, "parseInline", this.parseMarkdown(false));
    __publicField(this, "Parser", _Parser);
    __publicField(this, "Renderer", _Renderer);
    __publicField(this, "TextRenderer", _TextRenderer);
    __publicField(this, "Lexer", _Lexer);
    __publicField(this, "Tokenizer", _Tokenizer);
    __publicField(this, "Hooks", _Hooks);
    this.use(...args);
  }
  /**
   * Run callback for every token
   */
  walkTokens(tokens, callback) {
    var _a, _b;
    let values = [];
    for (const token of tokens) {
      values = values.concat(callback.call(this, token));
      switch (token.type) {
        case "table": {
          const tableToken = token;
          for (const cell of tableToken.header) {
            values = values.concat(this.walkTokens(cell.tokens, callback));
          }
          for (const row of tableToken.rows) {
            for (const cell of row) {
              values = values.concat(this.walkTokens(cell.tokens, callback));
            }
          }
          break;
        }
        case "list": {
          const listToken = token;
          values = values.concat(this.walkTokens(listToken.items, callback));
          break;
        }
        default: {
          const genericToken = token;
          if ((_b = (_a = this.defaults.extensions) == null ? void 0 : _a.childTokens) == null ? void 0 : _b[genericToken.type]) {
            this.defaults.extensions.childTokens[genericToken.type].forEach((childTokens) => {
              const tokens2 = genericToken[childTokens].flat(Infinity);
              values = values.concat(this.walkTokens(tokens2, callback));
            });
          } else if (genericToken.tokens) {
            values = values.concat(this.walkTokens(genericToken.tokens, callback));
          }
        }
      }
    }
    return values;
  }
  use(...args) {
    const extensions = this.defaults.extensions || { renderers: {}, childTokens: {} };
    args.forEach((pack) => {
      const opts = __spreadValues({}, pack);
      opts.async = this.defaults.async || opts.async || false;
      if (pack.extensions) {
        pack.extensions.forEach((ext) => {
          if (!ext.name) {
            throw new Error("extension name required");
          }
          if ("renderer" in ext) {
            const prevRenderer = extensions.renderers[ext.name];
            if (prevRenderer) {
              extensions.renderers[ext.name] = function(...args2) {
                let ret = ext.renderer.apply(this, args2);
                if (ret === false) {
                  ret = prevRenderer.apply(this, args2);
                }
                return ret;
              };
            } else {
              extensions.renderers[ext.name] = ext.renderer;
            }
          }
          if ("tokenizer" in ext) {
            if (!ext.level || ext.level !== "block" && ext.level !== "inline") {
              throw new Error("extension level must be 'block' or 'inline'");
            }
            const extLevel = extensions[ext.level];
            if (extLevel) {
              extLevel.unshift(ext.tokenizer);
            } else {
              extensions[ext.level] = [ext.tokenizer];
            }
            if (ext.start) {
              if (ext.level === "block") {
                if (extensions.startBlock) {
                  extensions.startBlock.push(ext.start);
                } else {
                  extensions.startBlock = [ext.start];
                }
              } else if (ext.level === "inline") {
                if (extensions.startInline) {
                  extensions.startInline.push(ext.start);
                } else {
                  extensions.startInline = [ext.start];
                }
              }
            }
          }
          if ("childTokens" in ext && ext.childTokens) {
            extensions.childTokens[ext.name] = ext.childTokens;
          }
        });
        opts.extensions = extensions;
      }
      if (pack.renderer) {
        const renderer = this.defaults.renderer || new _Renderer(this.defaults);
        for (const prop in pack.renderer) {
          if (!(prop in renderer)) {
            throw new Error(`renderer '${prop}' does not exist`);
          }
          if (["options", "parser"].includes(prop)) {
            continue;
          }
          const rendererProp = prop;
          const rendererFunc = pack.renderer[rendererProp];
          const prevRenderer = renderer[rendererProp];
          renderer[rendererProp] = (...args2) => {
            let ret = rendererFunc.apply(renderer, args2);
            if (ret === false) {
              ret = prevRenderer.apply(renderer, args2);
            }
            return ret || "";
          };
        }
        opts.renderer = renderer;
      }
      if (pack.tokenizer) {
        const tokenizer = this.defaults.tokenizer || new _Tokenizer(this.defaults);
        for (const prop in pack.tokenizer) {
          if (!(prop in tokenizer)) {
            throw new Error(`tokenizer '${prop}' does not exist`);
          }
          if (["options", "rules", "lexer"].includes(prop)) {
            continue;
          }
          const tokenizerProp = prop;
          const tokenizerFunc = pack.tokenizer[tokenizerProp];
          const prevTokenizer = tokenizer[tokenizerProp];
          tokenizer[tokenizerProp] = (...args2) => {
            let ret = tokenizerFunc.apply(tokenizer, args2);
            if (ret === false) {
              ret = prevTokenizer.apply(tokenizer, args2);
            }
            return ret;
          };
        }
        opts.tokenizer = tokenizer;
      }
      if (pack.hooks) {
        const hooks = this.defaults.hooks || new _Hooks();
        for (const prop in pack.hooks) {
          if (!(prop in hooks)) {
            throw new Error(`hook '${prop}' does not exist`);
          }
          if (["options", "block"].includes(prop)) {
            continue;
          }
          const hooksProp = prop;
          const hooksFunc = pack.hooks[hooksProp];
          const prevHook = hooks[hooksProp];
          if (_Hooks.passThroughHooks.has(prop)) {
            hooks[hooksProp] = (arg) => {
              if (this.defaults.async) {
                return Promise.resolve(hooksFunc.call(hooks, arg)).then((ret2) => {
                  return prevHook.call(hooks, ret2);
                });
              }
              const ret = hooksFunc.call(hooks, arg);
              return prevHook.call(hooks, ret);
            };
          } else {
            hooks[hooksProp] = (...args2) => {
              let ret = hooksFunc.apply(hooks, args2);
              if (ret === false) {
                ret = prevHook.apply(hooks, args2);
              }
              return ret;
            };
          }
        }
        opts.hooks = hooks;
      }
      if (pack.walkTokens) {
        const walkTokens2 = this.defaults.walkTokens;
        const packWalktokens = pack.walkTokens;
        opts.walkTokens = function(token) {
          let values = [];
          values.push(packWalktokens.call(this, token));
          if (walkTokens2) {
            values = values.concat(walkTokens2.call(this, token));
          }
          return values;
        };
      }
      this.defaults = __spreadValues(__spreadValues({}, this.defaults), opts);
    });
    return this;
  }
  setOptions(opt) {
    this.defaults = __spreadValues(__spreadValues({}, this.defaults), opt);
    return this;
  }
  lexer(src, options2) {
    return _Lexer.lex(src, options2 != null ? options2 : this.defaults);
  }
  parser(tokens, options2) {
    return _Parser.parse(tokens, options2 != null ? options2 : this.defaults);
  }
  parseMarkdown(blockType) {
    const parse = (src, options2) => {
      const origOpt = __spreadValues({}, options2);
      const opt = __spreadValues(__spreadValues({}, this.defaults), origOpt);
      const throwError = this.onError(!!opt.silent, !!opt.async);
      if (this.defaults.async === true && origOpt.async === false) {
        return throwError(new Error("marked(): The async option was set to true by an extension. Remove async: false from the parse options object to return a Promise."));
      }
      if (typeof src === "undefined" || src === null) {
        return throwError(new Error("marked(): input parameter is undefined or null"));
      }
      if (typeof src !== "string") {
        return throwError(new Error("marked(): input parameter is of type " + Object.prototype.toString.call(src) + ", string expected"));
      }
      if (opt.hooks) {
        opt.hooks.options = opt;
        opt.hooks.block = blockType;
      }
      const lexer2 = opt.hooks ? opt.hooks.provideLexer() : blockType ? _Lexer.lex : _Lexer.lexInline;
      const parser2 = opt.hooks ? opt.hooks.provideParser() : blockType ? _Parser.parse : _Parser.parseInline;
      if (opt.async) {
        return Promise.resolve(opt.hooks ? opt.hooks.preprocess(src) : src).then((src2) => lexer2(src2, opt)).then((tokens) => opt.hooks ? opt.hooks.processAllTokens(tokens) : tokens).then((tokens) => opt.walkTokens ? Promise.all(this.walkTokens(tokens, opt.walkTokens)).then(() => tokens) : tokens).then((tokens) => parser2(tokens, opt)).then((html2) => opt.hooks ? opt.hooks.postprocess(html2) : html2).catch(throwError);
      }
      try {
        if (opt.hooks) {
          src = opt.hooks.preprocess(src);
        }
        let tokens = lexer2(src, opt);
        if (opt.hooks) {
          tokens = opt.hooks.processAllTokens(tokens);
        }
        if (opt.walkTokens) {
          this.walkTokens(tokens, opt.walkTokens);
        }
        let html2 = parser2(tokens, opt);
        if (opt.hooks) {
          html2 = opt.hooks.postprocess(html2);
        }
        return html2;
      } catch (e) {
        return throwError(e);
      }
    };
    return parse;
  }
  onError(silent, async) {
    return (e) => {
      e.message += "\nPlease report this to https://github.com/markedjs/marked.";
      if (silent) {
        const msg = "<p>An error occurred:</p><pre>" + escape(e.message + "", true) + "</pre>";
        if (async) {
          return Promise.resolve(msg);
        }
        return msg;
      }
      if (async) {
        return Promise.reject(e);
      }
      throw e;
    };
  }
};
var markedInstance = new Marked();
function marked(src, opt) {
  return markedInstance.parse(src, opt);
}
marked.options = marked.setOptions = function(options2) {
  markedInstance.setOptions(options2);
  marked.defaults = markedInstance.defaults;
  changeDefaults(marked.defaults);
  return marked;
};
marked.getDefaults = _getDefaults;
marked.defaults = _defaults;
marked.use = function(...args) {
  markedInstance.use(...args);
  marked.defaults = markedInstance.defaults;
  changeDefaults(marked.defaults);
  return marked;
};
marked.walkTokens = function(tokens, callback) {
  return markedInstance.walkTokens(tokens, callback);
};
marked.parseInline = markedInstance.parseInline;
marked.Parser = _Parser;
marked.parser = _Parser.parse;
marked.Renderer = _Renderer;
marked.TextRenderer = _TextRenderer;
marked.Lexer = _Lexer;
marked.lexer = _Lexer.lex;
marked.Tokenizer = _Tokenizer;
marked.Hooks = _Hooks;
marked.parse = marked;
var options = marked.options;
var setOptions = marked.setOptions;
var use = marked.use;
var walkTokens = marked.walkTokens;
var parseInline = marked.parseInline;
var parser = _Parser.parse;
var lexer = _Lexer.lex;

// src/MarkdownRenderer.ts
var import_obsidian = require("obsidian");
var MarkdownRenderer = class _MarkdownRenderer extends import_obsidian.Component {
  constructor(container, content, app) {
    super();
    this.container = container;
    this.content = content;
    this.app = app;
  }
  static renderMarkdown(content, container, sourcePath, component) {
    return __async(this, null, function* () {
      const renderer = new _MarkdownRenderer(container, content, component.app);
      yield renderer.render();
    });
  }
  render() {
    return __async(this, null, function* () {
      try {
        this.container.empty();
        this.container.addClass("markdown-rendered");
        const rendered = yield marked.parse(this.content, { async: true });
        const tempDiv = document.createElement("div");
        tempDiv.innerHTML = rendered;
        const fragment = document.createDocumentFragment();
        while (tempDiv.firstChild) {
          fragment.appendChild(tempDiv.firstChild);
        }
        this.container.appendChild(fragment);
      } catch (error) {
        console.error("Error rendering markdown:", error);
        this.container.setText("Error rendering content: " + error.message);
      }
    });
  }
  /**
   * Get content from the current editor
   */
  static getCurrentFileContent(app) {
    try {
      const activeLeaf = app.workspace.activeLeaf;
      if (!activeLeaf) return null;
      const view = activeLeaf.view;
      if (!view || !("editor" in view)) return null;
      return view.editor.getValue();
    } catch (error) {
      console.error("Error getting file content:", error);
      return null;
    }
  }
};

// src/ChatView.ts
var VIEW_TYPE_CHAT = "chat-view";
var ConfirmModal = class extends import_obsidian2.Modal {
  constructor(app, message, onConfirm) {
    super(app);
    this.message = message;
    this.onConfirm = onConfirm;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("confirm-modal");
    contentEl.createEl("p", { text: this.message, cls: "confirm-message" });
    const buttonContainer = contentEl.createDiv({ cls: "confirm-button-container" });
    const confirmBtn = buttonContainer.createEl("button", { text: "Confirm", cls: "confirm-button" });
    const cancelBtn = buttonContainer.createEl("button", { text: "Cancel", cls: "cancel-button" });
    confirmBtn.onclick = () => {
      this.close();
      this.onConfirm();
    };
    cancelBtn.onclick = () => {
      this.close();
    };
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var ChatHistoryModal = class extends import_obsidian2.Modal {
  constructor(app, histories, onSelect, plugin) {
    super(app);
    this.histories = histories;
    this.onSelect = onSelect;
    this.plugin = plugin;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("chat-history-modal");
    const headerContainer = contentEl.createDiv({ cls: "history-header-container" });
    headerContainer.createEl("h2", { text: "Chat History" });
    this.addExportButton(headerContainer, this.histories);
    const searchInput = this.addSearchBar(contentEl);
    this.setupModalKeyboardShortcuts(searchInput);
    if (this.histories.length === 0) {
      contentEl.createEl("p", { text: "No chat history found." });
      return;
    }
    const historyList = contentEl.createDiv({ cls: "history-list" });
    const pinnedHistories = this.histories.filter((h) => h.pinned);
    if (pinnedHistories.length > 0) {
      const pinnedSection = historyList.createDiv({ cls: "pinned-section" });
      const pinnedHeader = pinnedSection.createEl("h3", { text: "Pinned Conversations", cls: "pinned-header" });
      pinnedHistories.forEach((history) => {
        this.createHistoryItem(pinnedSection, history);
      });
    }
    const conversationsByDate = /* @__PURE__ */ new Map();
    this.histories.filter((h) => !h.pinned).forEach((history) => {
      var _a;
      const date = new Date(history.date);
      const dateKey = `${date.getFullYear()}-${date.getMonth() + 1}-${date.getDate()}`;
      if (!conversationsByDate.has(dateKey)) {
        conversationsByDate.set(dateKey, []);
      }
      (_a = conversationsByDate.get(dateKey)) == null ? void 0 : _a.push(history);
    });
    const sortedDates = Array.from(conversationsByDate.keys()).sort((a, b) => new Date(b).getTime() - new Date(a).getTime());
    sortedDates.forEach((dateKey) => {
      const conversations = conversationsByDate.get(dateKey);
      if (!conversations || conversations.length === 0) return;
      const dateObj = new Date(dateKey);
      const dateHeader = historyList.createDiv({ cls: "history-date-header" });
      dateHeader.setText(dateObj.toLocaleDateString(void 0, {
        weekday: "long",
        year: "numeric",
        month: "long",
        day: "numeric"
      }));
      const dateGroup = historyList.createDiv({ cls: "history-date-group" });
      conversations.forEach((history) => {
        this.createHistoryItem(dateGroup, history);
      });
    });
    const keyboardHelpText = contentEl.createDiv({ cls: "keyboard-help-text" });
    keyboardHelpText.setText("Tip: Use up/down arrows to navigate, Enter to select, Esc to close");
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
  addExportButton(container, histories) {
    if (histories.length === 0) return;
    const exportButtonContainer = container.createDiv({ cls: "export-button-container" });
    const exportButton = exportButtonContainer.createEl("button", {
      text: "Export All Conversations",
      cls: "export-button"
    });
    exportButton.addEventListener("click", () => __async(this, null, function* () {
      try {
        const markdownContent = this.generateMarkdownExport(histories);
        const textArea = document.createElement("textarea");
        textArea.value = markdownContent;
        document.body.appendChild(textArea);
        textArea.select();
        document.execCommand("copy");
        document.body.removeChild(textArea);
        const blob = new Blob([markdownContent], { type: "text/markdown" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = `chat-history-export-${(/* @__PURE__ */ new Date()).toISOString().slice(0, 10)}.md`;
        document.body.appendChild(a);
        a.click();
        setTimeout(() => {
          document.body.removeChild(a);
          URL.revokeObjectURL(url);
        }, 100);
        new import_obsidian2.Notice("Chat history exported and copied to clipboard", 2e3);
      } catch (error) {
        console.error("Failed to export chat history:", error);
        new import_obsidian2.Notice("Failed to export chat history", 2e3);
      }
    }));
  }
  generateMarkdownExport(histories) {
    const sortedHistories = [...histories].sort((a, b) => b.date - a.date);
    let markdownContent = `# Chat History Export
Exported on ${(/* @__PURE__ */ new Date()).toLocaleString()}

`;
    sortedHistories.forEach((history, index) => {
      markdownContent += `## Conversation ${index + 1}: ${history.title}
`;
      markdownContent += `Date: ${new Date(history.date).toLocaleString()}

`;
      history.messages.forEach((message) => {
        const role = message.role === "user" ? "\u{1F464} User" : "\u{1F916} AI";
        markdownContent += `### ${role}

${message.content}

`;
      });
      markdownContent += `---

`;
    });
    return markdownContent;
  }
  addSearchBar(container) {
    const searchContainer = container.createDiv({ cls: "history-search-container" });
    const searchInput = searchContainer.createEl("input", {
      type: "text",
      placeholder: "Search conversations...",
      cls: "history-search-input"
    });
    const clearButton = searchContainer.createEl("button", {
      cls: "history-search-clear",
      attr: { "aria-label": "Clear search" }
    });
    (0, import_obsidian2.setIcon)(clearButton, "x");
    clearButton.style.display = "none";
    searchInput.addEventListener("input", () => {
      const query = searchInput.value.toLowerCase().trim();
      clearButton.style.display = query ? "flex" : "none";
      this.filterHistoryItems(query);
    });
    clearButton.addEventListener("click", () => {
      searchInput.value = "";
      clearButton.style.display = "none";
      this.filterHistoryItems("");
    });
    return searchInput;
  }
  filterHistoryItems(query) {
    const pinnedSection = this.contentEl.querySelector(".pinned-section");
    const dateHeaders = this.contentEl.querySelectorAll(".history-date-header");
    const dateGroups = this.contentEl.querySelectorAll(".history-date-group");
    const historyItems = this.contentEl.querySelectorAll(".history-item");
    const normalizedQuery = query.trim().toLowerCase();
    if (!normalizedQuery) {
      if (pinnedSection) {
        pinnedSection.style.display = "block";
      }
      dateHeaders.forEach((header) => {
        header.style.display = "block";
      });
      dateGroups.forEach((group) => {
        group.style.display = "flex";
      });
      historyItems.forEach((item) => {
        item.style.display = "flex";
      });
      return;
    }
    const headersWithVisibleItems = /* @__PURE__ */ new Set();
    const groupsWithVisibleItems = /* @__PURE__ */ new Set();
    let hasPinnedVisible = false;
    historyItems.forEach((item) => {
      var _a, _b;
      const titleEl = item.querySelector(".history-title");
      const previewEl = item.querySelector(".history-preview-content");
      const title = titleEl ? ((_a = titleEl.textContent) == null ? void 0 : _a.toLowerCase()) || "" : "";
      const preview = previewEl ? ((_b = previewEl.textContent) == null ? void 0 : _b.toLowerCase()) || "" : "";
      const matches = title.includes(normalizedQuery) || preview.includes(normalizedQuery);
      item.style.display = matches ? "flex" : "none";
      if (matches) {
        if (item.classList.contains("pinned-conversation") || item.closest(".pinned-section")) {
          hasPinnedVisible = true;
        } else {
          const dateGroup = item.closest(".history-date-group");
          if (dateGroup) {
            groupsWithVisibleItems.add(dateGroup);
            const dateHeader = dateGroup.previousElementSibling;
            if (dateHeader && dateHeader.classList.contains("history-date-header")) {
              headersWithVisibleItems.add(dateHeader.textContent || "");
            }
          }
        }
      }
    });
    if (pinnedSection) {
      pinnedSection.style.display = hasPinnedVisible ? "block" : "none";
    }
    dateHeaders.forEach((header) => {
      const headerText = header.textContent || "";
      const shouldShow = headersWithVisibleItems.has(headerText);
      header.style.display = shouldShow ? "block" : "none";
    });
    dateGroups.forEach((group) => {
      const shouldShow = groupsWithVisibleItems.has(group);
      group.style.display = shouldShow ? "flex" : "none";
    });
  }
  // Helper method to find the corresponding date header for an item
  findClosestDateHeader(element) {
    let current = element.previousElementSibling;
    while (current) {
      if (current.classList.contains("history-date-header")) {
        return current;
      }
      current = current.previousElementSibling;
    }
    return null;
  }
  setupModalKeyboardShortcuts(searchInput) {
    setTimeout(() => searchInput.focus(), 50);
    this.contentEl.addEventListener("keydown", (event) => {
      var _a;
      if (event.key === "f" && (event.ctrlKey || event.metaKey) || event.key === "/" && !event.isComposing && !(event.target instanceof HTMLInputElement)) {
        event.preventDefault();
        searchInput.focus();
      }
      if (event.key === "Enter" && event.target instanceof HTMLElement) {
        const historyItem = event.target.closest(".history-item");
        if (historyItem) {
          event.preventDefault();
          const clickEvent = new MouseEvent("click", {
            bubbles: true,
            cancelable: true,
            view: window
          });
          (_a = historyItem.querySelector(".history-item-content")) == null ? void 0 : _a.dispatchEvent(clickEvent);
        }
      }
    });
  }
  addRenameButton(actionsDiv, history, item) {
    const renameBtn = actionsDiv.createEl("button", {
      cls: "history-rename-button",
      attr: {
        "aria-label": "Rename conversation",
        "title": "Rename conversation"
      }
    });
    (0, import_obsidian2.setIcon)(renameBtn, "edit-2");
    const renameTooltip = renameBtn.createSpan({ cls: "history-button-tooltip" });
    renameTooltip.setText("Rename");
    renameBtn.addEventListener("click", (e) => {
      e.stopPropagation();
      const titleEl = item.querySelector(".history-title");
      if (!titleEl) return;
      const currentTitle = titleEl.textContent || "";
      const inputEl = document.createElement("input");
      inputEl.type = "text";
      inputEl.value = currentTitle;
      inputEl.className = "history-rename-input";
      titleEl.empty();
      titleEl.appendChild(inputEl);
      inputEl.focus();
      inputEl.select();
      const handleRename = () => __async(this, null, function* () {
        const newTitle = inputEl.value.trim() || currentTitle;
        titleEl.empty();
        titleEl.setText(newTitle);
        history.title = newTitle;
        if (this.plugin) {
          try {
            const historyDir = this.plugin.settings.chatHistoryPath;
            const filePath = `${historyDir}/chat-${history.id}.json`;
            yield this.app.vault.adapter.write(
              filePath,
              JSON.stringify(history, null, 2)
            );
            new import_obsidian2.Notice("Conversation renamed", 2e3);
          } catch (error) {
            console.error("Failed to rename conversation:", error);
            new import_obsidian2.Notice("Failed to rename conversation", 2e3);
          }
        }
      });
      inputEl.addEventListener("blur", () => {
        handleRename();
      });
      inputEl.addEventListener("keydown", (evt) => {
        if (evt.key === "Enter") {
          evt.preventDefault();
          handleRename();
        } else if (evt.key === "Escape") {
          titleEl.empty();
          titleEl.setText(currentTitle);
        }
      });
    });
    return renameBtn;
  }
  addPinButton(actionsDiv, history, item) {
    const pinBtn = actionsDiv.createEl("button", {
      cls: `history-pin-button ${history.pinned ? "pinned" : ""}`,
      attr: {
        "aria-label": history.pinned ? "Unpin conversation" : "Pin conversation",
        "title": history.pinned ? "Unpin conversation" : "Pin conversation"
      }
    });
    (0, import_obsidian2.setIcon)(pinBtn, history.pinned ? "pin-off" : "pin");
    const pinTooltip = pinBtn.createSpan({ cls: "history-button-tooltip" });
    pinTooltip.setText(history.pinned ? "Unpin" : "Pin");
    pinBtn.addEventListener("click", (e) => __async(this, null, function* () {
      e.stopPropagation();
      history.pinned = !history.pinned;
      pinBtn.className = `history-pin-button ${history.pinned ? "pinned" : ""}`;
      pinBtn.setAttribute("aria-label", history.pinned ? "Unpin conversation" : "Pin conversation");
      pinBtn.setAttribute("title", history.pinned ? "Unpin conversation" : "Pin conversation");
      pinBtn.empty();
      (0, import_obsidian2.setIcon)(pinBtn, history.pinned ? "pin-off" : "pin");
      const newTooltip = pinBtn.createSpan({ cls: "history-button-tooltip" });
      newTooltip.setText(history.pinned ? "Unpin" : "Pin");
      if (history.pinned) {
        item.classList.add("pinned-conversation");
      } else {
        item.classList.remove("pinned-conversation");
      }
      if (this.plugin) {
        try {
          const historyDir = this.plugin.settings.chatHistoryPath;
          const filePath = `${historyDir}/chat-${history.id}.json`;
          yield this.app.vault.adapter.write(
            filePath,
            JSON.stringify(history, null, 2)
          );
          this.reorderHistoryItems();
          new import_obsidian2.Notice(history.pinned ? "Conversation pinned" : "Conversation unpinned", 2e3);
        } catch (error) {
          console.error("Failed to update pin status:", error);
          new import_obsidian2.Notice("Failed to update pin status", 2e3);
        }
      }
    }));
    return pinBtn;
  }
  reorderHistoryItems() {
    const historyList = this.contentEl.querySelector(".history-list");
    if (!historyList) return;
    const pinnedSection = this.contentEl.querySelector(".pinned-section");
    if (!pinnedSection) {
      const hasPinnedItems = this.histories.some((h) => h.pinned);
      if (hasPinnedItems) {
        const pinnedHeader = this.contentEl.createDiv({ cls: "pinned-section" });
        pinnedHeader.createEl("h3", { text: "Pinned Conversations", cls: "pinned-header" });
        historyList.insertBefore(pinnedHeader, historyList.firstChild);
      }
    } else {
      const hasPinnedItems = this.histories.some((h) => h.pinned);
      if (!hasPinnedItems) {
        pinnedSection.remove();
      }
    }
    const searchInput = this.contentEl.querySelector(".history-search-input");
    if (searchInput) {
      const currentQuery = searchInput.value;
      this.filterHistoryItems(currentQuery);
    }
  }
  createHistoryItem(container, history) {
    var _a;
    const item = container.createDiv({
      cls: `history-item ${history.pinned ? "pinned-conversation" : ""}`
    });
    const contentDiv = item.createDiv({ cls: "history-item-content" });
    const titleEl = contentDiv.createDiv({ cls: "history-title" });
    const title = history.title || (((_a = history.messages[0]) == null ? void 0 : _a.content) || "").substring(0, 50) + "...";
    titleEl.setText(title);
    const metaEl = contentDiv.createDiv({ cls: "history-meta" });
    const countEl = metaEl.createSpan({ cls: "history-meta-count" });
    countEl.setText(`${history.messages.length} messages`);
    const dotEl = metaEl.createSpan({ cls: "history-meta-dot" });
    dotEl.setText("\u2022");
    const timeEl = metaEl.createSpan({ cls: "history-meta-time" });
    const date = new Date(history.date);
    timeEl.setText(date.toLocaleTimeString(void 0, { hour: "2-digit", minute: "2-digit" }));
    if (history.messages.length > 0) {
      const lastMessage = history.messages[history.messages.length - 1];
      const previewEl = contentDiv.createDiv({ cls: "history-preview" });
      const roleEl = previewEl.createSpan({ cls: "history-preview-role" });
      roleEl.setText(lastMessage.role === "user" ? "You: " : "AI: ");
      const contentPreview = lastMessage.content.replace(/\n/g, " ").substring(0, 60) + (lastMessage.content.length > 60 ? "..." : "");
      const contentEl = previewEl.createSpan({ cls: "history-preview-content" });
      contentEl.setText(contentPreview);
    }
    contentDiv.addEventListener("click", () => {
      this.onSelect(history);
      this.close();
    });
    const actionsDiv = item.createDiv({ cls: "history-item-actions" });
    this.addPinButton(actionsDiv, history, item);
    this.addRenameButton(actionsDiv, history, item);
    const deleteBtn = actionsDiv.createEl("button", {
      cls: "history-delete-button",
      attr: {
        "aria-label": "Delete conversation",
        "title": "Delete conversation"
      }
    });
    (0, import_obsidian2.setIcon)(deleteBtn, "trash-2");
    const deleteTooltip = deleteBtn.createSpan({ cls: "history-button-tooltip" });
    deleteTooltip.setText("Delete");
    deleteBtn.addEventListener("click", (e) => __async(this, null, function* () {
      e.stopPropagation();
      new ConfirmModal(
        this.app,
        "Are you sure you want to delete this conversation?",
        () => __async(this, null, function* () {
          if (this.plugin) {
            try {
              const historyDir = this.plugin.settings.chatHistoryPath;
              const filePath = `${historyDir}/chat-${history.id}.json`;
              yield this.app.vault.adapter.remove(filePath);
              const index = this.histories.findIndex((h) => h.id === history.id);
              if (index >= 0) {
                this.histories.splice(index, 1);
              }
              item.remove();
              this.reorderHistoryItems();
              new import_obsidian2.Notice("Conversation deleted", 2e3);
            } catch (error) {
              console.error("Failed to delete conversation:", error);
              new import_obsidian2.Notice("Failed to delete conversation", 2e3);
            }
          }
        })
      ).open();
    }));
    return item;
  }
};
var ChatView = class extends import_obsidian2.ItemView {
  constructor(leaf, plugin, modelManager) {
    super(leaf);
    this.messages = [];
    this.currentMode = "chat";
    this.requestId = null;
    this.knowledgeBaseCache = /* @__PURE__ */ new Map();
    this.MAX_RETRIES = 3;
    this.RETRY_DELAY = 1e3;
    this.MAX_TOKENS = 4096;
    this.RENDER_THROTTLE = 30;
    // New history button
    this.lastHistorySave = 0;
    this.isEndingConversation = false;
    this.conversationId = null;
    this.lastNoticedFile = null;
    this.currentModelId = "";
    this.plugin = plugin;
    this.requestId = this.plugin.requestId;
    this.modelManager = modelManager;
    const models = this.modelManager.getActiveModels();
    if (models.length > 0) {
      this.currentModelId = models[0].id;
    }
  }
  load() {
  }
  unload() {
  }
  getViewType() {
    return VIEW_TYPE_CHAT;
  }
  getDisplayText() {
    return "AI Chat";
  }
  getIcon() {
    return "message-square";
  }
  onOpen() {
    return __async(this, null, function* () {
      this.contentEl.addClass("chat-view-container");
      this.tabsContainer = this.contentEl.createDiv({ cls: "chat-tabs" });
      this.createTabs();
      this.viewContainer = this.contentEl.createDiv({ cls: "view-container" });
      this.initializeChatView();
    });
  }
  createTabs() {
    const chatTab = this.tabsContainer.createDiv({
      cls: `chat-tab ${this.currentMode === "chat" ? "active" : ""}`
    });
    const chatIcon = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    chatIcon.setAttribute("viewBox", "0 0 100 100");
    chatIcon.classList.add("chat-icon");
    const chatPath = document.createElementNS("http://www.w3.org/2000/svg", "path");
    chatPath.setAttribute("d", "M20,20v45h10v15l15-15h35V20H20z M25,25h50v35H42.5L35,67.5V60H25V25z");
    chatIcon.appendChild(chatPath);
    chatTab.appendChild(chatIcon);
    const searchTab = this.tabsContainer.createDiv({
      cls: `chat-tab ${this.currentMode === "search" ? "active" : ""}`
    });
    const searchIcon = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    searchIcon.setAttribute("viewBox", "0 0 100 100");
    searchIcon.classList.add("search-icon");
    const searchPath = document.createElementNS("http://www.w3.org/2000/svg", "path");
    searchPath.setAttribute("d", "M80,75 L65,60 C70,54 73,46 73,38 C73,22 60,9 44,9 C28,9 15,22 15,38 C15,54 28,67 44,67 C52,67 60,64 66,59 L81,74 L80,75 Z M44,62 C31,62 20,51 20,38 C20,25 31,14 44,14 C57,14 68,25 68,38 C68,51 57,62 44,62 Z");
    searchIcon.appendChild(searchPath);
    searchTab.appendChild(searchIcon);
    chatTab.onclick = () => this.switchMode("chat");
    searchTab.onclick = () => this.switchMode("search");
  }
  switchMode(mode) {
    return __async(this, null, function* () {
      if (this.currentMode === "chat" && mode === "search" && this.messages.length > 0) {
        this.isEndingConversation = true;
        yield this.saveChatHistory();
      }
      this.currentMode = mode;
      const tabs = this.tabsContainer.querySelectorAll(".chat-tab");
      tabs.forEach((tab) => tab.classList.remove("active"));
      const activeTab = this.tabsContainer.querySelector(`.chat-tab:nth-child(${mode === "chat" ? 1 : 2})`);
      if (activeTab) {
        activeTab.classList.add("active");
      }
      this.viewContainer.empty();
      if (mode === "chat") {
        yield this.initializeChatView();
      } else {
        yield this.initializeSearchView();
      }
    });
  }
  initializeChatView() {
    return __async(this, null, function* () {
      this.chatContainer = this.viewContainer.createDiv({ cls: "chat-container" });
      this.chatHistoryButton = this.chatContainer.createDiv({ cls: "chat-history-button" });
      (0, import_obsidian2.setIcon)(this.chatHistoryButton, "history");
      this.chatHistoryButton.setAttribute("aria-label", "View chat history");
      this.chatHistoryButton.addEventListener("click", () => this.showChatHistory());
      const newChatButton = this.chatContainer.createDiv({ cls: "new-chat-button" });
      (0, import_obsidian2.setIcon)(newChatButton, "plus-circle");
      newChatButton.setAttribute("aria-label", "Start new chat");
      newChatButton.addEventListener("click", () => this.startNewChat());
      this.messagesContainer = this.chatContainer.createDiv({ cls: "messages-container" });
      this.inputContainer = this.chatContainer.createDiv({ cls: "input-container" });
      const inputWrapper = this.inputContainer.createDiv({ cls: "input-wrapper" });
      this.currentInput = inputWrapper.createEl("textarea", {
        cls: "chat-input",
        attr: { placeholder: "Type your message... (Press Enter to send) \u23CE" }
      });
      const functionIconsContainer = this.inputContainer.createDiv({ cls: "function-icons-container" });
      if (!this.plugin.settings.functions) {
        console.log("Initializing functions array from defaults");
        this.plugin.settings.functions = DEFAULT_SETTINGS.functions ? [...DEFAULT_SETTINGS.functions] : [];
        if (this.plugin.settings.customFunctions && this.plugin.settings.customFunctions.length > 0) {
          this.plugin.settings.functions.push(...this.plugin.settings.customFunctions);
        }
        this.plugin.saveSettings();
      } else if (this.plugin.settings.functions.length === 0) {
        this.plugin.settings.functions = DEFAULT_SETTINGS.functions ? [...DEFAULT_SETTINGS.functions] : [];
        this.plugin.saveSettings();
      }
      console.log("Available functions:", this.plugin.settings.functions.map((f) => f.name).join(", "));
      if (!this.plugin.settings.functions.some((f) => f.name === "Polish")) {
        console.log("Polish function missing, adding it");
        this.plugin.settings.functions.push({
          name: "Polish",
          prompt: "Please polish and refine the following text to improve clarity, flow, and style while preserving the original meaning and language. Enhance the expression, eliminate redundancies, and make it more engaging. Return the polished version only, without explanations:",
          icon: "bird",
          tooltip: "Polish and refine text",
          isBuiltIn: true
        });
        this.plugin.saveSettings();
      }
      this.plugin.settings.functions.forEach((func) => {
        console.log(`Creating button for function: ${func.name}, icon: ${func.icon}`);
        const iconButton = functionIconsContainer.createEl("button", {
          cls: `function-icon-button ${func.isBuiltIn ? "built-in" : "custom-function"}`,
          attr: { "aria-label": `${func.name} ${func.tooltip ? `(${func.tooltip})` : ""}` }
        });
        try {
          (0, import_obsidian2.setIcon)(iconButton, func.icon);
        } catch (e) {
          (0, import_obsidian2.setIcon)(iconButton, "bot");
          console.warn(`Invalid icon '${func.icon}' for function '${func.name}'`);
        }
        const tooltipEl = iconButton.createSpan({ cls: "function-icon-tooltip" });
        tooltipEl.setText(func.tooltip || func.name);
        if (func.isBuiltIn) {
          switch (func.name) {
            case "Organize":
              iconButton.onclick = () => this.handleOrganize();
              break;
            case "Grammar":
              iconButton.onclick = () => this.handleGrammar();
              break;
            case "Generate":
              iconButton.onclick = () => this.handleGenerate();
              break;
            case "Dialogue":
              iconButton.onclick = () => this.handleDialogue();
              break;
            case "Summarize":
              iconButton.onclick = () => this.handleSummarize();
              break;
            case "Polish":
              iconButton.onclick = () => this.handlePolish();
              break;
            default:
              iconButton.onclick = () => this.handleCustomFunction(func);
          }
        } else {
          iconButton.onclick = () => this.handleCustomFunction(func);
        }
      });
      this.setupKeyboardShortcuts();
      if (this.messages.length > 0) {
        this.renderChatHistory();
      }
    });
  }
  initializeSearchView() {
    return __async(this, null, function* () {
      const searchContainer = this.viewContainer.createDiv({ cls: "search-container" });
      const inputContainer = searchContainer.createDiv({ cls: "search-input-container" });
      const dirSelector = inputContainer.createEl("select", {
        cls: "search-dir-selector",
        attr: {
          "aria-label": "Select directory to search in"
        }
      });
      dirSelector.createEl("option", {
        text: "All Files",
        value: ""
      });
      const rootFolder = this.app.vault.getRoot();
      const folders = rootFolder.children.filter((child) => child instanceof import_obsidian2.TFolder).sort((a, b) => a.name.localeCompare(b.name));
      folders.forEach((folder) => {
        dirSelector.createEl("option", {
          text: folder.name,
          value: folder.path
        });
      });
      const searchInputRow = inputContainer.createDiv({ cls: "search-input-row" });
      const searchInput = searchInputRow.createEl("input", {
        cls: "search-input",
        attr: {
          placeholder: "Enter your search query...",
          "aria-label": "Search query",
          type: "search"
        }
      });
      const searchButton = searchInputRow.createEl("button", {
        cls: "search-button",
        text: "Search"
      });
      const resultsContainer = searchContainer.createDiv({ cls: "search-results" });
      const progressContainer = searchContainer.createDiv({ cls: "search-progress" });
      const progressBar = progressContainer.createDiv({ cls: "search-progress-bar" });
      const progressText = progressContainer.createDiv({ cls: "search-progress-text" });
      const countText = progressContainer.createDiv({ cls: "count-text" });
      progressContainer.style.display = "none";
      const handleSearch = () => __async(this, null, function* () {
        const query = searchInput.value.trim();
        if (!query) {
          resultsContainer.empty();
          resultsContainer.createDiv({
            cls: "error-message",
            text: "Please enter a search query."
          });
          return;
        }
        progressContainer.style.display = "block";
        progressText.textContent = "Initializing search...";
        progressBar.style.width = "0%";
        countText.textContent = "";
        resultsContainer.empty();
        try {
          const selectedDir = dirSelector.value;
          const files = yield this.plugin.getKnowledgeBaseNotes(selectedDir);
          const now = Date.now();
          const CACHE_DURATION = 30 * 60 * 1e3;
          if (files.length === 0) {
            progressContainer.style.display = "none";
            resultsContainer.createDiv({
              cls: "error-message",
              text: selectedDir ? `No files found in directory: ${selectedDir}` : "No files found in knowledge base."
            });
            return;
          }
          let processed = 0;
          const results = [];
          const totalFiles = files.length;
          countText.textContent = `Found ${totalFiles} files to process`;
          for (const file of files) {
            const content = yield this.app.vault.read(file);
            const currentHash = yield this.calculateFileHash(content);
            const cached = this.knowledgeBaseCache.get(file.path);
            if (cached && now - cached.timestamp < CACHE_DURATION && cached.hash === currentHash) {
              results.push({
                file,
                similarity: cached.similarity,
                content: cached.content
              });
              processed++;
              continue;
            }
            const similarity = yield this.plugin.calculateSimilarity(query, content);
            results.push({ file, similarity, content });
            this.knowledgeBaseCache.set(file.path, {
              similarity,
              content,
              timestamp: now,
              hash: currentHash
            });
            processed++;
            const progress = processed / files.length * 100;
            progressBar.style.width = `${progress}%`;
            progressText.textContent = `Processing ${processed}/${files.length} files...`;
            countText.textContent = `Found ${files.length} files, processed ${processed}`;
          }
          progressText.textContent = "Generating summary...";
          progressBar.style.width = "100%";
          countText.textContent = `Processing summary for top ${Math.min(5, results.length)} results...`;
          const topResults = results.sort((a, b) => b.similarity - a.similarity).slice(0, 5);
          yield this.displaySearchResults(resultsContainer, topResults);
          progressContainer.style.display = "none";
        } catch (error) {
          progressContainer.style.display = "none";
          resultsContainer.createDiv({
            cls: "error-message",
            text: `Error: ${error.message}`
          });
        }
      });
      searchInput.addEventListener("keydown", (e) => __async(this, null, function* () {
        if (e.key === "Enter") {
          yield handleSearch();
        }
      }));
      searchButton.addEventListener("click", handleSearch);
      searchInput.focus();
    });
  }
  addMessage(role, content) {
    return __async(this, null, function* () {
      this.messages.push({ role, content });
      const messageDiv = this.messagesContainer.createDiv({
        cls: role === "user" ? "user-message" : "ai-message"
      });
      const contentDiv = messageDiv.createDiv({ cls: "message-content" });
      const metadata = contentDiv.createDiv({ cls: "message-metadata" });
      metadata.setText((/* @__PURE__ */ new Date()).toLocaleTimeString());
      const textDiv = contentDiv.createDiv({ cls: "message-text" });
      yield MarkdownRenderer.renderMarkdown(
        content,
        textDiv,
        "",
        this.plugin
      );
      if (role === "assistant") {
        const actionContainer = contentDiv.createDiv({ cls: "message-actions hover-only" });
        const copyButton = actionContainer.createEl("button", {
          cls: "message-action-button copy-button",
          attr: { "aria-label": "Copy message" }
        });
        (0, import_obsidian2.setIcon)(copyButton, "copy");
        copyButton.onclick = () => __async(this, null, function* () {
          try {
            yield navigator.clipboard.writeText(content);
            new import_obsidian2.Notice("Copied to clipboard", 2e3);
          } catch (err) {
            console.error("Failed to copy content:", err);
            new import_obsidian2.Notice("Failed to copy content");
          }
        });
        const insertButton = actionContainer.createEl("button", {
          cls: "message-action-button insert-button",
          attr: { "aria-label": "Insert into editor" }
        });
        (0, import_obsidian2.setIcon)(insertButton, "plus");
        insertButton.onclick = () => {
          const activeLeaf = this.app.workspace.activeLeaf;
          if (!activeLeaf) {
            new import_obsidian2.Notice("Please open a markdown file first");
            return;
          }
          const view = activeLeaf.view;
          if (!(view instanceof import_obsidian2.MarkdownView)) {
            new import_obsidian2.Notice("Please open a markdown file first");
            return;
          }
          const editor = view.editor;
          const cursor = editor.getCursor();
          editor.replaceRange(content + "\n", cursor);
          editor.focus();
          new import_obsidian2.Notice("Content inserted into editor", 2e3);
        };
        const applyButton = actionContainer.createEl("button", {
          cls: "message-action-button apply-button",
          attr: { "aria-label": "Apply changes to original text" }
        });
        (0, import_obsidian2.setIcon)(applyButton, "check");
        applyButton.onclick = () => {
          const editor = this.getEditor();
          if (!editor) {
            new import_obsidian2.Notice("Please open a markdown file first");
            return;
          }
          let originalText = "";
          let isSelection = false;
          if (editor.somethingSelected()) {
            originalText = editor.getSelection();
            isSelection = true;
          } else {
            originalText = editor.getValue();
          }
          new PolishResultModal(
            this.plugin.app,
            originalText,
            content,
            (updatedContent) => {
              if (editor) {
                if (isSelection) {
                  editor.replaceSelection(updatedContent);
                } else {
                  editor.setValue(updatedContent);
                }
                new import_obsidian2.Notice("AI polish applied successfully");
              }
            },
            this.plugin
            // Pass the plugin instance
          ).open();
        };
      }
      this.messagesContainer.scrollTo({
        top: this.messagesContainer.scrollHeight,
        behavior: "smooth"
      });
    });
  }
  // Improved method to get the editor, trying to find an open markdown file
  // even if the chat view is currently active
  getEditor() {
    const activeLeaf = this.app.workspace.activeLeaf;
    if (activeLeaf && activeLeaf.view instanceof import_obsidian2.MarkdownView) {
      const fileName = activeLeaf.getDisplayText();
      this.lastNoticedFile = fileName;
      return activeLeaf.view.editor;
    }
    const mdLeaves = this.app.workspace.getLeavesOfType("markdown");
    if (mdLeaves.length > 0) {
      const mdView = mdLeaves[0].view;
      const fileName = mdLeaves[0].getDisplayText();
      if (mdView && mdView.editor) {
        if (this.lastNoticedFile !== fileName) {
          new import_obsidian2.Notice(`Using the file "${fileName}" for content`, 2e3);
          this.lastNoticedFile = fileName;
        }
        return mdView.editor;
      }
    }
    const leaves = this.app.workspace.getLeavesOfType("");
    for (const leaf of leaves) {
      if (leaf.view && "getViewType" in leaf.view && leaf.view.getViewType() === "markdown" && "editor" in leaf.view) {
        const fileName = leaf.getDisplayText();
        new import_obsidian2.Notice(`Using the file "${fileName}" for content`, 2e3);
        this.lastNoticedFile = fileName;
        return leaf.view.editor;
      }
    }
    return null;
  }
  // Method to get the selected text from the editor
  getSelectedText() {
    return __async(this, null, function* () {
      const editor = this.getEditor();
      if (!editor) return "";
      return editor.somethingSelected() ? editor.getSelection() : "";
    });
  }
  // Method to get the content of the current file
  getCurrentFileContent() {
    return __async(this, null, function* () {
      const editor = this.getEditor();
      if (!editor) return "";
      return editor.getValue();
    });
  }
  // Helper method to send a message to the chat with a function prompt
  sendFunctionPromptToChat(prompt, content = "") {
    return __async(this, null, function* () {
      if (content) {
        this.sendMessage(prompt, content);
        new import_obsidian2.Notice(`Applied function to ${(yield this.getSelectedText()) ? "selected text" : "current document"}`, 2e3);
      } else {
        const editor = this.getEditor();
        let documentContent = "";
        let isSelection = false;
        if (editor) {
          if (editor.somethingSelected()) {
            documentContent = editor.getSelection();
            isSelection = true;
          } else {
            documentContent = editor.getValue();
          }
        }
        if (documentContent) {
          this.sendMessage(prompt, documentContent);
          const source = isSelection ? "selected text" : "current document";
          new import_obsidian2.Notice(`Applied function to ${source}`, 2e3);
        } else {
          this.currentInput.value = prompt + "\n\n(Paste your text here or open a file first)";
          this.currentInput.focus();
          const placeholderPos = this.currentInput.value.indexOf("(Paste your text here");
          if (placeholderPos > -1) {
            this.currentInput.setSelectionRange(placeholderPos, placeholderPos + "(Paste your text here or open a file first)".length);
          }
        }
      }
    });
  }
  // Updated handler methods to use a consistent approach
  handleSummarize() {
    return __async(this, null, function* () {
      const content = yield this.getCurrentFileContent();
      const selectedText = yield this.getSelectedText();
      const summarizeFunc = this.plugin.settings.functions.find((f) => f.name === "Summarize");
      const prompt = summarizeFunc ? summarizeFunc.prompt : "";
      if (!content) {
        this.sendFunctionPromptToChat(prompt);
        return;
      }
      this.sendFunctionPromptToChat(prompt, selectedText || content);
    });
  }
  // Updated method to check if we can use an editor
  shouldUseEditorMode() {
    const editor = this.getEditor();
    if (!editor) {
      new import_obsidian2.Notice("No active editor found. Please open a file first.", 2e3);
      return false;
    }
    return true;
  }
  // Add this method to handle the Polish function
  handlePolish() {
    return __async(this, null, function* () {
      const content = yield this.getCurrentFileContent();
      const selectedText = yield this.getSelectedText();
      const polishFunc = this.plugin.settings.functions.find((f) => f.name === "Polish");
      const prompt = polishFunc ? polishFunc.prompt : "";
      if (!content) {
        console.log("Polish function: No active file content found");
        this.sendFunctionPromptToChat(prompt);
        return;
      }
      console.log("Polish function: Using " + (selectedText ? "selected text" : "entire document"));
      this.sendFunctionPromptToChat(prompt, selectedText || content);
    });
  }
  handleOrganize() {
    return __async(this, null, function* () {
      const content = yield this.getCurrentFileContent();
      const selectedText = yield this.getSelectedText();
      const organizeFunc = this.plugin.settings.functions.find((f) => f.name === "Organize");
      const prompt = organizeFunc ? organizeFunc.prompt : "";
      if (!content) {
        this.sendFunctionPromptToChat(prompt);
        return;
      }
      this.sendFunctionPromptToChat(prompt, selectedText || content);
    });
  }
  handleGrammar() {
    return __async(this, null, function* () {
      const content = yield this.getCurrentFileContent();
      const selectedText = yield this.getSelectedText();
      const grammarFunc = this.plugin.settings.functions.find((f) => f.name === "Grammar");
      const prompt = grammarFunc ? grammarFunc.prompt : "";
      if (!content) {
        this.sendFunctionPromptToChat(prompt);
        return;
      }
      this.sendFunctionPromptToChat(prompt, selectedText || content);
    });
  }
  // Handler for custom functions
  handleCustomFunction(func) {
    return __async(this, null, function* () {
      const content = yield this.getCurrentFileContent();
      const selectedText = yield this.getSelectedText();
      if (!content) {
        this.sendFunctionPromptToChat(func.prompt);
        return;
      }
      this.sendFunctionPromptToChat(func.prompt, selectedText || content);
    });
  }
  // Handler for built-in generate content function
  handleGenerate() {
    return __async(this, null, function* () {
      const content = yield this.getCurrentFileContent();
      const selectedText = yield this.getSelectedText();
      const generateFunc = this.plugin.settings.functions.find((f) => f.isBuiltIn && f.name === "Generate");
      const prompt = generateFunc ? generateFunc.prompt : "";
      if (!content) {
        this.sendFunctionPromptToChat(prompt);
        return;
      }
      this.sendFunctionPromptToChat(prompt, selectedText || content);
    });
  }
  // Handler for built-in dialogue function
  handleDialogue() {
    return __async(this, null, function* () {
      const content = yield this.getCurrentFileContent();
      const selectedText = yield this.getSelectedText();
      const dialogueFunc = this.plugin.settings.functions.find((f) => f.isBuiltIn && f.name === "Dialogue");
      const prompt = dialogueFunc ? dialogueFunc.prompt : "";
      if (!content) {
        this.sendFunctionPromptToChat(prompt);
        return;
      }
      this.sendFunctionPromptToChat(prompt, selectedText || content);
    });
  }
  handleSend() {
    return __async(this, null, function* () {
      const content = this.currentInput.value.trim();
      if (!content) return;
      this.currentInput.value = "";
      yield this.addMessage("user", content);
      const messageDiv = this.messagesContainer.createDiv({
        cls: "ai-message"
      });
      const contentDiv = messageDiv.createDiv({ cls: "message-content" });
      const metadata = contentDiv.createDiv({ cls: "message-metadata" });
      metadata.setText((/* @__PURE__ */ new Date()).toLocaleTimeString());
      const textDiv = contentDiv.createDiv({ cls: "message-text" });
      try {
        if (!this.requestId) {
          this.requestId = crypto.randomUUID();
          this.plugin.requestId = this.requestId;
        }
        let streamedContent = "";
        let lastRenderTime = Date.now();
        let retries = 0;
        while (retries < this.MAX_RETRIES) {
          try {
            const response = yield this.plugin.callAIChat([
              ...this.messages,
              { role: "user", content }
            ], (chunk) => __async(this, null, function* () {
              if (!chunk) return;
              streamedContent += chunk;
              const now = Date.now();
              if (now - lastRenderTime >= this.RENDER_THROTTLE) {
                let renderRetries = 0;
                const MAX_RENDER_RETRIES = 3;
                while (renderRetries < MAX_RENDER_RETRIES) {
                  try {
                    textDiv.empty();
                    yield MarkdownRenderer.renderMarkdown(
                      streamedContent,
                      textDiv,
                      "",
                      this.plugin
                    );
                    this.scrollToBottom();
                    break;
                  } catch (e) {
                    console.warn(`Error rendering markdown (attempt ${renderRetries + 1}/${MAX_RENDER_RETRIES}):`, e);
                    if (renderRetries === MAX_RENDER_RETRIES - 1) {
                      textDiv.setText(streamedContent);
                    }
                    renderRetries++;
                    yield new Promise((resolve) => setTimeout(resolve, 100));
                  }
                }
                lastRenderTime = now;
              }
            }));
            this.messages.push({ role: "assistant", content: response });
            const actionContainer = contentDiv.createDiv({ cls: "message-actions hover-only" });
            const copyButton = actionContainer.createEl("button", {
              cls: "message-action-button copy-button",
              attr: { "aria-label": "Copy message" }
            });
            (0, import_obsidian2.setIcon)(copyButton, "copy");
            copyButton.onclick = () => __async(this, null, function* () {
              try {
                yield navigator.clipboard.writeText(response);
                new import_obsidian2.Notice("Copied to clipboard", 2e3);
              } catch (err) {
                console.error("Failed to copy content:", err);
                new import_obsidian2.Notice("Failed to copy content");
              }
            });
            const insertButton = actionContainer.createEl("button", {
              cls: "message-action-button insert-button",
              attr: { "aria-label": "Insert into editor" }
            });
            (0, import_obsidian2.setIcon)(insertButton, "plus");
            insertButton.onclick = () => {
              const activeLeaf = this.app.workspace.activeLeaf;
              if (!activeLeaf) {
                new import_obsidian2.Notice("Please open a markdown file first");
                return;
              }
              const view = activeLeaf.view;
              if (!(view instanceof import_obsidian2.MarkdownView)) {
                new import_obsidian2.Notice("Please open a markdown file first");
                return;
              }
              const editor = view.editor;
              const cursor = editor.getCursor();
              editor.replaceRange(response + "\n", cursor);
              editor.focus();
              new import_obsidian2.Notice("Content inserted into editor", 2e3);
            };
            const applyButton = actionContainer.createEl("button", {
              cls: "message-action-button apply-button",
              attr: { "aria-label": "Apply changes to original text" }
            });
            (0, import_obsidian2.setIcon)(applyButton, "check");
            applyButton.onclick = () => {
              const editor = this.getEditor();
              if (!editor) {
                new import_obsidian2.Notice("Please open a markdown file first");
                return;
              }
              let originalText = "";
              let isSelection = false;
              if (editor.somethingSelected()) {
                originalText = editor.getSelection();
                isSelection = true;
              } else {
                originalText = editor.getValue();
              }
              new PolishResultModal(
                this.plugin.app,
                originalText,
                response,
                (updatedContent) => {
                  if (editor) {
                    if (isSelection) {
                      editor.replaceSelection(updatedContent);
                    } else {
                      editor.setValue(updatedContent);
                    }
                    new import_obsidian2.Notice("AI polish applied successfully");
                  }
                },
                this.plugin
                // Pass the plugin instance
              ).open();
            };
            break;
          } catch (error) {
            console.error(`AI request failed (retry ${retries + 1}/${this.MAX_RETRIES}):`, error);
            if (retries === this.MAX_RETRIES - 1) {
              throw new Error("Failed to get AI response after multiple retries");
            }
            retries++;
            yield new Promise((resolve) => setTimeout(resolve, this.RETRY_DELAY * Math.pow(2, retries)));
          }
        }
      } catch (error) {
        console.error("Error in chat:", error);
        let errorMessage = "Sorry, an error occurred. Please try again.";
        if (error && error.message) {
          if (error.message.includes("images") || error.message.includes("unsupported content")) {
            errorMessage = "Error: Your message contains images or unsupported content that the AI cannot process. Please remove any images and try again.";
          } else if (error.message.includes("rate limit") || error.message.includes("429")) {
            errorMessage = "Error: Rate limit exceeded. Please wait a moment before trying again.";
          } else if (error.message.includes("Invalid API key") || error.message.includes("401")) {
            errorMessage = "Error: Invalid API key. Please check your API key in settings.";
          } else if (error.message.includes("Failed to get AI response after multiple retries")) {
            errorMessage = "Error: Failed to get a response after multiple attempts. Please check your internet connection and try again.";
          }
        }
        textDiv.empty();
        const errorContainer = textDiv.createDiv({ cls: "error-container" });
        const warningIcon = errorContainer.createDiv({ cls: "error-icon" });
        (0, import_obsidian2.setIcon)(warningIcon, "alert-triangle");
        const errorText = errorContainer.createDiv({ cls: "error-text" });
        errorText.setText(errorMessage);
        const retryButton = errorContainer.createEl("button", {
          cls: "compact-retry-button",
          text: "Retry Last Message"
        });
        retryButton.addEventListener("click", () => {
          messageDiv.remove();
          this.currentInput.value = content;
          this.currentInput.focus();
        });
      }
      if (this.shouldSaveHistory()) {
        yield this.saveChatHistory();
      }
    });
  }
  displaySearchResults(resultsContainer, topResults) {
    return __async(this, null, function* () {
      const contextsWithRefs = topResults.map((result, index) => {
        const cleanContent = result.content.replace(/\n+/g, " ").slice(0, 1e3);
        return `Document [${index + 1}] (${result.file.basename}):
${cleanContent}...`;
      }).join("\n\n");
      const summaryPrompt = `${this.plugin.settings.promptSummary}

${contextsWithRefs}`;
      const summary = yield this.plugin.getAIResponse(summaryPrompt);
      const summaryDiv = resultsContainer.createDiv({ cls: "search-summary" });
      yield MarkdownRenderer.renderMarkdown(summary, summaryDiv, "", this.plugin);
      const refsDiv = resultsContainer.createDiv({ cls: "search-references" });
      refsDiv.createEl("h3", { text: "References" });
      topResults.forEach((result, index) => {
        const refDiv = refsDiv.createDiv({ cls: "search-reference-item" });
        const link2 = refDiv.createEl("a", {
          text: `[${index + 1}] ${result.file.basename}`,
          cls: "search-reference-link"
        });
        link2.addEventListener("click", () => {
          this.app.workspace.getLeaf().openFile(result.file);
        });
      });
    });
  }
  calculateFileHash(content) {
    return __async(this, null, function* () {
      const encoder = new TextEncoder();
      const data = encoder.encode(content);
      const hashBuffer = yield crypto.subtle.digest("SHA-256", data);
      return Array.from(new Uint8Array(hashBuffer)).map((b) => b.toString(16).padStart(2, "0")).join("");
    });
  }
  estimateTokenCount(text) {
    return Math.ceil(text.length / 4);
  }
  scrollToBottom(smooth = true) {
    if (this.messagesContainer) {
      void this.messagesContainer.offsetHeight;
      const isAtBottom = this.messagesContainer.scrollHeight - this.messagesContainer.scrollTop - this.messagesContainer.clientHeight < 100;
      const behavior = smooth && !isAtBottom ? "smooth" : "auto";
      this.messagesContainer.scrollTo({
        top: this.messagesContainer.scrollHeight,
        behavior
      });
    }
  }
  onClose() {
    return __async(this, null, function* () {
    });
  }
  setupKeyboardShortcuts() {
    this.currentInput.addEventListener("keydown", (event) => __async(this, null, function* () {
      if (event.key === "Enter" && !event.shiftKey && !event.altKey && !event.ctrlKey && !event.metaKey) {
        event.preventDefault();
        yield this.handleSend();
      }
      if (event.key === "Enter" && event.shiftKey) {
        return;
      }
      if (event.key === "Enter" && event.altKey) {
        event.preventDefault();
        const start = this.currentInput.selectionStart;
        const end = this.currentInput.selectionEnd;
        this.currentInput.value = this.currentInput.value.substring(0, start) + "\n" + this.currentInput.value.substring(end);
        this.currentInput.selectionStart = this.currentInput.selectionEnd = start + 1;
      }
      if (event.key === "Escape") {
        event.preventDefault();
        this.currentInput.value = "";
        this.currentInput.focus();
      }
      if (event.key.toLowerCase() === "l" && (event.ctrlKey || event.metaKey)) {
        event.preventDefault();
        this.clearChat();
      }
    }));
  }
  clearChat() {
    if (this.messagesContainer) {
      this.messagesContainer.empty();
      this.messages = [];
      new import_obsidian2.Notice("Chat cleared");
    }
  }
  sendMessage(prompt, content) {
    this.currentInput.value = `${prompt}

${content}`;
    this.handleSend();
  }
  // Add this method to save the current chat history
  saveChatHistory() {
    return __async(this, null, function* () {
      if (this.messages.length === 0) return;
      try {
        if (!this.conversationId) {
          this.conversationId = crypto.randomUUID();
        }
        const history = {
          id: this.conversationId,
          title: this.getHistoryTitle(),
          date: Date.now(),
          messages: [...this.messages],
          requestId: this.requestId
        };
        const historyDir = this.plugin.settings.chatHistoryPath;
        const folderExists = yield this.ensureFolderExists(historyDir);
        if (!folderExists) {
          throw new Error(`Failed to create chat history directory: ${historyDir}`);
        }
        const fileName = `chat-${this.conversationId}.json`;
        const filePath = `${historyDir}/${fileName}`;
        yield this.plugin.app.vault.adapter.write(filePath, JSON.stringify(history, null, 2));
        this.lastHistorySave = Date.now();
        console.log(`Chat history saved: ${filePath} with ${this.messages.length} messages`);
        return true;
      } catch (error) {
        return this.handleHistoryError("save chat history", error);
      }
    });
  }
  // Helper to ensure a folder exists
  ensureFolderExists(path) {
    return __async(this, null, function* () {
      const { vault } = this.plugin.app;
      const folderExists = yield vault.adapter.exists(path);
      if (!folderExists) {
        try {
          yield vault.createFolder(path);
          return true;
        } catch (error) {
          console.error(`Failed to create folder ${path}:`, error);
          return false;
        }
      }
      return true;
    });
  }
  // Get a title for the chat history based on first user message
  getHistoryTitle() {
    const firstUserMsg = this.messages.find((m) => m.role === "user");
    if (!firstUserMsg) return "Chat Session";
    const title = firstUserMsg.content.substring(0, 30).trim();
    return title + (firstUserMsg.content.length > 30 ? "..." : "");
  }
  // Show the chat history modal
  showChatHistory() {
    return __async(this, null, function* () {
      this.isEndingConversation = true;
      try {
        const histories = yield this.loadChatHistories();
        new ChatHistoryModal(this.plugin.app, histories, (history) => {
          this.loadChatFromHistory(history);
        }, this.plugin).open();
      } catch (error) {
        console.error("Failed to load chat histories:", error);
        new import_obsidian2.Notice("Failed to load chat histories", 2e3);
      }
    });
  }
  // Load all chat histories
  loadChatHistories() {
    return __async(this, null, function* () {
      try {
        const historyDir = this.plugin.settings.chatHistoryPath;
        const folderExists = yield this.ensureFolderExists(historyDir);
        if (!folderExists) {
          throw new Error(`Chat history directory does not exist: ${historyDir}`);
        }
        const files = yield this.plugin.app.vault.adapter.list(historyDir);
        const histories = [];
        for (const file of files.files) {
          if (file.endsWith(".json")) {
            try {
              const content = yield this.plugin.app.vault.adapter.read(file);
              const historyData = JSON.parse(content);
              if (!historyData.requestId) {
                historyData.requestId = null;
              }
              const history = historyData;
              histories.push(history);
            } catch (error) {
              console.error(`Failed to read chat history ${file}:`, error);
            }
          }
        }
        return histories.sort((a, b) => b.date - a.date);
      } catch (error) {
        return this.handleHistoryError("load chat histories", error);
      }
    });
  }
  // Load a specific chat history
  loadChatFromHistory(history) {
    if (this.messages.length > 0) {
      this.saveChatHistory();
    }
    this.clearChat();
    this.conversationId = history.id;
    this.messages = [...history.messages];
    if (history.requestId) {
      this.requestId = history.requestId;
      this.plugin.requestId = history.requestId;
    }
    this.renderChatHistory();
    new import_obsidian2.Notice(`Loaded chat: ${history.title}`, 2e3);
  }
  // Fix the renderChatHistory method in ChatView
  renderChatHistory() {
    if (!this.messagesContainer) return;
    this.messagesContainer.empty();
    for (const message of this.messages) {
      const messageEl = this.messagesContainer.createDiv({
        cls: `message ${message.role}-message`
      });
      const contentDiv = messageEl.createDiv({ cls: "message-content" });
      if (message.role === "assistant") {
        MarkdownRenderer.renderMarkdown(message.content, contentDiv, "", this.plugin);
        const actionContainer = messageEl.createDiv({ cls: "message-actions hover-only" });
        const copyButton = actionContainer.createEl("button", {
          cls: "message-action-button copy-button",
          attr: { "aria-label": "Copy message" }
        });
        (0, import_obsidian2.setIcon)(copyButton, "copy");
        copyButton.onclick = () => __async(this, null, function* () {
          try {
            yield navigator.clipboard.writeText(message.content);
            new import_obsidian2.Notice("Copied to clipboard", 2e3);
          } catch (err) {
            console.error("Failed to copy content:", err);
            new import_obsidian2.Notice("Failed to copy content", 2e3);
          }
        });
        const insertButton = actionContainer.createEl("button", {
          cls: "message-action-button insert-button",
          attr: { "aria-label": "Insert into editor" }
        });
        (0, import_obsidian2.setIcon)(insertButton, "plus");
        insertButton.onclick = () => {
          const activeLeaf = this.app.workspace.activeLeaf;
          if (!activeLeaf) {
            new import_obsidian2.Notice("Please open a markdown file first");
            return;
          }
          const view = activeLeaf.view;
          if (!(view instanceof import_obsidian2.MarkdownView)) {
            new import_obsidian2.Notice("Please open a markdown file first");
            return;
          }
          const editor = view.editor;
          const cursor = editor.getCursor();
          editor.replaceRange(message.content + "\n", cursor);
          editor.focus();
          new import_obsidian2.Notice("Content inserted into editor", 2e3);
        };
        const applyButton = actionContainer.createEl("button", {
          cls: "message-action-button apply-button",
          attr: { "aria-label": "Apply changes to original text" }
        });
        (0, import_obsidian2.setIcon)(applyButton, "check");
        applyButton.onclick = () => {
          const editor = this.getEditor();
          if (!editor) {
            new import_obsidian2.Notice("Please open a markdown file first");
            return;
          }
          let originalText = "";
          let isSelection = false;
          if (editor.somethingSelected()) {
            originalText = editor.getSelection();
            isSelection = true;
          } else {
            originalText = editor.getValue();
          }
          new PolishResultModal(
            this.plugin.app,
            originalText,
            message.content,
            (updatedContent) => {
              if (editor) {
                if (isSelection) {
                  editor.replaceSelection(updatedContent);
                } else {
                  editor.setValue(updatedContent);
                }
                new import_obsidian2.Notice("AI polish applied successfully");
              }
            },
            this.plugin
            // Pass the plugin instance
          ).open();
        };
      } else {
        contentDiv.setText(message.content);
      }
    }
    if (this.messagesContainer.scrollHeight) {
      this.messagesContainer.scrollTo({
        top: this.messagesContainer.scrollHeight,
        behavior: "smooth"
      });
    }
  }
  startNewChat() {
    return __async(this, null, function* () {
      this.isEndingConversation = true;
      if (this.messages.length > 0) {
        yield this.saveChatHistory();
      }
      this.clearChat();
      this.conversationId = null;
      this.requestId = crypto.randomUUID();
      this.plugin.requestId = this.requestId;
      new import_obsidian2.Notice("Started new chat", 2e3);
    });
  }
  // Update shouldSaveHistory to include a check for ending a conversation
  shouldSaveHistory() {
    if (this.isEndingConversation) {
      this.isEndingConversation = false;
      return true;
    }
    if (this.messages.length % 5 === 0 && this.messages.length > 0) {
      return true;
    }
    const lastSaveTime = this.lastHistorySave || 0;
    const TEN_MINUTES = 10 * 60 * 1e3;
    if (this.messages.length > 0 && Date.now() - lastSaveTime > TEN_MINUTES) {
      return true;
    }
    return false;
  }
  // Add this method to improve error handling for chat history operations
  handleHistoryError(operation, error) {
    console.error(`Error during ${operation}:`, error);
    let errorMessage = `Failed to ${operation}`;
    if (error instanceof Error) {
      if (error.message.includes("ENOENT") || error.message.includes("not found")) {
        errorMessage = `Chat history directory not found. Please check your settings.`;
      } else if (error.message.includes("permission")) {
        errorMessage = `Permission denied. Cannot access chat history files.`;
      } else if (error.message.includes("JSON")) {
        errorMessage = `Invalid chat history file format.`;
      }
    }
    new import_obsidian2.Notice(errorMessage, 3e3);
    switch (operation) {
      case "load chat histories":
        return [];
      case "save chat history":
      case "delete chat history":
      default:
        return false;
    }
  }
  createInputContainer() {
    this.createModelSelector();
  }
  createModelSelector() {
    const modelSelectorContainer = this.inputContainer.createDiv({ cls: "model-selector-container" });
    modelSelectorContainer.createEl("label", {
      text: "AI Model:",
      attr: { for: "model-selector" }
    });
    this.modelSelectEl = modelSelectorContainer.createEl("select", {
      cls: "model-selector",
      attr: { id: "model-selector" }
    });
    this.updateModelSelector();
    this.modelSelectEl.addEventListener("change", () => {
      this.currentModelId = this.modelSelectEl.value;
    });
  }
  updateModelSelector() {
    this.modelSelectEl.empty();
    const models = this.modelManager.getActiveModels();
    models.forEach((model) => {
      const option = this.modelSelectEl.createEl("option", {
        text: model.isDefault ? `${model.name} (Default)` : model.name,
        attr: { value: model.id }
      });
      if (model.isDefault) {
        option.style.fontWeight = "bold";
      }
    });
    const defaultModel = this.modelManager.getDefaultModel();
    if (!this.currentModelId || !models.find((m) => m.id === this.currentModelId)) {
      this.currentModelId = (defaultModel == null ? void 0 : defaultModel.id) || (models.length > 0 ? models[0].id : "");
    }
    this.modelSelectEl.value = this.currentModelId;
  }
  onSendMessage() {
    return __async(this, null, function* () {
      const userInput = this.currentInput.value.trim();
      if (!userInput) {
        return;
      }
      yield this.addMessage("user", userInput);
      this.currentInput.value = "";
      try {
        let response;
        if (this.modelManager && this.currentModelId) {
          response = yield this.modelManager.callModel(this.currentModelId, userInput);
        } else {
          response = yield this.plugin.callAI(userInput);
        }
        yield this.addMessage("assistant", response);
        yield this.saveChatHistory();
      } catch (error) {
        console.error("Error sending message to model:", error);
        yield this.addMessage("assistant", `Error: ${error.message}`);
      }
    });
  }
};

// src/models/ModelManager.ts
var ModelManager = class {
  constructor(plugin, initialModels = [], initialProxyConfig = {
    enabled: false,
    address: "",
    port: "",
    type: "http",
    requiresAuth: false
  }, saveCallback) {
    this.plugin = plugin;
    this.models = [];
    this.models = initialModels;
    this.proxyConfig = initialProxyConfig;
    this.saveSettingsCallback = saveCallback;
  }
  loadConfigs(models, proxyConfig) {
    this.models = models || [];
    this.proxyConfig = proxyConfig || {
      enabled: false,
      address: "",
      port: "",
      type: "http",
      requiresAuth: false
    };
  }
  getModels() {
    return [...this.models];
  }
  getActiveModels() {
    return this.models.filter((model) => model.active);
  }
  getModelById(id) {
    return this.models.find((m) => m.id === id);
  }
  addModel(model) {
    if (model.isDefault) {
      this.models.forEach((m) => {
        if (m.id !== model.id) {
          m.isDefault = false;
        }
      });
    }
    const existingIndex = this.models.findIndex((m) => m.id === model.id);
    if (existingIndex >= 0) {
      this.models[existingIndex] = model;
    } else {
      this.models.push(model);
    }
    this.saveModels();
  }
  updateModel(id, updates) {
    const modelIndex = this.models.findIndex((m) => m.id === id);
    if (modelIndex >= 0) {
      this.models[modelIndex] = __spreadValues(__spreadValues({}, this.models[modelIndex]), updates);
      this.saveModels();
    }
  }
  removeModel(id) {
    this.models = this.models.filter((model) => model.id !== id);
    this.saveModels();
  }
  getProxyConfig() {
    return this.proxyConfig;
  }
  updateProxyConfig(config) {
    this.proxyConfig = __spreadValues(__spreadValues({}, this.proxyConfig), config);
    this.saveProxyConfig();
  }
  saveModels() {
    this.saveSettingsCallback();
  }
  saveProxyConfig() {
    this.saveSettingsCallback();
  }
  callModel(_0, _1) {
    return __async(this, arguments, function* (modelId, prompt, options2 = {}) {
      const model = this.getModelById(modelId);
      if (!model) throw new Error(`Model ${modelId} not found`);
      const useProxy = model.useProxy !== void 0 ? model.useProxy : this.proxyConfig.enabled;
      let result = "";
      try {
        console.log(`Calling model: ${model.name} (${model.type}) with prompt: ${prompt.substring(0, 50)}...`);
        switch (model.type) {
          case "openai":
            result = yield this.callOpenAI(model, prompt, useProxy, options2);
            break;
          case "ollama":
            result = yield this.callOllama(model, prompt, useProxy, options2);
            break;
          case "claude":
            result = yield this.callClaude(model, prompt, useProxy, options2);
            break;
          case "zhipu":
          case "zhipuai":
            result = yield this.callZhipu(model, prompt, useProxy, options2);
            break;
          case "baidu":
            result = yield this.callBaidu(model, prompt, useProxy, options2);
            break;
          case "custom":
            result = yield this.callCustomAPI(model, prompt, useProxy, options2);
            break;
          default:
            throw new Error(`Model type ${model.type} not supported`);
        }
        return result;
      } catch (error) {
        console.error(`Error calling model ${model.name} (${model.type}):`, error);
        throw error;
      }
    });
  }
  callOpenAI(model, prompt, useProxy, options2) {
    return __async(this, null, function* () {
      const url = model.baseUrl || "https://api.openai.com/v1/chat/completions";
      const headers = {
        "Content-Type": "application/json",
        "Authorization": `Bearer ${model.apiKey}`
      };
      const payload = {
        model: options2.modelName || model.modelName || "gpt-3.5-turbo",
        messages: [
          { role: "system", content: model.systemPrompt || "You are a helpful assistant." },
          { role: "user", content: prompt }
        ],
        temperature: options2.temperature || 0.7,
        max_tokens: options2.maxTokens || 2048
      };
      const response = yield this.fetchWithProxy(url, {
        method: "POST",
        headers,
        body: JSON.stringify(payload)
      }, useProxy);
      const data = yield response.json();
      return data.choices[0].message.content;
    });
  }
  callOllama(model, prompt, useProxy, options2) {
    return __async(this, null, function* () {
      const url = model.baseUrl || "http://localhost:11434/api/generate";
      const headers = {
        "Content-Type": "application/json"
      };
      const payload = {
        model: options2.modelName || model.modelName || "llama2",
        prompt,
        system: model.systemPrompt || "You are a helpful assistant.",
        options: {
          temperature: options2.temperature || 0.7,
          num_predict: options2.maxTokens || 2048
        }
      };
      const response = yield this.fetchWithProxy(url, {
        method: "POST",
        headers,
        body: JSON.stringify(payload)
      }, useProxy);
      const data = yield response.json();
      return data.response;
    });
  }
  callClaude(model, prompt, useProxy, options2) {
    return __async(this, null, function* () {
      const url = model.baseUrl || "https://api.anthropic.com/v1/messages";
      const headers = {
        "Content-Type": "application/json",
        "anthropic-version": "2023-06-01"
      };
      if (model.apiKey) {
        headers["x-api-key"] = model.apiKey;
      }
      const payload = {
        model: options2.modelName || model.modelName || "claude-3-opus-20240229",
        messages: [
          { role: "user", content: prompt }
        ],
        system: model.systemPrompt || "You are Claude, a helpful AI assistant.",
        max_tokens: options2.maxTokens || 2048
      };
      const response = yield this.fetchWithProxy(url, {
        method: "POST",
        headers,
        body: JSON.stringify(payload)
      }, useProxy);
      const data = yield response.json();
      return data.content[0].text;
    });
  }
  callZhipu(model, prompt, useProxy, options2) {
    return __async(this, null, function* () {
      var _a, _b, _c, _d, _e, _f, _g;
      const isZhipuAI = model.type === "zhipuai";
      let baseUrl = "";
      if (model.baseUrl) {
        baseUrl = model.baseUrl;
        if (baseUrl.endsWith("/v4") || baseUrl.endsWith("/v3")) {
          baseUrl += "/chat/completions";
        }
      } else {
        baseUrl = isZhipuAI ? "https://open.bigmodel.cn/api/paas/v4/chat/completions" : "https://open.bigmodel.cn/api/paas/v3/chat/completions";
      }
      console.log(`ZhipuAI: Using endpoint ${baseUrl} for model type ${model.type}`);
      let headers = {
        "Content-Type": "application/json"
      };
      if (model.apiKey) {
        headers["Authorization"] = `Bearer ${model.apiKey}`;
      }
      const modelName = model.modelName || options2.modelName || (isZhipuAI ? "glm-4" : "glm-4");
      const streaming = !!options2.streaming;
      const onChunk = options2.onChunk;
      const payload = {
        model: modelName,
        messages: options2.conversation || [
          { role: "system", content: model.systemPrompt || "You are a helpful assistant." },
          { role: "user", content: prompt }
        ],
        temperature: options2.temperature || 0.7,
        max_tokens: options2.maxTokens || 2048,
        stream: streaming
        // Enable streaming if requested
      };
      try {
        console.log(`ZhipuAI: Sending request to ${baseUrl} with model ${modelName}, streaming: ${streaming}`);
        if (streaming && typeof onChunk === "function") {
          let fullResponse = "";
          const response2 = yield this.fetchWithProxy(baseUrl, {
            method: "POST",
            headers,
            body: JSON.stringify(payload)
          }, useProxy);
          if (!response2.ok) {
            const errorData = yield response2.text();
            console.error(`ZhipuAI API error (${response2.status}): ${errorData}`);
            throw new Error(`ZhipuAI API error: ${response2.status} ${response2.statusText}`);
          }
          const reader = (_a = response2.body) == null ? void 0 : _a.getReader();
          if (!reader) {
            throw new Error("Failed to get response reader for streaming");
          }
          const decoder = new TextDecoder();
          let buffer = "";
          while (true) {
            const { done, value } = yield reader.read();
            if (done) break;
            buffer += decoder.decode(value, { stream: true });
            let newlineIndex;
            while ((newlineIndex = buffer.indexOf("\n")) !== -1) {
              const line = buffer.slice(0, newlineIndex).trim();
              buffer = buffer.slice(newlineIndex + 1);
              if (line.startsWith("data:")) {
                const jsonData = line.slice(5).trim();
                if (jsonData === "" || jsonData === "[DONE]") continue;
                try {
                  const parsedData = JSON.parse(jsonData);
                  if ((_d = (_c = (_b = parsedData.choices) == null ? void 0 : _b[0]) == null ? void 0 : _c.delta) == null ? void 0 : _d.content) {
                    const content = parsedData.choices[0].delta.content;
                    fullResponse += content;
                    onChunk(content);
                  }
                } catch (e) {
                  console.error("Error parsing streaming data:", e, jsonData);
                }
              }
            }
          }
          return fullResponse;
        }
        const response = yield this.fetchWithProxy(baseUrl, {
          method: "POST",
          headers,
          body: JSON.stringify(payload)
        }, useProxy);
        if (!response.ok) {
          const errorData = yield response.text();
          console.error(`ZhipuAI API error (${response.status}): ${errorData}`);
          if (response.status === 404) {
            console.error("ZhipuAI API endpoint not found. Please verify the correct endpoint URL.");
            throw new Error(`ZhipuAI API endpoint not found. Please check your model configuration and API documentation for the correct URL. Status: ${response.status}`);
          }
          throw new Error(`ZhipuAI API error: ${response.status} ${response.statusText}`);
        }
        const data = yield response.json();
        console.log("ZhipuAI response:", JSON.stringify(data).substring(0, 200) + "...");
        if (data.choices && ((_f = (_e = data.choices[0]) == null ? void 0 : _e.message) == null ? void 0 : _f.content)) {
          return data.choices[0].message.content;
        } else if (data.data && data.data.choices && ((_g = data.data.choices[0]) == null ? void 0 : _g.content)) {
          return data.data.choices[0].content;
        } else if (data.response) {
          return data.response;
        } else {
          console.warn("Unexpected ZhipuAI response format:", data);
          return JSON.stringify(data);
        }
      } catch (error) {
        console.error("Error calling ZhipuAI:", error);
        throw error;
      }
    });
  }
  callBaidu(model, prompt, useProxy, options2) {
    return __async(this, null, function* () {
      const url = model.baseUrl || "https://aip.baidubce.com/rpc/2.0/ai_custom/v1/wenxinworkshop/chat/";
      const headers = {
        "Content-Type": "application/json",
        "Authorization": `Bearer ${model.apiKey}`
      };
      const payload = {
        messages: [
          { role: "system", content: model.systemPrompt || "You are a helpful assistant." },
          { role: "user", content: prompt }
        ],
        temperature: options2.temperature || 0.7,
        max_tokens: options2.maxTokens || 2048
      };
      const response = yield this.fetchWithProxy(url, {
        method: "POST",
        headers,
        body: JSON.stringify(payload)
      }, useProxy);
      const data = yield response.json();
      return data.result;
    });
  }
  callCustomAPI(model, prompt, useProxy, options2) {
    return __async(this, null, function* () {
      if (!model.baseUrl) throw new Error("Base URL is required for custom API model");
      const headers = {
        "Content-Type": "application/json"
      };
      if (model.apiKey) {
        headers["Authorization"] = `Bearer ${model.apiKey}`;
      }
      const payload = {
        prompt,
        system_prompt: model.systemPrompt || "You are a helpful assistant.",
        temperature: options2.temperature || 0.7,
        max_tokens: options2.maxTokens || 2048
      };
      const response = yield this.fetchWithProxy(model.baseUrl, {
        method: "POST",
        headers,
        body: JSON.stringify(payload)
      }, useProxy);
      const data = yield response.json();
      return data.response || data.result || data.text || JSON.stringify(data);
    });
  }
  fetchWithProxy(url, options2, useProxy) {
    return __async(this, null, function* () {
      try {
        console.log(`Making request to: ${url}`);
        if (!useProxy || !this.proxyConfig.enabled) {
          return fetch(url, options2);
        }
        console.log(`Using proxy: ${this.proxyConfig.type}://${this.proxyConfig.address}:${this.proxyConfig.port}`);
        return fetch(url, options2);
      } catch (error) {
        console.error(`Fetch error for ${url}:`, error);
        throw error;
      }
    });
  }
  callMultipleModels(_0, _1) {
    return __async(this, arguments, function* (modelIds, prompt, options2 = {}) {
      const results = {};
      yield Promise.all(modelIds.map((modelId) => __async(this, null, function* () {
        try {
          const result = yield this.callModel(modelId, prompt, options2);
          results[modelId] = result;
        } catch (error) {
          console.error(`Error calling model ${modelId}:`, error);
          results[modelId] = `Error: ${error.message}`;
        }
      })));
      return results;
    });
  }
  getDefaultModel() {
    const defaultModel = this.models.find((m) => m.isDefault && m.active);
    if (defaultModel) {
      return defaultModel;
    }
    const firstActive = this.models.find((m) => m.active);
    return firstActive || null;
  }
  // Add new methods for embedding functionality
  getEmbedding(text, modelId) {
    return __async(this, null, function* () {
      const model = modelId ? this.getModelById(modelId) : this.getDefaultModel();
      if (!model) {
        throw new Error("No model found for embedding generation");
      }
      const embeddingModel = model.embeddingModel || "embedding-3";
      try {
        console.log(`Getting embedding using model: ${model.name}, embedding model: ${embeddingModel}`);
        const useProxy = model.useProxy !== void 0 ? model.useProxy : this.proxyConfig.enabled;
        switch (model.type) {
          case "openai":
            return yield this.getOpenAIEmbedding(model, text, embeddingModel, useProxy);
          case "zhipu":
          case "zhipuai":
            return yield this.getZhipuEmbedding(model, text, embeddingModel, useProxy);
          case "custom":
            return yield this.getCustomEmbedding(model, text, embeddingModel, useProxy);
          default:
            throw new Error(`Embedding not supported for model type: ${model.type}`);
        }
      } catch (error) {
        console.error(`Error getting embedding using model ${model.name}:`, error);
        throw error;
      }
    });
  }
  getOpenAIEmbedding(model, text, embeddingModel, useProxy) {
    return __async(this, null, function* () {
      var _a, _b;
      const url = "https://api.openai.com/v1/embeddings";
      const headers = {
        "Authorization": `Bearer ${model.apiKey}`,
        "Content-Type": "application/json"
      };
      const payload = {
        model: embeddingModel,
        input: text
      };
      const response = yield this.fetchWithProxy(url, {
        method: "POST",
        headers,
        body: JSON.stringify(payload)
      }, useProxy);
      const data = yield response.json();
      if (!((_b = (_a = data.data) == null ? void 0 : _a[0]) == null ? void 0 : _b.embedding)) {
        throw new Error("Invalid embedding response from OpenAI");
      }
      return data.data[0].embedding;
    });
  }
  getZhipuEmbedding(model, text, embeddingModel, useProxy) {
    return __async(this, null, function* () {
      var _a, _b;
      const url = model.baseUrl || "https://open.bigmodel.cn/api/paas/v4/embeddings";
      const headers = {
        "Authorization": `Bearer ${model.apiKey}`,
        "Content-Type": "application/json"
      };
      const MAX_CHARS = 3e3;
      if (text.length > MAX_CHARS) {
        const truncated = text.substring(0, MAX_CHARS);
        const lastPeriod = truncated.lastIndexOf(".");
        const lastNewline = truncated.lastIndexOf("\n");
        const breakPoint = Math.max(lastPeriod, lastNewline);
        text = breakPoint > 0 ? truncated.substring(0, breakPoint + 1) : truncated;
      }
      const payload = {
        model: embeddingModel,
        input: text,
        dimensions: embeddingModel === "embedding-3" ? 1024 : void 0
      };
      console.log(`ZhipuAI Embedding: Sending request to ${url} with model ${embeddingModel}`);
      const response = yield this.fetchWithProxy(url, {
        method: "POST",
        headers,
        body: JSON.stringify(payload)
      }, useProxy);
      if (!response.ok) {
        const errorData = yield response.text();
        console.error(`ZhipuAI Embedding API error (${response.status}): ${errorData}`);
        if (response.status === 404) {
          throw new Error(`ZhipuAI Embedding API endpoint not found. Please check your model configuration and API documentation for the correct URL. Status: ${response.status}`);
        }
        throw new Error(`ZhipuAI Embedding API error: ${response.status} ${response.statusText}`);
      }
      const data = yield response.json();
      if (!((_b = (_a = data.data) == null ? void 0 : _a[0]) == null ? void 0 : _b.embedding)) {
        console.error("Invalid embedding response from ZhipuAI:", data);
        throw new Error("Invalid embedding response from ZhipuAI");
      }
      return data.data[0].embedding;
    });
  }
  getCustomEmbedding(model, text, embeddingModel, useProxy) {
    return __async(this, null, function* () {
      var _a, _b;
      if (!model.baseUrl) {
        throw new Error("Base URL is required for custom embedding API");
      }
      const headers = {
        "Content-Type": "application/json"
      };
      if (model.apiKey) {
        headers["Authorization"] = `Bearer ${model.apiKey}`;
      }
      const payload = {
        model: embeddingModel,
        input: text
      };
      const response = yield this.fetchWithProxy(model.baseUrl + "/embeddings", {
        method: "POST",
        headers,
        body: JSON.stringify(payload)
      }, useProxy);
      const data = yield response.json();
      if (!((_b = (_a = data.data) == null ? void 0 : _a[0]) == null ? void 0 : _b.embedding)) {
        throw new Error("Invalid embedding response from custom API");
      }
      return data.data[0].embedding;
    });
  }
};

// src/debate/DebatePanel.ts
var import_obsidian3 = require("obsidian");

// src/debate/AgentDebateEngine.ts
var Agent = class {
  constructor(id, name, rolePrompt, modelId, modelManager) {
    this.id = id;
    this.name = name;
    this.rolePrompt = rolePrompt;
    this.modelId = modelId;
    this.modelManager = modelManager;
  }
  think(message, context = "", onChunk) {
    return __async(this, null, function* () {
      const fullPrompt = `${context}

${this.rolePrompt}

${message}`;
      try {
        return yield this.modelManager.callModel(
          this.modelId,
          fullPrompt,
          {
            streaming: !!onChunk,
            onChunk
          }
        );
      } catch (error) {
        console.error(`Error in agent ${this.name} thinking:`, error);
        return `[Agent ${this.name} encountered an error: ${error.message}]`;
      }
    });
  }
};
var AgentDebateEngine = class _AgentDebateEngine {
  // Default language
  constructor(agents, hostAgent, maxRounds = 3, language = "English") {
    this.round = 0;
    this.agents = [];
    this.messages = [];
    this.currentAgentIndex = 0;
    this.isRunning = false;
    this.isComplete = false;
    this.onMessageCallback = null;
    this.onCompleteCallback = null;
    this.onMessageUpdateCallback = null;
    this.language = "English";
    this.agents = agents;
    this.hostAgent = hostAgent;
    this.maxRounds = maxRounds;
    this.language = language;
  }
  getMessages() {
    return [...this.messages];
  }
  getStatus() {
    return {
      currentRound: this.round,
      currentAgentIndex: this.currentAgentIndex,
      isComplete: this.isComplete,
      messages: [...this.messages]
    };
  }
  onMessage(callback) {
    this.onMessageCallback = callback;
  }
  onComplete(callback) {
    this.onCompleteCallback = callback;
  }
  onMessageUpdate(callback) {
    this.onMessageUpdateCallback = callback;
  }
  resetDebate() {
    this.round = 0;
    this.messages = [];
    this.currentAgentIndex = 0;
    this.isRunning = false;
    this.isComplete = false;
  }
  startDebate(topic) {
    return __async(this, null, function* () {
      if (this.isRunning) {
        throw new Error("Debate is already running");
      }
      this.resetDebate();
      this.isRunning = true;
      try {
        const config = this.getConfig();
        const language = (config == null ? void 0 : config.language) || "English";
        const hostPrompt = `You are the host of a debate or discussion. Your role is to introduce the topic, establish the key points to be discussed, and guide the conversation.
      
      First, provide a thoughtful introduction to this topic: "${topic}"
      
      Then, outline the key aspects that should be discussed by our participants. What are the main points to consider?
      
      Please respond in ${language}.`;
        const hostMessageId = `msg_${Date.now()}`;
        const hostMessage = {
          id: hostMessageId,
          agentId: this.hostAgent.id,
          content: "",
          timestamp: Date.now(),
          round: 0,
          streaming: true
        };
        this.messages.push(hostMessage);
        if (this.onMessageCallback) {
          this.onMessageCallback(hostMessage);
        }
        const hostIntro = yield this.hostAgent.think(hostPrompt, "", (chunk) => {
          const messageIndex = this.messages.findIndex((m) => m.id === hostMessageId);
          if (messageIndex >= 0) {
            this.messages[messageIndex].content += chunk;
            if (this.onMessageUpdateCallback) {
              this.onMessageUpdateCallback(this.messages[messageIndex]);
            }
          }
        });
        const finalMessageIndex = this.messages.findIndex((m) => m.id === hostMessageId);
        if (finalMessageIndex >= 0) {
          this.messages[finalMessageIndex].streaming = false;
          if (this.onMessageUpdateCallback) {
            this.onMessageUpdateCallback(this.messages[finalMessageIndex]);
          }
        }
        yield this.runDebateRounds(topic);
        yield this.generateConclusion(topic);
        this.isComplete = true;
        this.isRunning = false;
        if (this.onCompleteCallback) {
          this.onCompleteCallback();
        }
      } catch (error) {
        console.error("Error running debate:", error);
        this.isRunning = false;
        throw error;
      }
    });
  }
  runDebateRounds(topic) {
    return __async(this, null, function* () {
      const context = this.buildDebateContext();
      const config = this.getConfig();
      const language = (config == null ? void 0 : config.language) || "English";
      for (this.round = 1; this.round <= this.maxRounds; this.round++) {
        for (let i = 0; i < this.agents.length; i++) {
          this.currentAgentIndex = i;
          const agent = this.agents[i];
          const updatedContext = this.buildDebateContext();
          const agentPrompt = `We are in round ${this.round} of the debate on: "${topic}"

Previous messages:
${updatedContext}

Based on the previous discussion, provide your perspective as ${agent.name}. 
Address points made by other participants if relevant, and further develop your own arguments.

Please respond in ${language}.`;
          const messageId = `msg_${Date.now()}_${agent.id}_${this.round}`;
          const message = {
            id: messageId,
            agentId: agent.id,
            content: "",
            timestamp: Date.now(),
            round: this.round,
            streaming: true
          };
          this.messages.push(message);
          if (this.onMessageCallback) {
            this.onMessageCallback(message);
          }
          yield agent.think(agentPrompt, "", (chunk) => {
            const messageIndex = this.messages.findIndex((m) => m.id === messageId);
            if (messageIndex >= 0) {
              this.messages[messageIndex].content += chunk;
              if (this.onMessageUpdateCallback) {
                this.onMessageUpdateCallback(this.messages[messageIndex]);
              }
            }
          });
          const finalMessageIndex = this.messages.findIndex((m) => m.id === messageId);
          if (finalMessageIndex >= 0) {
            this.messages[finalMessageIndex].streaming = false;
            if (this.onMessageUpdateCallback) {
              this.onMessageUpdateCallback(this.messages[finalMessageIndex]);
            }
          }
        }
      }
    });
  }
  generateConclusion(topic) {
    return __async(this, null, function* () {
      const context = this.buildDebateContext();
      const config = this.getConfig();
      const language = (config == null ? void 0 : config.language) || "English";
      const conclusionPrompt = `Now that we've completed ${this.maxRounds} rounds of our debate on "${topic}", please provide a thoughtful conclusion.

Summarize the key points made by each participant, identify areas of agreement and disagreement, and provide your own synthesis of the discussion.

The full debate transcript:
${context}

Please respond in ${language}.`;
      const conclusionId = `msg_conclusion_${Date.now()}`;
      const conclusionMessage = {
        id: conclusionId,
        agentId: this.hostAgent.id,
        content: "",
        timestamp: Date.now(),
        round: this.maxRounds + 1,
        streaming: true
      };
      this.messages.push(conclusionMessage);
      if (this.onMessageCallback) {
        this.onMessageCallback(conclusionMessage);
      }
      yield this.hostAgent.think(conclusionPrompt, "", (chunk) => {
        const messageIndex = this.messages.findIndex((m) => m.id === conclusionId);
        if (messageIndex >= 0) {
          this.messages[messageIndex].content += chunk;
          if (this.onMessageUpdateCallback) {
            this.onMessageUpdateCallback(this.messages[messageIndex]);
          }
        }
      });
      const finalMessageIndex = this.messages.findIndex((m) => m.id === conclusionId);
      if (finalMessageIndex >= 0) {
        this.messages[finalMessageIndex].streaming = false;
        if (this.onMessageUpdateCallback) {
          this.onMessageUpdateCallback(this.messages[finalMessageIndex]);
        }
      }
    });
  }
  buildDebateContext() {
    return this.messages.map((msg) => {
      const agent = this.agents.find((a) => a.id === msg.agentId) || this.hostAgent;
      return `[Round ${msg.round}] ${agent.name}: ${msg.content}`;
    }).join("\n\n");
  }
  static createFromConfig(config, modelManager) {
    const agents = config.agents.filter((a) => a.active).map((agentConfig) => new Agent(
      agentConfig.id,
      agentConfig.name,
      agentConfig.rolePrompt,
      agentConfig.modelId,
      modelManager
    ));
    const hostAgent = new Agent(
      config.hostAgent.id,
      config.hostAgent.name,
      config.hostAgent.rolePrompt,
      config.hostAgent.modelId,
      modelManager
    );
    return new _AgentDebateEngine(
      agents,
      hostAgent,
      config.maxRounds,
      config.language
    );
  }
  static generateDebatePrompts(mode) {
    const prompts = {
      host: "You are the host and moderator of this discussion. Your role is to introduce the topic, guide the conversation, ask probing questions, and ensure all perspectives are heard. At the end, you'll summarize the key points and provide a balanced conclusion.",
      positive: "You are advocating for the positive or affirmative position on this topic. Present the strongest arguments in favor, backed by reasoning and evidence where possible. Address counterarguments in a respectful way.",
      negative: "You are advocating for the negative or critical position on this topic. Present the strongest arguments against, backed by reasoning and evidence where possible. Address counterarguments in a respectful way.",
      blue: "Blue Hat (Process): You focus on managing the thinking process and ensuring productive discussion. You think about how to approach the problem, what thinking tools to use, and how to organize the conversation.",
      red: "Red Hat (Emotions): You focus on intuition, feelings, and emotional reactions. Express how the topic makes you feel, and consider the emotional aspects and impacts on people.",
      yellow: "Yellow Hat (Benefits): You focus on positivity, optimism, and benefits. Identify advantages, opportunities, and potential gains related to the topic.",
      green: "Green Hat (Creativity): You focus on creativity, alternatives, and new ideas. Propose innovative solutions, possibilities, and 'what if' scenarios related to the topic.",
      white: "White Hat (Facts): You focus on data, information, and objective facts. Provide relevant statistics, research findings, and verified information about the topic.",
      black: "Black Hat (Caution): You focus on critical judgment and potential problems. Identify risks, difficulties, and challenges related to the topic.",
      custom: "You are a participant in this discussion. Share your unique perspective on the topic based on your expertise and viewpoint."
    };
    return prompts;
  }
  static generateDefaultConfig(topic, mode, defaultModelId, language = "English") {
    const prompts = _AgentDebateEngine.generateDebatePrompts(mode);
    const timestamp = Date.now();
    let agents = [];
    switch (mode) {
      case "debate":
        agents = [
          {
            id: `agent_positive_${timestamp}`,
            name: "Proponent",
            role: "positive",
            rolePrompt: prompts.positive,
            modelId: defaultModelId,
            active: true
          },
          {
            id: `agent_negative_${timestamp}`,
            name: "Opponent",
            role: "negative",
            rolePrompt: prompts.negative,
            modelId: defaultModelId,
            active: true
          }
        ];
        break;
      case "sixHats":
        agents = [
          {
            id: `agent_white_${timestamp}`,
            name: "White Hat (Facts)",
            role: "white",
            rolePrompt: prompts.white,
            modelId: defaultModelId,
            active: true
          },
          {
            id: `agent_red_${timestamp}`,
            name: "Red Hat (Emotions)",
            role: "red",
            rolePrompt: prompts.red,
            modelId: defaultModelId,
            active: true
          },
          {
            id: `agent_black_${timestamp}`,
            name: "Black Hat (Caution)",
            role: "black",
            rolePrompt: prompts.black,
            modelId: defaultModelId,
            active: true
          },
          {
            id: `agent_yellow_${timestamp}`,
            name: "Yellow Hat (Benefits)",
            role: "yellow",
            rolePrompt: prompts.yellow,
            modelId: defaultModelId,
            active: true
          },
          {
            id: `agent_green_${timestamp}`,
            name: "Green Hat (Creativity)",
            role: "green",
            rolePrompt: prompts.green,
            modelId: defaultModelId,
            active: true
          },
          {
            id: `agent_blue_${timestamp}`,
            name: "Blue Hat (Process)",
            role: "blue",
            rolePrompt: prompts.blue,
            modelId: defaultModelId,
            active: true
          }
        ];
        break;
      case "roundtable":
        agents = [
          {
            id: `agent_expert1_${timestamp}`,
            name: "Subject Matter Expert",
            role: "custom",
            rolePrompt: "You are a subject matter expert with deep knowledge of this topic. Provide factual information, historical context, and technical details that help illuminate the discussion.",
            modelId: defaultModelId,
            active: true
          },
          {
            id: `agent_critic_${timestamp}`,
            name: "Critical Analyst",
            role: "custom",
            rolePrompt: "You analyze the topic critically, looking for logical flaws, inconsistencies, and areas that deserve more scrutiny. Your goal is to strengthen the discussion through thoughtful criticism.",
            modelId: defaultModelId,
            active: true
          },
          {
            id: `agent_innovator_${timestamp}`,
            name: "Innovator",
            role: "custom",
            rolePrompt: "You specialize in finding new approaches and creative solutions. Consider how the topic could be reimagined or what novel perspectives might add value to the discussion.",
            modelId: defaultModelId,
            active: true
          },
          {
            id: `agent_custom_${timestamp}`,
            name: "Custom",
            role: "custom",
            rolePrompt: "You are a custom participant in this discussion. Share your unique perspective on the topic based on your expertise and viewpoint.",
            modelId: defaultModelId,
            active: true
          }
        ];
        break;
    }
    const hostAgent = {
      id: `host_${timestamp}`,
      name: "Host",
      role: "host",
      rolePrompt: prompts.host,
      modelId: defaultModelId,
      active: true
    };
    return {
      id: `debate_${timestamp}`,
      title: `Debate on ${topic}`,
      topic,
      mode,
      agents,
      hostAgent,
      maxRounds: 3,
      maxTokensPerResponse: 1e3,
      createdAt: timestamp,
      active: true,
      language
    };
  }
  // Helper method to get config from debate context
  getConfig() {
    return {
      id: "",
      title: "",
      topic: "",
      mode: "debate",
      agents: [],
      hostAgent: { id: "", name: "", role: "host", rolePrompt: "", modelId: "", active: true },
      maxRounds: this.maxRounds,
      maxTokensPerResponse: 1e3,
      createdAt: Date.now(),
      active: true,
      language: this.language
    };
  }
};

// src/debate/DebatePanel.ts
var DEBATE_VIEW_TYPE = "aipilot-debate-view";
var DebatePanel = class extends import_obsidian3.ItemView {
  constructor(leaf, modelManager) {
    super(leaf);
    this.debateEngine = null;
    this.debateConfig = null;
    this.modelManager = modelManager;
  }
  getViewType() {
    return DEBATE_VIEW_TYPE;
  }
  getDisplayText() {
    return "Debate & Reasoning";
  }
  onOpen() {
    return __async(this, null, function* () {
      this.containerEl = this.contentEl.createDiv({ cls: "debate-view-container" });
      this.createHeader();
      this.createConfigPanel();
      this.createMessagesContainer();
      this.createStatusBar();
      this.initializeDefaultConfig();
    });
  }
  onClose() {
    return __async(this, null, function* () {
    });
  }
  createHeader() {
    const headerEl = this.containerEl.createDiv({ cls: "debate-header" });
    const titleEl = headerEl.createEl("h2", { text: "AI Agent Debate" });
    const descriptionEl = headerEl.createEl("p", {
      text: "Create a multi-agent debate or discussion on any topic. Select a debate mode, configure your settings, and let multiple AI agents discuss the topic from different perspectives."
    });
  }
  createConfigPanel() {
    const configPanelEl = this.containerEl.createDiv({ cls: "debate-config-panel" });
    const headerEl = configPanelEl.createEl("h2", { text: "AI Agent Debate" });
    const topicWrapperEl = configPanelEl.createDiv({ cls: "config-input-wrapper" });
    topicWrapperEl.createEl("label", { text: "Topic", attr: { for: "debate-topic" } });
    this.topicInputEl = topicWrapperEl.createEl("input", {
      cls: "debate-topic-input",
      attr: {
        id: "debate-topic",
        type: "text",
        placeholder: "Enter debate topic"
      }
    });
    const languageWrapperEl = configPanelEl.createDiv({ cls: "config-input-wrapper" });
    languageWrapperEl.createEl("label", { text: "Language", attr: { for: "debate-language" } });
    this.languageSelectEl = languageWrapperEl.createEl("select", {
      cls: "debate-language-select",
      attr: { id: "debate-language" }
    });
    const languages = [
      "English",
      "Spanish",
      "French",
      "German",
      "Chinese",
      "Japanese",
      "Russian",
      "Arabic",
      "Hindi",
      "Portuguese",
      "Italian",
      "Dutch",
      "Korean",
      "Turkish",
      "Swedish",
      "Polish",
      "Vietnamese",
      "Thai",
      "Greek",
      "Hebrew"
    ];
    languages.forEach((lang) => {
      this.languageSelectEl.createEl("option", {
        text: lang,
        attr: { value: lang }
      });
    });
    const modeContainerEl = configPanelEl.createDiv({ cls: "config-item config-row" });
    const modeWrapperEl = modeContainerEl.createDiv({ cls: "config-input-wrapper" });
    modeWrapperEl.createEl("label", { text: "Debate Mode", attr: { for: "debate-mode" } });
    this.modeSelectEl = modeWrapperEl.createEl("select", {
      cls: "debate-mode-select",
      attr: { id: "debate-mode" }
    });
    this.modeSelectEl.createEl("option", { text: "Debate (Pro vs Con)", attr: { value: "debate" } });
    this.modeSelectEl.createEl("option", { text: "Six Thinking Hats", attr: { value: "sixHats" } });
    this.modeSelectEl.createEl("option", { text: "Roundtable Discussion", attr: { value: "roundtable" } });
    this.modeSelectEl.addEventListener("change", () => this.onModeChange());
    const roundsWrapperEl = modeContainerEl.createDiv({ cls: "config-input-wrapper" });
    roundsWrapperEl.createEl("label", { text: "Rounds", attr: { for: "debate-rounds" } });
    this.roundsInputEl = roundsWrapperEl.createEl("input", {
      cls: "debate-rounds-input",
      attr: {
        id: "debate-rounds",
        type: "number",
        min: "1",
        max: "5",
        value: "3"
      }
    });
    this.controlsEl = configPanelEl.createDiv({ cls: "debate-controls" });
    this.startButtonEl = this.controlsEl.createEl("button", {
      cls: "debate-start-button",
      text: "Start Debate"
    });
    this.startButtonEl.addEventListener("click", () => this.startDebate());
    this.exportButtonEl = this.controlsEl.createEl("button", {
      cls: "debate-export-button",
      text: "Export to Note",
      attr: { disabled: "true" }
    });
    this.exportButtonEl.addEventListener("click", () => this.exportToNote());
  }
  createMessagesContainer() {
    this.messagesContainerEl = this.containerEl.createDiv({ cls: "debate-messages-container" });
    const emptyStateEl = this.messagesContainerEl.createDiv({ cls: "debate-empty-state" });
    const emptyIconEl = emptyStateEl.createDiv({ cls: "debate-empty-icon" });
    emptyStateEl.createEl("h3", { text: "No Active Debate" });
    emptyStateEl.createEl("p", {
      text: 'Configure your debate settings above and click "Start Debate" to begin a new multi-agent discussion.'
    });
  }
  createStatusBar() {
    this.statusEl = this.containerEl.createDiv({ cls: "debate-status-bar" });
    this.statusEl.textContent = "Ready to start";
  }
  initializeDefaultConfig() {
    const models = this.modelManager.getModels();
    const defaultModelId = models.length > 0 ? models[0].id : "default_model_id";
    this.debateConfig = AgentDebateEngine.generateDefaultConfig(
      "",
      "debate",
      defaultModelId,
      this.languageSelectEl.value
    );
  }
  onModeChange() {
    if (!this.debateConfig) return;
    const selectedMode = this.modeSelectEl.value;
    const topic = this.topicInputEl.value.trim();
    const language = this.languageSelectEl.value;
    const models = this.modelManager.getModels();
    const defaultModelId = models.length > 0 ? models[0].id : "default_model_id";
    this.debateConfig = AgentDebateEngine.generateDefaultConfig(
      topic,
      selectedMode,
      defaultModelId,
      language
    );
  }
  startDebate() {
    return __async(this, null, function* () {
      const topic = this.topicInputEl.value.trim();
      if (!topic) {
        new import_obsidian3.Notice("Please enter a topic for the debate");
        return;
      }
      if (!this.debateConfig) {
        new import_obsidian3.Notice("Debate configuration not initialized");
        return;
      }
      const rounds = parseInt(this.roundsInputEl.value);
      if (rounds > 0) {
        this.debateConfig.maxRounds = rounds;
      }
      this.debateConfig.topic = topic;
      this.debateConfig.language = this.languageSelectEl.value;
      this.messagesContainerEl.empty();
      this.statusEl.textContent = "Starting debate...";
      this.startButtonEl.disabled = true;
      this.startButtonEl.textContent = "Debate in Progress...";
      try {
        this.debateEngine = AgentDebateEngine.createFromConfig(
          this.debateConfig,
          this.modelManager
        );
        this.debateEngine.onMessage((message) => {
          this.renderMessage(message);
          this.messagesContainerEl.scrollTo({
            top: this.messagesContainerEl.scrollHeight,
            behavior: "smooth"
          });
        });
        this.debateEngine.onMessageUpdate((message) => {
          this.updateMessage(message);
          this.messagesContainerEl.scrollTo({
            top: this.messagesContainerEl.scrollHeight,
            behavior: "smooth"
          });
        });
        this.debateEngine.onComplete(() => {
          this.statusEl.textContent = "Debate completed";
          this.startButtonEl.disabled = false;
          this.startButtonEl.textContent = "Start New Debate";
          this.exportButtonEl.removeAttribute("disabled");
        });
        yield this.debateEngine.startDebate(topic);
      } catch (error) {
        console.error("Error starting debate:", error);
        new import_obsidian3.Notice(`Error starting debate: ${error.message}`);
        this.statusEl.textContent = "Error starting debate";
        this.startButtonEl.disabled = false;
        this.startButtonEl.textContent = "Start Debate";
      }
    });
  }
  renderMessage(message) {
    if (!this.debateEngine || !this.debateConfig) return;
    const messageEl = this.messagesContainerEl.createDiv({ cls: "debate-message" });
    messageEl.setAttribute("data-message-id", message.id);
    const isHost = message.agentId === this.debateConfig.hostAgent.id;
    const agent = isHost ? this.debateConfig.hostAgent : this.debateConfig.agents.find((a) => a.id === message.agentId);
    if (!agent) return;
    messageEl.addClass(`agent-role-${agent.role}`);
    if (isHost) messageEl.addClass("host-message");
    if (message.streaming) messageEl.addClass("streaming-message");
    const headerEl = messageEl.createDiv({ cls: "message-header" });
    const nameEl = headerEl.createEl("span", {
      cls: "agent-name",
      text: agent.name
    });
    const roundEl = headerEl.createEl("span", {
      cls: "message-round",
      text: message.round === 0 ? "Introduction" : message.round > this.debateConfig.maxRounds ? "Conclusion" : `Round ${message.round}`
    });
    const contentEl = messageEl.createDiv({ cls: "message-content" });
    const formattedContent = this.formatMarkdown(message.content);
    contentEl.appendChild(formattedContent);
    if (message.streaming) {
      const indicatorEl = messageEl.createDiv({ cls: "streaming-indicator" });
      indicatorEl.createSpan({ text: "Typing", cls: "typing-text" });
      const dotsContainer = indicatorEl.createDiv({ cls: "typing-dots-container" });
    }
  }
  updateMessage(message) {
    const messageEl = this.messagesContainerEl.querySelector(`[data-message-id="${message.id}"]`);
    if (!messageEl) return;
    const contentEl = messageEl.querySelector(".message-content");
    if (contentEl) {
      contentEl.empty();
      const formattedContent = this.formatMarkdown(message.content);
      contentEl.appendChild(formattedContent);
    }
    if (message.streaming) {
      messageEl.addClass("streaming-message");
      if (!messageEl.querySelector(".streaming-indicator")) {
        const indicatorEl = messageEl.createDiv({ cls: "streaming-indicator" });
        indicatorEl.createSpan({ text: "Typing", cls: "typing-text" });
        const dotsContainer = indicatorEl.createDiv({ cls: "typing-dots-container" });
      }
    } else {
      messageEl.removeClass("streaming-message");
      const indicatorEl = messageEl.querySelector(".streaming-indicator");
      if (indicatorEl) {
        indicatorEl.remove();
      }
    }
  }
  // Simple markdown formatter - replaced with a safer implementation
  formatMarkdown(text) {
    const container = document.createElement("div");
    container.className = "debate-markdown-container";
    const lines = text.split("\n");
    lines.forEach((line) => {
      const h1Match = line.match(/^# (.*?)$/);
      const h2Match = line.match(/^## (.*?)$/);
      const h3Match = line.match(/^### (.*?)$/);
      const h4Match = line.match(/^#### (.*?)$/);
      if (h1Match) {
        const h1 = document.createElement("h1");
        h1.textContent = h1Match[1];
        h1.className = "debate-markdown-heading debate-markdown-h1";
        container.appendChild(h1);
      } else if (h2Match) {
        const h2 = document.createElement("h2");
        h2.textContent = h2Match[1];
        h2.className = "debate-markdown-heading debate-markdown-h2";
        container.appendChild(h2);
      } else if (h3Match) {
        const h3 = document.createElement("h3");
        h3.textContent = h3Match[1];
        h3.className = "debate-markdown-heading debate-markdown-h3";
        container.appendChild(h3);
      } else if (h4Match) {
        const h4 = document.createElement("h4");
        h4.textContent = h4Match[1];
        h4.className = "debate-markdown-heading debate-markdown-h4";
        container.appendChild(h4);
      } else {
        const paragraph2 = document.createElement("p");
        paragraph2.className = "debate-markdown-paragraph";
        let content = line;
        const processedContent = this.processInlineMarkdown(content);
        paragraph2.appendChild(processedContent);
        container.appendChild(paragraph2);
      }
    });
    return container;
  }
  // Helper method to process inline markdown formatting
  processInlineMarkdown(text) {
    const fragment = document.createDocumentFragment();
    let currentPos = 0;
    let lastProcessedPos = 0;
    const processBold = (text2, fragment2) => {
      let pos = 0;
      while ((pos = text2.indexOf("**", pos)) !== -1) {
        const endPos = text2.indexOf("**", pos + 2);
        if (endPos === -1) break;
        if (pos > lastProcessedPos) {
          fragment2.appendChild(document.createTextNode(text2.substring(lastProcessedPos, pos)));
        }
        const bold = document.createElement("strong");
        bold.textContent = text2.substring(pos + 2, endPos);
        bold.className = "debate-markdown-bold";
        fragment2.appendChild(bold);
        lastProcessedPos = endPos + 2;
        pos = endPos + 2;
      }
    };
    const processItalic = (text2, fragment2) => {
      let pos = 0;
      while ((pos = text2.indexOf("*", pos)) !== -1) {
        if (pos > 0 && text2[pos - 1] === "*") {
          pos++;
          continue;
        }
        if (pos < text2.length - 1 && text2[pos + 1] === "*") {
          pos += 2;
          continue;
        }
        const endPos = text2.indexOf("*", pos + 1);
        if (endPos === -1) break;
        if (pos > lastProcessedPos) {
          fragment2.appendChild(document.createTextNode(text2.substring(lastProcessedPos, pos)));
        }
        const italic = document.createElement("em");
        italic.textContent = text2.substring(pos + 1, endPos);
        italic.className = "debate-markdown-italic";
        fragment2.appendChild(italic);
        lastProcessedPos = endPos + 1;
        pos = endPos + 1;
      }
    };
    const processCode = (text2, fragment2) => {
      let pos = 0;
      while ((pos = text2.indexOf("`", pos)) !== -1) {
        const endPos = text2.indexOf("`", pos + 1);
        if (endPos === -1) break;
        if (pos > lastProcessedPos) {
          fragment2.appendChild(document.createTextNode(text2.substring(lastProcessedPos, pos)));
        }
        const code = document.createElement("code");
        code.textContent = text2.substring(pos + 1, endPos);
        code.className = "debate-markdown-code";
        fragment2.appendChild(code);
        lastProcessedPos = endPos + 1;
        pos = endPos + 1;
      }
    };
    processBold(text, fragment);
    processItalic(text, fragment);
    processCode(text, fragment);
    if (lastProcessedPos < text.length) {
      fragment.appendChild(document.createTextNode(text.substring(lastProcessedPos)));
    }
    return fragment;
  }
  exportToNote() {
    return __async(this, null, function* () {
      if (!this.debateEngine || !this.debateConfig) {
        new import_obsidian3.Notice("No debate to export");
        return;
      }
      const messages = this.debateEngine.getMessages();
      if (messages.length === 0) {
        new import_obsidian3.Notice("No debate messages to export");
        return;
      }
      try {
        let markdown = `# Debate: ${this.debateConfig.topic}

`;
        markdown += `*Mode: ${this.getModeName(this.debateConfig.mode)} | Rounds: ${this.debateConfig.maxRounds} | Date: ${(/* @__PURE__ */ new Date()).toLocaleString()}*

`;
        for (const message of messages) {
          const isHost = message.agentId === this.debateConfig.hostAgent.id;
          const agent = isHost ? this.debateConfig.hostAgent : this.debateConfig.agents.find((a) => a.id === message.agentId);
          if (!agent) continue;
          const roundLabel = message.round === 0 ? "Introduction" : message.round > this.debateConfig.maxRounds ? "Conclusion" : `Round ${message.round}`;
          markdown += `## ${agent.name} (${roundLabel})

`;
          markdown += `${message.content}

`;
        }
        try {
          const noteName = `Debate - ${this.debateConfig.topic.substring(0, 30)}`;
          const file = yield this.app.vault.create(`${noteName}.md`, markdown);
          yield this.app.workspace.openLinkText(file.path, "", true);
          new import_obsidian3.Notice("Debate exported to new note");
        } catch (error) {
          console.error("Error creating note:", error);
          yield navigator.clipboard.writeText(markdown);
          new import_obsidian3.Notice("Could not create note. Debate content copied to clipboard.");
        }
      } catch (error) {
        console.error("Error exporting debate:", error);
        new import_obsidian3.Notice(`Error exporting debate: ${error.message}`);
      }
    });
  }
  getModeName(mode) {
    switch (mode) {
      case "debate":
        return "Debate (Pro vs Con)";
      case "sixHats":
        return "Six Thinking Hats";
      case "roundtable":
        return "Roundtable Discussion";
      default:
        return mode;
    }
  }
};

// src/models/ModelConfigModal.ts
var import_obsidian4 = require("obsidian");
var ModelConfigModal = class extends import_obsidian4.Modal {
  constructor(app, model, onSubmit) {
    super(app);
    this.isNewModel = !model;
    this.model = model || {
      id: `model_${Date.now()}`,
      name: "",
      type: "openai",
      apiKey: "",
      baseUrl: "",
      systemPrompt: "You are a helpful assistant.",
      active: true
    };
    this.onSubmit = onSubmit;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.createEl("h2", {
      text: this.isNewModel ? "Add AI Model" : "Edit AI Model"
    });
    new import_obsidian4.Setting(contentEl).setName("Model Name").setDesc("A friendly name to identify this model").addText(
      (text) => text.setPlaceholder("e.g., GPT-4, Ollama Local, Claude").setValue(this.model.name).onChange((value) => this.model.name = value)
    );
    new import_obsidian4.Setting(contentEl).setName("Provider").setDesc("Select the provider for this model").addDropdown(
      (dropdown) => dropdown.addOption("openai", "OpenAI").addOption("ollama", "Ollama").addOption("claude", "Anthropic Claude").addOption("zhipuai", "Zhipu AI").addOption("baidu", "Baidu").addOption("custom", "Custom API").setValue(this.model.type).onChange((value) => {
        this.model.type = value;
        this.model.baseUrl = "";
        this.model.modelName = "";
        this.contentEl.empty();
        this.onOpen();
      })
    );
    if (this.model.type !== "ollama") {
      new import_obsidian4.Setting(contentEl).setName("API Key").setDesc("Your API key for authenticating with the service").addText(
        (text) => text.setPlaceholder("sk-...").setValue(this.model.apiKey || "").onChange((value) => this.model.apiKey = value).inputEl.setAttribute("type", "password")
      );
    }
    new import_obsidian4.Setting(contentEl).setName("API Endpoint URL").setDesc(this.getUrlDescription()).addText(
      (text) => text.setPlaceholder(this.getUrlPlaceholder()).setValue(this.model.baseUrl || "").onChange((value) => this.model.baseUrl = value)
    );
    new import_obsidian4.Setting(contentEl).setName("Model Name").setDesc(this.getModelNameDescription()).addText(
      (text) => text.setPlaceholder(this.getModelNamePlaceholder()).setValue(this.model.modelName || "").onChange((value) => this.model.modelName = value)
    );
    new import_obsidian4.Setting(contentEl).setName("System Prompt").setDesc("Instructions that define how the AI responds").addTextArea(
      (text) => text.setPlaceholder("You are a helpful assistant...").setValue(this.model.systemPrompt || "").onChange((value) => this.model.systemPrompt = value)
    );
    new import_obsidian4.Setting(contentEl).setName("Use Proxy").setDesc("Override global proxy settings for this model").addToggle(
      (toggle) => toggle.setValue(this.model.useProxy || false).onChange((value) => this.model.useProxy = value)
    );
    if (["openai", "zhipuai", "custom"].includes(this.model.type)) {
      contentEl.createEl("h3", { text: "Embedding Settings" });
      new import_obsidian4.Setting(contentEl).setName("Embedding Model").setDesc("The model to use for generating embeddings").addText((text) => {
        const placeholder = this.model.type === "openai" ? "e.g., text-embedding-3-small" : this.model.type === "zhipuai" ? "e.g., embedding-3" : "Embedding model name";
        text.setPlaceholder(placeholder).setValue(this.model.embeddingModel || "").onChange((value) => this.model.embeddingModel = value);
      });
      if (this.model.type === "zhipuai" || this.model.type === "custom") {
        new import_obsidian4.Setting(contentEl).setName("Embedding Dimensions").setDesc("Number of dimensions for the embedding vectors (leave empty to use default)").addText(
          (text) => {
            var _a;
            return text.setPlaceholder("e.g., 1024").setValue(((_a = this.model.embeddingDimensions) == null ? void 0 : _a.toString()) || "").onChange((value) => {
              const dimensions = parseInt(value);
              this.model.embeddingDimensions = isNaN(dimensions) ? void 0 : dimensions;
            });
          }
        );
      }
    }
    new import_obsidian4.Setting(contentEl).setName("Active").setDesc("Enable or disable this model").addToggle(
      (toggle) => toggle.setValue(this.model.active).onChange((value) => this.model.active = value)
    );
    new import_obsidian4.Setting(contentEl).setName("Set as Default").setDesc("Use this model as the default when no specific model is selected").addToggle(
      (toggle) => toggle.setValue(this.model.isDefault || false).onChange((value) => this.model.isDefault = value)
    );
    new import_obsidian4.Setting(contentEl).addButton(
      (button) => button.setButtonText(this.isNewModel ? "Add Model" : "Save Changes").setCta().onClick(() => {
        if (this.validateModel()) {
          this.onSubmit(this.model);
          this.close();
        }
      })
    ).addButton(
      (button) => button.setButtonText("Cancel").onClick(() => this.close())
    );
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
  validateModel() {
    if (!this.model.name) {
      new import_obsidian4.Notice("Please provide a name for the model");
      return false;
    }
    if (this.model.type !== "ollama" && !this.model.apiKey) {
      new import_obsidian4.Notice("API key is required for this model type");
      return false;
    }
    if (this.model.type === "ollama" && !this.model.baseUrl) {
      this.model.baseUrl = "http://localhost:11434/api/generate";
    }
    return true;
  }
  getUrlDescription() {
    switch (this.model.type) {
      case "openai":
        return "OpenAI API endpoint (leave blank for default)";
      case "ollama":
        return "Local URL for Ollama server";
      case "claude":
        return "Anthropic API endpoint (leave blank for default)";
      case "custom":
        return "Full URL to your custom API endpoint";
      default:
        return "API endpoint URL";
    }
  }
  getUrlPlaceholder() {
    switch (this.model.type) {
      case "openai":
        return "https://api.openai.com/v1/chat/completions";
      case "ollama":
        return "http://localhost:11434/api/generate";
      case "claude":
        return "https://api.anthropic.com/v1/messages";
      case "zhipuai":
        return "https://open.bigmodel.cn/api/paas/v4/chat/completions";
      case "baidu":
        return "https://aip.baidubce.com/rpc/2.0/ai_custom/v1/wenxinworkshop/chat/";
      case "custom":
        return "https://your-custom-api-endpoint.com/generate";
      default:
        return "";
    }
  }
  getModelNameDescription() {
    switch (this.model.type) {
      case "openai":
        return "The specific OpenAI model to use (e.g., gpt-3.5-turbo, gpt-4)";
      case "ollama":
        return "The specific Ollama model to use (e.g., llama2, mistral)";
      case "claude":
        return "The specific Claude model to use (e.g., claude-3-opus-20240229)";
      case "zhipuai":
        return "The specific ZhipuAI model to use (e.g., glm-4)";
      case "baidu":
        return "The specific Baidu model to use";
      case "custom":
        return "The model identifier for your custom API";
      default:
        return "Model name as it appears to the provider";
    }
  }
  getModelNamePlaceholder() {
    switch (this.model.type) {
      case "openai":
        return "gpt-4-turbo";
      case "ollama":
        return "llama2";
      case "claude":
        return "claude-3-opus-20240229";
      case "zhipuai":
        return "glm-4";
      case "baidu":
        return "ERNIE-Bot-4";
      case "custom":
        return "model-name";
      default:
        return "";
    }
  }
};

// src/icons.ts
var import_obsidian5 = require("obsidian");
var addDebateIcon = () => {
  (0, import_obsidian5.addIcon)("brain-cog", `
    <svg xmlns="http://www.w3.org/2000/svg" width="100" height="100" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z"/>
      <path d="M17 4a2 2 0 0 0 2 2a2 2 0 0 0 -2 2a2 2 0 0 0 -2 -2a2 2 0 0 0 2 -2"/>
      <path d="M19 11h2m-1 -1v2"/>
      <path d="M15 16.5v.5a2 2 0 0 0 2 2"/>
      <path d="M8.5 14l-.386 -.51a1 1 0 0 0 -1.628 .476l-.748 2.238a1 1 0 0 0 .606 1.283l.279 .093a1 1 0 0 0 1.283 -.606l.558 -1.674a1 1 0 0 0 -.606 -1.283l-.121 -.04a1 1 0 0 0 -.221 -.025z"/>
      <path d="M14.5 17c0 .828 -.672 1.5 -1.5 1.5s-1.5 -.672 -1.5 -1.5s.672 -1.5 1.5 -1.5"/>
    </svg>
  `);
};
var addModelIcon = () => {
  (0, import_obsidian5.addIcon)("ai-model", `
    <svg xmlns="http://www.w3.org/2000/svg" width="100" height="100" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <path d="M12 2c1.109 0 2.01 .9 2.01 2s-.901 2 -2.01 2c-1.109 0 -2.01 -.9 -2.01 -2s.901 -2 2.01 -2z"/>
      <path d="M12 8c4.097 0 7.61 2.462 9 6h-18c1.39 -3.538 4.903 -6 9 -6z"/>
      <path d="M5.5 15l-1.5 6l3 -4l3 4l-1.5 -6"/>
      <path d="M14.5 15l-1.5 6l3 -4l3 4l-1.5 -6"/>
    </svg>
  `);
};
var addRoleIcons = () => {
  (0, import_obsidian5.addIcon)("debate-positive", `
    <svg xmlns="http://www.w3.org/2000/svg" width="100" height="100" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <path d="M12 12m-9 0a9 9 0 1 0 18 0a9 9 0 1 0 -18 0"/>
      <path d="M9 12l2 2l4 -4"/>
    </svg>
  `);
  (0, import_obsidian5.addIcon)("debate-negative", `
    <svg xmlns="http://www.w3.org/2000/svg" width="100" height="100" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <path d="M12 12m-9 0a9 9 0 1 0 18 0a9 9 0 1 0 -18 0"/>
      <path d="M9 12l6 0"/>
    </svg>
  `);
  (0, import_obsidian5.addIcon)("debate-host", `
    <svg xmlns="http://www.w3.org/2000/svg" width="100" height="100" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <path d="M8 9l2 3l-2 3"/>
      <path d="M14 9l-2 3l2 3"/>
      <path d="M12 12m-9 0a9 9 0 1 0 18 0a9 9 0 1 0 -18 0"/>
    </svg>
  `);
};
var addAllIcons = () => {
  addDebateIcon();
  addModelIcon();
  addRoleIcons();
};

// src/main.ts
var DEFAULT_SETTINGS = {
  apiKey: "",
  model: "gpt-4",
  provider: "openai",
  embeddingModel: "embedding-3",
  embeddingDimensions: 1024,
  knowledgeBasePath: "AI_KnowledgeBase",
  promptOrganize: 'Please organize the content of the following article logically, following an introduction-body-conclusion structure. Use Markdown format, ensuring a smooth flow between sections. Output in the same language as the input text:\n1. Use `#` and `##` for main and secondary headings, marking primary sections and sub-sections, respectively.\n2. If appropriate, divide content into list form or use block quotes (`>`) to present specific points.\n3. Avoid repetitive content, highlight key information, and ensure the article structure is clearer and easier to read.\n4. Summarize the core points of the article in the conclusion.\n5. Do not include any lines that start with "=".\nHere is the content that needs to be organized:',
  promptCheckGrammar: "Please check the grammar, typos, and punctuation in the following text. Never delete any content, and provide the corrected text in the same language. For any errors in the original text, please list them at the end of the corrected version:",
  promptGenerateContent: "Generate content based on the following prompt, maintaining the same language as the prompt: ",
  promptDialogue: "Engage in a Socratic dialogue based on the following text, using the same language as the input: ",
  chatModel: "glm-4-air",
  promptSummary: `Analyze and summarize the following documents in the same language as the source documents:

1. Concise Summary: Synthesize the main content and key information
2. Document Insights: List key insights and important information from each document
3. Document Connections: Analyze logical relationships and connections between documents
4. References: Use numbers [n] to cite sources, using Obsidian link syntax [[filename]]

Guidelines:
- Maintain professionalism and logical flow
- Highlight important information and key concepts
- Ensure accurate citations and correct link format
- Use clear hierarchical structure for content presentation
- Use proper Markdown formatting for better readability`,
  customFunctions: [],
  models: [],
  // Add default empty array for models
  debateConfigs: [],
  // Add default empty array for debate configs
  functions: [
    {
      name: "Organize",
      icon: "file-text",
      prompt: 'Please organize the content of the following article logically, following an introduction-body-conclusion structure. Use Markdown format, ensuring a smooth flow between sections. Output in the same language as the input text:\n1. Use `#` and `##` for main and secondary headings, marking primary sections and sub-sections, respectively.\n2. If appropriate, divide content into list form or use block quotes (`>`) to present specific points.\n3. Avoid repetitive content, highlight key information, and ensure the article structure is clearer and easier to read.\n4. Summarize the core points of the article in the conclusion.\n5. Do not include any lines that start with "=".\nHere is the content that needs to be organized:',
      tooltip: "Organize text structure",
      isBuiltIn: true
    },
    {
      name: "Grammar",
      icon: "check-square",
      prompt: "Please check the grammar, typos, and punctuation in the following text. Never delete any content, and provide the corrected text in the same language. For any errors in the original text, please list them at the end of the corrected version:",
      tooltip: "Check grammar and spelling",
      isBuiltIn: true
    },
    {
      name: "Generate",
      icon: "sparkles",
      prompt: "Generate content based on the following prompt, maintaining the same language as the prompt: ",
      tooltip: "Generate content",
      isBuiltIn: true
    },
    {
      name: "Dialogue",
      icon: "message-circle",
      prompt: "Engage in a Socratic dialogue based on the following text, using the same language as the input: ",
      tooltip: "Start a dialogue",
      isBuiltIn: true
    },
    {
      name: "Summarize",
      icon: "bookmark",
      prompt: `Analyze and summarize the following documents in the same language as the source documents:

1. Concise Summary: Synthesize the main content and key information
2. Document Insights: List key insights and important information from each document
3. Document Connections: Analyze logical relationships and connections between documents
4. References: Use numbers [n] to cite sources, using Obsidian link syntax [[filename]]

Guidelines:
- Maintain professionalism and logical flow
- Highlight important information and key concepts
- Ensure accurate citations and correct link format
- Use clear hierarchical structure for content presentation
- Use proper Markdown formatting for better readability`,
      tooltip: "Summarize content",
      isBuiltIn: true
    },
    {
      name: "Polish",
      icon: "bird",
      prompt: `Please polish and refine the following text to improve clarity, flow, and style while preserving the original meaning and language. Enhance the expression, eliminate redundancies, and make it more engaging. Return the polished version only, without explanations:`,
      tooltip: "Polish and refine text",
      isBuiltIn: true
    }
  ],
  chatHistoryPath: "AI_ChatHistory",
  editorModeEnabled: true,
  proxyConfig: {
    enabled: false,
    address: "",
    port: "",
    type: "http",
    requiresAuth: false
  }
};
function encryptString(text, salt) {
  try {
    const textToChars = (text2) => text2.split("").map((c) => c.charCodeAt(0));
    const byteHex = (n) => ("0" + Number(n).toString(16)).substr(-2);
    const applySaltToChar = (code) => textToChars(salt).reduce((a, b) => a ^ b, code);
    return text.split("").map((c) => c.charCodeAt(0)).map(applySaltToChar).map(byteHex).join("");
  } catch (e) {
    console.error("Encryption error:", e);
    return "";
  }
}
function decryptString(encoded, salt) {
  var _a;
  try {
    const textToChars = (text) => text.split("").map((c) => c.charCodeAt(0));
    const applySaltToChar = (code) => textToChars(salt).reduce((a, b) => a ^ b, code);
    return ((_a = encoded.match(/.{1,2}/g)) == null ? void 0 : _a.map((hex) => parseInt(hex, 16)).map(applySaltToChar).map((charCode) => String.fromCharCode(charCode)).join("")) || encoded;
  } catch (e) {
    console.error("Decryption failed:", e);
    return encoded;
  }
}
var AIPilotPlugin = class extends import_obsidian6.Plugin {
  constructor(app, manifest) {
    super(app, manifest);
    this.requestId = null;
    this.salt = "AIPilot-v1";
    this.lastApiCall = 0;
    this.MIN_API_INTERVAL = 100;
    // 100ms between calls
    this.embeddingCache = /* @__PURE__ */ new Map();
    this.CACHE_DURATION = 1e3 * 60 * 60;
    // 1 hour
    this.currentInput = null;
    this.diffMatchPatchLib = null;
    this.app = app;
  }
  onload() {
    return __async(this, null, function* () {
      yield this.loadSettings();
      this.migrateLegacyAPIKey();
      this.modelManager = new ModelManager(
        this,
        this.settings.models || [],
        // Ensure we have a default empty array if models is undefined
        this.settings.proxyConfig,
        () => __async(this, null, function* () {
          yield this.saveSettings();
        })
      );
      yield this.loadDiffMatchPatchLibrary();
      addAllIcons();
      this.registerView(
        DEBATE_VIEW_TYPE,
        (leaf) => new DebatePanel(leaf, this.modelManager)
      );
      this.addCommand({
        id: "open-debate-panel",
        name: "Open Agent Debate Panel",
        callback: () => this.activateDebateView()
      });
      this.addSettingTab(new AIPilotSettingTab(this.app, this));
      this.registerView(
        VIEW_TYPE_CHAT,
        (leaf) => new ChatView(leaf, this, this.modelManager)
      );
      this.addCommand({
        id: "open-chat-view",
        name: "Open AI Chat",
        callback: () => {
          this.activateView();
        }
      });
      this.addRibbonIcon("message-square", "Open AI Chat", () => {
        this.activateView();
      });
      this.addRibbonIcon("bird", "Polish Text", (evt) => {
        const mdView = this.app.workspace.getActiveViewOfType(import_obsidian6.MarkdownView);
        if (mdView) {
          this.polishText(mdView.editor);
        } else {
          new import_obsidian6.Notice("No active editor found.");
        }
      });
      this.addRibbonIcon("eraser", "Clean Polish Markup", (evt) => {
        const mdView = this.app.workspace.getActiveViewOfType(import_obsidian6.MarkdownView);
        if (mdView) {
          this.cleanPolishMarkup(mdView.editor);
        } else {
          new import_obsidian6.Notice("No active editor found.");
        }
      });
      this.addCommands();
      this.initializeRequestId();
      this.addRibbonIcon("search", "Search Knowledge Base", () => {
        this.searchKnowledgeBase();
      });
      const debateRibbonIcon = this.addRibbonIcon(
        "brain-cog",
        // Replace with your actual icon
        "AI Agent Debate",
        () => this.activateDebateView()
      );
    });
  }
  onunload() {
  }
  saveSettings() {
    return __async(this, null, function* () {
      const dataToSave = __spreadValues({}, this.settings);
      if (dataToSave.apiKey) {
        dataToSave.apiKey = encryptString(dataToSave.apiKey, this.salt);
      }
      if (dataToSave.models && dataToSave.models.length > 0) {
        dataToSave.models = dataToSave.models.map((model) => {
          const modelCopy = __spreadValues({}, model);
          if (modelCopy.apiKey) {
            modelCopy.apiKey = encryptString(modelCopy.apiKey, this.salt);
          }
          return modelCopy;
        });
      }
      yield this.saveData(dataToSave);
    });
  }
  loadSettings() {
    return __async(this, null, function* () {
      this.settings = Object.assign({}, DEFAULT_SETTINGS, yield this.loadData());
      if (!this.settings.models) this.settings.models = [];
      if (!this.settings.functions) this.settings.functions = [];
      if (!this.settings.customFunctions) this.settings.customFunctions = [];
      if (!this.settings.debateConfigs) this.settings.debateConfigs = [];
      if (!this.settings.proxyConfig) {
        this.settings.proxyConfig = {
          enabled: false,
          address: "",
          port: "",
          type: "http",
          requiresAuth: false
        };
      }
      if (this.settings.apiKey) {
        try {
          const decrypted = decryptString(this.settings.apiKey, this.salt);
          const isValidFormat = decrypted.startsWith("sk-") && /^[a-zA-Z0-9_-]+$/.test(decrypted) || // For other providers, just make sure it's alphanumeric
          /^[a-zA-Z0-9_-]+$/.test(decrypted);
          this.settings.apiKey = isValidFormat ? decrypted : "";
          if (!isValidFormat) {
            console.log("Invalid API key format detected, resetting key");
          }
        } catch (e) {
          console.error("Error decrypting API key, resetting it", e);
          this.settings.apiKey = "";
        }
      }
      if (this.settings.models && this.settings.models.length > 0) {
        this.settings.models = this.settings.models.map((model) => {
          const modelCopy = __spreadValues({}, model);
          if (modelCopy.apiKey) {
            try {
              const decrypted = decryptString(modelCopy.apiKey, this.salt);
              if (decrypted && /^[a-zA-Z0-9_\-\.]+$/.test(decrypted)) {
                modelCopy.apiKey = decrypted;
              } else {
                modelCopy.apiKey = "";
                console.log(`Invalid API key format detected for model ${model.name}, resetting key`);
              }
            } catch (e) {
              console.error(`Error decrypting API key for model ${model.name}, resetting it`, e);
              modelCopy.apiKey = "";
            }
          }
          return modelCopy;
        });
      }
      const hasDefaultModel = this.settings.models.some((m) => m.isDefault);
      if (!hasDefaultModel && this.settings.models.length > 0) {
        const firstActive = this.settings.models.find((m) => m.active);
        if (firstActive) {
          firstActive.isDefault = true;
        } else if (this.settings.models.length > 0) {
          this.settings.models[0].isDefault = true;
          this.settings.models[0].active = true;
        }
      }
    });
  }
  initializeRequestId() {
    if (!this.requestId) {
      this.requestId = crypto.randomUUID();
    }
  }
  showFeatureModal() {
    new FeatureSelectionModal(this.app, this).open();
  }
  addCommands() {
    this.addCommand({
      id: "organize-text",
      name: "Organize text",
      editorCallback: (editor, view) => this.organizeText(editor)
    });
    this.addCommand({
      id: "check-grammar",
      name: "Check grammar",
      editorCallback: (editor, view) => this.checkGrammar(editor)
    });
    this.addCommand({
      id: "generate-content",
      name: "Generate content",
      editorCallback: (editor) => __async(this, null, function* () {
        const content = editor.getValue();
        const result = yield this.generateAIContent(content);
        if (result) {
          editor.setValue(result);
        }
      })
    });
    this.addCommand({
      id: "engage-in-dialogue",
      name: "Engage in Dialogue",
      editorCallback: (editor, view) => this.engageInDialogue(editor)
    });
    this.addCommand({
      id: "polish-text",
      name: "Polish Text",
      editorCallback: (editor, view) => this.polishText(editor)
    });
    this.addCommand({
      id: "clean-polish-markup",
      name: "Clean Polish Markup",
      editorCallback: (editor, view) => this.cleanPolishMarkup(editor)
    });
    this.addCommand({
      id: "custom-prompt",
      name: "Custom Prompt",
      editorCallback: (editor, view) => this.handleCustomPrompt(editor)
    });
    this.addCommand({
      id: "search-knowledge-base",
      name: "Search Knowledge Base",
      callback: () => __async(this, null, function* () {
        const modal = new SearchPromptModal(this.app);
        const query = yield modal.openAndGetValue();
        if (!query) return;
        const loadingModal = new LoadingModal2(this.app, true);
        loadingModal.open();
        try {
          const files = yield this.getKnowledgeBaseNotes();
          const results = [];
          let processed = 0;
          for (const file of files) {
            const content = yield this.app.vault.read(file);
            const similarity = this.calculateSimilarity(query, content);
            results.push({ file, similarity });
            processed++;
            loadingModal.setProgress(processed / files.length, processed, files.length);
          }
          const topResults = results.sort((a, b) => b.similarity - a.similarity).slice(0, 5);
          loadingModal.close();
          new SearchResultsModal(this.app, topResults).open();
        } catch (error) {
          new import_obsidian6.Notice("Error searching knowledge base: " + error.message);
          loadingModal.close();
        }
      })
    });
  }
  // Approximate token estimation function
  estimateTokenCount(text) {
    return Math.ceil(text.length / 4);
  }
  callAI(content, promptPrefix = "") {
    return __async(this, null, function* () {
      const defaultModel = this.modelManager.getDefaultModel();
      if (!defaultModel) {
        new import_obsidian6.Notice("No active model found. Please configure a model in settings.");
        return "Error: No active model configured";
      }
      const maxTokens = 4096;
      let maxTokensForContent = maxTokens - this.estimateTokenCount(promptPrefix);
      const MIN_TOKENS_FOR_CONTENT = 500;
      if (maxTokensForContent < MIN_TOKENS_FOR_CONTENT) {
        maxTokensForContent = MIN_TOKENS_FOR_CONTENT;
      }
      const tokenCount = this.estimateTokenCount(content);
      if (tokenCount > maxTokensForContent) {
        const chunks = this.chunkContent(content, maxTokensForContent);
        const results = [];
        new import_obsidian6.Notice(`The text is too long and will be processed in ${chunks.length} parts.`);
        for (const chunk of chunks) {
          try {
            const prompt = `${promptPrefix}${chunk}

Note: This is part of a larger text. Ensure continuity with the previous sections.`;
            const result = yield this.modelManager.callModel(
              defaultModel.id,
              prompt,
              { maxTokens }
            );
            results.push(result.trim());
          } catch (error) {
            console.error("Error processing chunk:", error);
            new import_obsidian6.Notice(`Error processing chunk: ${error.message || "Unknown error"}`);
          }
        }
        return results.join("\n\n");
      } else {
        const prompt = `${promptPrefix}${content}`;
        try {
          return yield this.modelManager.callModel(
            defaultModel.id,
            prompt,
            { maxTokens }
          );
        } catch (error) {
          console.error("Error calling AI:", error);
          new import_obsidian6.Notice(`Error calling AI: ${error.message || "Unknown error"}`);
          return "Error fetching AI response";
        }
      }
    });
  }
  chunkContent(content, maxTokens) {
    const paragraphs = content.split(/\n\s*\n/);
    const chunks = [];
    let currentChunk = "";
    let currentTokens = 0;
    for (let i = 0; i < paragraphs.length; i++) {
      const paragraph2 = paragraphs[i];
      const paragraphTokens = this.estimateTokenCount(paragraph2);
      if (currentTokens + paragraphTokens > maxTokens) {
        if (currentChunk) {
          chunks.push(currentChunk.trim());
          currentChunk = "";
          currentTokens = 0;
        }
      }
      currentChunk += paragraph2 + "\n\n";
      currentTokens += paragraphTokens;
    }
    if (currentChunk) {
      chunks.push(currentChunk.trim());
    }
    return chunks;
  }
  callAIChat(messages, onUpdate) {
    return __async(this, null, function* () {
      const defaultModel = this.modelManager.getDefaultModel();
      if (!defaultModel) {
        new import_obsidian6.Notice("No active model found. Please configure a model in settings.");
        return "Error: No active model configured";
      }
      let totalTokens = 0;
      for (const msg of messages) {
        totalTokens += this.estimateTokenCount(msg.content);
      }
      const lastMessage = messages[messages.length - 1];
      let systemPrompt = defaultModel.systemPrompt || "You are a helpful assistant.";
      try {
        return yield this.modelManager.callModel(
          defaultModel.id,
          lastMessage.content,
          {
            maxTokens: 4096,
            // Safe default 
            conversation: messages,
            streaming: !!onUpdate,
            onChunk: onUpdate
          }
        );
      } catch (error) {
        console.error("Error calling AI chat:", error);
        new import_obsidian6.Notice(`Error calling AI chat: ${error.message || "Unknown error"}`);
        return "Error fetching AI response";
      }
    });
  }
  callAIChunk(content, promptPrefix) {
    return __async(this, null, function* () {
      const defaultModel = this.modelManager.getDefaultModel();
      if (!defaultModel) {
        new import_obsidian6.Notice("No active model found. Please configure a model in settings.");
        return "Error: No active model configured";
      }
      const prompt = `${promptPrefix}${content}

Note: This is part of a larger text. Ensure continuity with the previous sections.`;
      try {
        return yield this.modelManager.callModel(
          defaultModel.id,
          prompt,
          { maxTokens: 4096 }
          // Safe default
        );
      } catch (error) {
        console.error("Error calling AI:", error);
        new import_obsidian6.Notice(`Error calling AI: ${error.message || "Unknown error"}`);
        return "Error fetching AI response";
      }
    });
  }
  organizeText(editor) {
    return __async(this, null, function* () {
      if (!editor) {
        const mdView = this.app.workspace.getActiveViewOfType(import_obsidian6.MarkdownView);
        if (mdView) {
          editor = mdView.editor;
        } else {
          new import_obsidian6.Notice("No active editor found.");
          return;
        }
      }
      this.initializeRequestId();
      const selectedText = editor.getSelection();
      if (!selectedText) {
        new ConfirmModal2(this.app, "No text selected. Apply organization to the entire document?", () => __async(this, null, function* () {
          const content = editor.getValue();
          yield this.processOrganize(content, editor);
        })).open();
      } else {
        yield this.processOrganize(selectedText, editor);
      }
    });
  }
  processOrganize(content, editor) {
    return __async(this, null, function* () {
      const loadingModal = new LoadingModal2(this.app, true);
      loadingModal.open();
      const prompt = `${this.settings.promptOrganize}${content}

Note: This is part of a larger text. Ensure continuity with the previous sections.`;
      const organizedText = yield this.callAI(content, prompt);
      loadingModal.close();
      new AIContentModal(this.app, this, organizedText, editor, (updatedContent) => {
        if (editor.somethingSelected()) {
          editor.replaceSelection(updatedContent);
        } else {
          editor.setValue(updatedContent);
        }
      }).open();
    });
  }
  checkGrammar(editor) {
    return __async(this, null, function* () {
      if (!editor) {
        const mdView = this.app.workspace.getActiveViewOfType(import_obsidian6.MarkdownView);
        if (mdView) {
          editor = mdView.editor;
        } else {
          new import_obsidian6.Notice("No active editor found.");
          return;
        }
      }
      this.initializeRequestId();
      const selectedText = editor.getSelection();
      if (!selectedText) {
        new ConfirmModal2(this.app, "No text selected. Apply grammar check to the entire document?", () => __async(this, null, function* () {
          const content = editor.getValue();
          yield this.processGrammar(content, editor);
        })).open();
      } else {
        yield this.processGrammar(selectedText, editor);
      }
    });
  }
  processGrammar(content, editor) {
    return __async(this, null, function* () {
      const loadingModal = new LoadingModal2(this.app, true);
      loadingModal.open();
      const grammarCheckedText = yield this.callAI(content, this.settings.promptCheckGrammar);
      loadingModal.close();
      new AIContentModal(this.app, this, grammarCheckedText, editor, (updatedContent) => {
        if (editor.somethingSelected()) {
          editor.replaceSelection(updatedContent);
        } else {
          editor.setValue(updatedContent);
        }
      }).open();
    });
  }
  generateAIContent(prompt) {
    return __async(this, null, function* () {
      const activeView = this.app.workspace.getActiveViewOfType(import_obsidian6.MarkdownView);
      if (!activeView) {
        throw new Error("No active markdown file");
      }
      const editor = activeView.editor;
      let selectedText = editor.getSelection();
      if (!selectedText && !prompt) {
        throw new Error("No text selected and no prompt provided");
      }
      const textToProcess = prompt || selectedText;
      try {
        const response = yield this.getAIResponse(textToProcess);
        return response;
      } catch (error) {
        console.error("Error generating AI content:", error);
        throw error;
      }
    });
  }
  getAIResponse(message, history) {
    return __async(this, null, function* () {
      if (history) {
        return this.callAIChat([...history, { role: "user", content: message }]);
      }
      return this.callAI(message);
    });
  }
  engageInDialogue(editor) {
    return __async(this, null, function* () {
      if (!editor) {
        const mdView = this.app.workspace.getActiveViewOfType(import_obsidian6.MarkdownView);
        if (mdView) {
          editor = mdView.editor;
        } else {
          new import_obsidian6.Notice("No active editor found.");
          return;
        }
      }
      this.initializeRequestId();
      const selectedText = editor.getSelection();
      if (!selectedText) {
        new ConfirmModal2(this.app, "No text selected. Apply dialogue to the entire document?", () => __async(this, null, function* () {
          const content = editor.getValue();
          yield this.processDialogue(content, editor);
        })).open();
      } else {
        yield this.processDialogue(selectedText, editor);
      }
    });
  }
  processDialogue(content, editor) {
    return __async(this, null, function* () {
      const loadingModal = new LoadingModal2(this.app, true);
      loadingModal.open();
      const dialoguePrompt = `${this.settings.promptDialogue}${content}`;
      const aiResponse = yield this.callAI(dialoguePrompt);
      loadingModal.close();
      const history = [
        { role: "user", content },
        { role: "assistant", content: aiResponse }
      ];
      new ChatModal(this.app, this, history, editor).open();
    });
  }
  handleCustomPrompt(editor) {
    return __async(this, null, function* () {
      if (!editor) {
        const mdView = this.app.workspace.getActiveViewOfType(import_obsidian6.MarkdownView);
        if (mdView) {
          editor = mdView.editor;
        } else {
          new import_obsidian6.Notice("No active editor found.");
          return;
        }
      }
      this.initializeRequestId();
      const selectedText = editor.getSelection();
      let contentToProcess;
      new CustomPromptInputModal(this.app, (inputPrompt) => __async(this, null, function* () {
        if (!inputPrompt) {
          new import_obsidian6.Notice("No prompt entered.", 2e3);
          return;
        }
        if (selectedText) {
          contentToProcess = `${inputPrompt} ${selectedText}`;
        } else {
          new ConfirmModal2(this.app, "No text selected. Apply organization to the entire document?", () => __async(this, null, function* () {
            contentToProcess = editor.getValue();
          })).open();
        }
        yield this.processCustomPrompt(contentToProcess, editor);
      })).open();
    });
  }
  processCustomPrompt(content, editor) {
    return __async(this, null, function* () {
      const loadingModal = new LoadingModal2(this.app, true);
      loadingModal.open();
      const customResponse = yield this.callAI(content);
      loadingModal.close();
      new AIContentModal(this.app, this, customResponse, editor, (updatedContent) => {
        if (editor.somethingSelected()) {
          editor.replaceSelection(updatedContent);
        } else {
          editor.setValue(updatedContent);
        }
      }).open();
    });
  }
  // 获取知识库文件
  getKnowledgeBaseNotes(selectedDir) {
    return __async(this, null, function* () {
      const path = this.settings.knowledgeBasePath;
      let files = [];
      if (!path) {
        const getAllFiles = (folder) => {
          for (const child of folder.children) {
            if (child instanceof import_obsidian6.TFile && child.extension === "md") {
              files.push(child);
            } else if (child instanceof import_obsidian6.TFolder) {
              getAllFiles(child);
            }
          }
        };
        const rootFolder = this.app.vault.getRoot();
        getAllFiles(rootFolder);
      } else {
        const folder = this.app.vault.getAbstractFileByPath(path);
        if (!folder || !(folder instanceof import_obsidian6.TFolder)) {
          console.log("Knowledge base folder not found:", path);
          return [];
        }
        const searchFolder = (folder2) => {
          for (const child of folder2.children) {
            if (child instanceof import_obsidian6.TFile && child.extension === "md") {
              files.push(child);
            } else if (child instanceof import_obsidian6.TFolder) {
              searchFolder(child);
            }
          }
        };
        searchFolder(folder);
      }
      if (selectedDir) {
        files = files.filter((file) => file.path.startsWith(selectedDir));
      }
      return files;
    });
  }
  // 计算文本相似度
  calculateSimilarity(query, content) {
    const queryWords = new Set(query.split(/\s+/).filter((word) => word.length > 2));
    const contentWords = new Set(content.split(/\s+/).filter((word) => word.length > 2));
    let matches = 0;
    for (const word of queryWords) {
      if (contentWords.has(word)) matches++;
    }
    return matches / Math.max(queryWords.size, 1);
  }
  // Getting text embedding vector
  getEmbedding(text) {
    return __async(this, null, function* () {
      try {
        return yield this.modelManager.getEmbedding(text);
      } catch (error) {
        console.error("Error getting embedding:", error);
        console.log("Falling back to legacy embedding implementation");
        return this.getLegacyEmbedding(text);
      }
    });
  }
  // Legacy implementation for backward compatibility
  getLegacyEmbedding(text) {
    return __async(this, null, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _i;
      const { provider, apiKey, embeddingModel } = this.settings;
      try {
        if (provider === "zhipuai") {
          if (!(text == null ? void 0 : text.trim())) {
            throw new Error("Empty text cannot be embedded");
          }
          const MAX_CHARS = 3e3;
          if (text.length > MAX_CHARS) {
            const truncated = text.substring(0, MAX_CHARS);
            const lastPeriod = truncated.lastIndexOf(".");
            const lastNewline = truncated.lastIndexOf("\n");
            const breakPoint = Math.max(lastPeriod, lastNewline);
            text = breakPoint > 0 ? truncated.substring(0, breakPoint + 1) : truncated;
          }
          const requestBody = {
            model: embeddingModel,
            input: text,
            dimensions: embeddingModel === "embedding-3" ? 1024 : void 0
          };
          console.log("ZhipuAI Embedding Request:", {
            url: "https://open.bigmodel.cn/api/paas/v4/embeddings",
            model: embeddingModel,
            textLength: text.length,
            requestBody
          });
          const response = yield (0, import_obsidian6.requestUrl)({
            url: "https://open.bigmodel.cn/api/paas/v4/embeddings",
            method: "POST",
            headers: {
              "Authorization": `Bearer ${apiKey}`,
              "Content-Type": "application/json"
            },
            body: JSON.stringify(requestBody)
          });
          console.log("ZhipuAI Embedding Response:", {
            status: response.status,
            statusText: response.status,
            responseBody: response.json
          });
          if (response.status !== 200) {
            const errorMessage = ((_b = (_a = response.json) == null ? void 0 : _a.error) == null ? void 0 : _b.message) || response.text;
            throw new Error(`API returned status ${response.status}: ${errorMessage}`);
          }
          if (!((_e = (_d = (_c = response.json) == null ? void 0 : _c.data) == null ? void 0 : _d[0]) == null ? void 0 : _e.embedding)) {
            console.error("Invalid API response:", response.json);
            throw new Error("Invalid embedding response from ZhipuAI");
          }
          return response.json.data[0].embedding;
        } else if (provider === "openai") {
          const response = yield this.rateLimitedRequest(() => __async(this, null, function* () {
            return yield (0, import_obsidian6.requestUrl)({
              url: "https://api.openai.com/v1/embeddings",
              method: "POST",
              headers: {
                "Authorization": `Bearer ${apiKey}`,
                "Content-Type": "application/json"
              },
              body: JSON.stringify({
                model: embeddingModel,
                input: text
              })
            });
          }));
          if (!((_g = (_f = response.json.data) == null ? void 0 : _f[0]) == null ? void 0 : _g.embedding)) {
            throw new Error("Invalid embedding response from OpenAI");
          }
          return response.json.data[0].embedding;
        } else if (provider === "groq") {
          const response = yield this.rateLimitedRequest(() => __async(this, null, function* () {
            return yield (0, import_obsidian6.requestUrl)({
              url: "https://api.groq.com/openai/v1/embeddings",
              method: "POST",
              headers: {
                "Authorization": `Bearer ${apiKey}`,
                "Content-Type": "application/json"
              },
              body: JSON.stringify({
                model: embeddingModel,
                input: text
              })
            });
          }));
          if (!((_i = (_h = response.json.data) == null ? void 0 : _h[0]) == null ? void 0 : _i.embedding)) {
            throw new Error("Invalid embedding response from Groq");
          }
          return response.json.data[0].embedding;
        }
        throw new Error("Unsupported provider for embeddings");
      } catch (error) {
        console.error("Error getting legacy embedding:", error);
        throw error;
      }
    });
  }
  rateLimitedRequest(requestFn) {
    return __async(this, null, function* () {
      const now = Date.now();
      const timeSinceLastCall = now - this.lastApiCall;
      if (timeSinceLastCall < this.MIN_API_INTERVAL) {
        yield new Promise((resolve) => setTimeout(resolve, this.MIN_API_INTERVAL - timeSinceLastCall));
      }
      this.lastApiCall = Date.now();
      return requestFn();
    });
  }
  getCachedEmbedding(text) {
    return __async(this, null, function* () {
      const cached = this.embeddingCache.get(text);
      const now = Date.now();
      if (cached && now - cached.timestamp < this.CACHE_DURATION) {
        return cached.vector;
      }
      const vector = yield this.getEmbedding(text);
      this.embeddingCache.set(text, {
        vector,
        timestamp: now
      });
      return vector;
    });
  }
  activateView() {
    return __async(this, null, function* () {
      const workspace = this.app.workspace;
      let leaf = workspace.getLeavesOfType(VIEW_TYPE_CHAT)[0];
      if (!leaf) {
        const rightLeaf = workspace.getRightLeaf(false);
        if (!rightLeaf) return;
        leaf = rightLeaf;
        yield leaf.setViewState({
          type: VIEW_TYPE_CHAT,
          active: true
        });
      }
      workspace.revealLeaf(leaf);
    });
  }
  searchKnowledgeBase() {
    return __async(this, null, function* () {
      const modal = new SearchPromptModal(this.app);
      const query = yield modal.openAndGetValue();
      if (!query) return;
      const loadingModal = new LoadingModal2(this.app, true);
      loadingModal.open();
      try {
        const files = yield this.getKnowledgeBaseNotes();
        const results = [];
        let processed = 0;
        for (const file of files) {
          const content = yield this.app.vault.read(file);
          const similarity = this.calculateSimilarity(query, content);
          results.push({ file, similarity });
          processed++;
          loadingModal.setProgress(processed / files.length, processed, files.length);
        }
        const topResults = results.sort((a, b) => b.similarity - a.similarity).slice(0, 5);
        loadingModal.close();
        new SearchResultsModal(this.app, topResults).open();
      } catch (error) {
        new import_obsidian6.Notice("Error searching knowledge base: " + error.message);
        loadingModal.close();
      }
    });
  }
  handleSelection(editor) {
    return __async(this, null, function* () {
      const selectedText = editor.getSelection();
      if (!selectedText) return;
      const history = [
        { role: "user", content: selectedText },
        { role: "assistant", content: "I'll help you with that." }
      ];
      new ChatModal(this.app, this, history, editor).open();
    });
  }
  processFileReferences(message) {
    return __async(this, null, function* () {
      const matches = message.match(/@\[\[(.*?)\]\]/g);
      if (!matches) return message;
      let processedMessage = message;
      for (const match of matches) {
        const filePath = match.slice(3, -2);
        const file = this.app.vault.getAbstractFileByPath(filePath);
        if (file instanceof import_obsidian6.TFile) {
          try {
            const content = yield this.app.vault.read(file);
            processedMessage = processedMessage.replace(match, `

=== Content from ${filePath} ===
${content}
=== End of ${filePath} ===

`);
          } catch (error) {
            console.error(`Error reading file ${filePath}:`, error);
            new import_obsidian6.Notice(`Failed to read file ${filePath}`);
          }
        }
      }
      return processedMessage;
    });
  }
  getTopRelevantNotes(query, limit = 5) {
    return __async(this, null, function* () {
      const files = yield this.getKnowledgeBaseNotes();
      const results = [];
      for (const file of files) {
        try {
          const content = yield this.app.vault.read(file);
          const similarity = this.calculateSimilarity(query.toLowerCase(), content.toLowerCase());
          if (similarity > 0) {
            const snippet = this.getRelevantSnippet(content, query);
            results.push({ file, similarity, content: snippet });
          }
        } catch (error) {
          console.error(`Error processing file ${file.path}:`, error);
        }
      }
      return results.sort((a, b) => b.similarity - a.similarity).slice(0, limit);
    });
  }
  getRelevantSnippet(content, query, snippetLength = 300) {
    const lowerContent = content.toLowerCase();
    const lowerQuery = query.toLowerCase();
    const index = lowerContent.indexOf(lowerQuery);
    if (index === -1) {
      const queryWords = query.toLowerCase().split(/\s+/);
      for (const word of queryWords) {
        const wordIndex = lowerContent.indexOf(word);
        if (wordIndex !== -1) {
          return this.extractSnippet(content, wordIndex, snippetLength);
        }
      }
      return content.slice(0, snippetLength) + "...";
    }
    return this.extractSnippet(content, index, snippetLength);
  }
  extractSnippet(content, index, snippetLength) {
    const start = Math.max(0, index - snippetLength / 2);
    const end = Math.min(content.length, index + snippetLength / 2);
    let snippet = content.slice(start, end);
    if (start > 0) snippet = "..." + snippet;
    if (end < content.length) snippet = snippet + "...";
    return snippet;
  }
  renderMarkdown(content, container) {
    return __async(this, null, function* () {
      yield import_obsidian6.MarkdownRenderer.renderMarkdown(content, container, "", this);
    });
  }
  polishText(editor) {
    return __async(this, null, function* () {
      if (!editor) {
        const mdView = this.app.workspace.getActiveViewOfType(import_obsidian6.MarkdownView);
        if (mdView) {
          editor = mdView.editor;
        } else {
          new import_obsidian6.Notice("No active editor found.");
          return;
        }
      }
      this.initializeRequestId();
      const selectedText = editor.getSelection();
      if (!selectedText) {
        new ConfirmModal2(this.app, "No text selected. Apply polishing to the entire document?", () => __async(this, null, function* () {
          const content = editor.getValue();
          yield this.processPolish(content, editor);
        })).open();
      } else {
        yield this.processPolish(selectedText, editor);
      }
    });
  }
  processPolish(content, editor) {
    return __async(this, null, function* () {
      const loadingModal = new LoadingModal2(this.app, true);
      loadingModal.open();
      const polishFunc = this.settings.functions.find((f) => f.isBuiltIn && f.name === "Polish");
      const polishPrompt = polishFunc ? polishFunc.prompt : "Please polish and refine the following text:";
      const polishedText = yield this.callAI(content, polishPrompt);
      loadingModal.close();
      if (!editor.somethingSelected()) {
        const diffResult = this.generateDiffHtml(content, polishedText);
        editor.setValue(diffResult);
        new import_obsidian6.Notice("Polish results applied with diff markers. Use Ctrl+Shift+P (or Cmd+Shift+P) to remove all markup.", 7e3);
      } else {
        new PolishResultModal(
          this.app,
          content,
          polishedText,
          (updatedContent) => {
            editor.replaceSelection(updatedContent);
          },
          this
        ).open();
      }
    });
  }
  // Method to generate diff DOM elements with highlighting
  generateDiffElements(original, modified) {
    try {
      if (this.diffMatchPatchLib) {
        return this.generateWordLevelDiffElements(original, modified);
      }
    } catch (e) {
      console.error("Error using diff-match-patch library:", e);
    }
    return this.generateParagraphLevelDiffElements(original, modified);
  }
  // Advanced word-level diff implementation that returns DOM elements
  generateWordLevelDiffElements(original, modified) {
    try {
      const dmp = new this.diffMatchPatchLib();
      const diffs = dmp.diff_main(original, modified);
      dmp.diff_cleanupSemantic(diffs);
      const fragment = document.createDocumentFragment();
      for (const [operation, text] of diffs) {
        const escText = this.escapeHtml(text);
        if (operation === -1) {
          const deletedSpan = document.createElement("span");
          deletedSpan.className = "polish-deleted";
          deletedSpan.textContent = text;
          fragment.appendChild(deletedSpan);
        } else if (operation === 1) {
          const addedSpan = document.createElement("span");
          addedSpan.className = "polish-highlight";
          addedSpan.textContent = text;
          fragment.appendChild(addedSpan);
        } else {
          fragment.appendChild(document.createTextNode(text));
        }
      }
      return fragment;
    } catch (e) {
      console.error("Error in word-level diff:", e);
      return this.generateParagraphLevelDiffElements(original, modified);
    }
  }
  // Basic paragraph-level diff that returns DOM elements
  generateParagraphLevelDiffElements(original, modified) {
    const originalParagraphs = original.split("\n");
    const modifiedParagraphs = modified.split("\n");
    const fragment = document.createDocumentFragment();
    if (Math.abs(originalParagraphs.length - modifiedParagraphs.length) > originalParagraphs.length * 0.5) {
      fragment.appendChild(document.createTextNode(modified));
      return fragment;
    }
    const maxLength = Math.max(originalParagraphs.length, modifiedParagraphs.length);
    for (let i = 0; i < maxLength; i++) {
      const origPara = i < originalParagraphs.length ? originalParagraphs[i] : "";
      const modPara = i < modifiedParagraphs.length ? modifiedParagraphs[i] : "";
      if (origPara === modPara) {
        fragment.appendChild(document.createTextNode(modPara));
      } else if (origPara && !modPara) {
        const deletedSpan = document.createElement("span");
        deletedSpan.className = "polish-deleted";
        deletedSpan.textContent = origPara;
        fragment.appendChild(deletedSpan);
      } else if (!origPara && modPara) {
        const addedSpan = document.createElement("span");
        addedSpan.className = "polish-highlight";
        addedSpan.textContent = modPara;
        fragment.appendChild(addedSpan);
      } else {
        const deletedSpan = document.createElement("span");
        deletedSpan.className = "polish-deleted";
        deletedSpan.textContent = origPara;
        fragment.appendChild(deletedSpan);
        fragment.appendChild(document.createElement("br"));
        const addedSpan = document.createElement("span");
        addedSpan.className = "polish-highlight";
        addedSpan.textContent = modPara;
        fragment.appendChild(addedSpan);
      }
      if (i < maxLength - 1) {
        fragment.appendChild(document.createElement("br"));
      }
    }
    return fragment;
  }
  // Keep the existing methods for backward compatibility but update them to use the new methods
  generateDiffHtml(original, modified) {
    return this.generateDiffElements(original, modified);
  }
  generateWordLevelDiff(original, modified) {
    return this.generateWordLevelDiffElements(original, modified);
  }
  generateParagraphLevelDiff(original, modified) {
    return this.generateParagraphLevelDiffElements(original, modified);
  }
  // Add this new method to clean Polish markup
  cleanPolishMarkup(editor) {
    return __async(this, null, function* () {
      if (!editor) return;
      const content = editor.getValue();
      let cleanedContent = content.replace(/~~([^~]*?)~~(\n)?/g, "");
      cleanedContent = cleanedContent.replace(/\*\*([^*]*?)\*\*/g, "$1");
      cleanedContent = cleanedContent.replace(/\n\n+/g, "\n\n");
      editor.setValue(cleanedContent);
      new import_obsidian6.Notice("Polish markup removed");
    });
  }
  activateDebateView() {
    return __async(this, null, function* () {
      const { workspace } = this.app;
      let leaf = workspace.getLeavesOfType(DEBATE_VIEW_TYPE)[0];
      if (!leaf) {
        const rightLeaf = workspace.getRightLeaf(false);
        if (!rightLeaf) {
          new import_obsidian6.Notice("Could not create debate view");
          return;
        }
        leaf = rightLeaf;
        yield leaf.setViewState({ type: DEBATE_VIEW_TYPE });
      }
      workspace.revealLeaf(leaf);
    });
  }
  migrateLegacyAPIKey() {
    if (this.settings.apiKey && (!this.settings.models || this.settings.models.length === 0)) {
      console.log("Migrating legacy API key to models system");
      const newModel = {
        id: `model_${Date.now()}`,
        name: `${this.settings.provider || "openai"} (Migrated)`,
        type: this.settings.provider || "openai",
        apiKey: this.settings.apiKey,
        systemPrompt: "You are a helpful assistant.",
        active: true,
        isDefault: true,
        modelName: this.settings.model || this.settings.chatModel || this.getDefaultModelName(this.settings.provider)
      };
      if (!this.settings.models) {
        this.settings.models = [];
      }
      this.settings.models.push(newModel);
      this.settings.apiKey = "";
      this.saveSettings().catch((e) => {
        console.error("Failed to save settings after API key migration", e);
      });
    }
  }
  getDefaultModelName(provider) {
    switch (provider) {
      case "openai":
        return "gpt-3.5-turbo";
      case "zhipuai":
        return "glm-4";
      case "groq":
        return "llama2-70b-4096";
      default:
        return "gpt-3.5-turbo";
    }
  }
  loadDiffMatchPatchLibrary() {
    return __async(this, null, function* () {
      try {
        const diffMatchPatchScript = document.createElement("script");
        diffMatchPatchScript.src = "https://cdnjs.cloudflare.com/ajax/libs/diff-match-patch/1.0.0/diff-match-patch.min.js";
        diffMatchPatchScript.onload = () => {
          this.diffMatchPatchLib = window.diff_match_patch;
        };
        document.head.appendChild(diffMatchPatchScript);
      } catch (error) {
        console.error("Failed to load diff-match-patch library:", error);
      }
    });
  }
  // Add the escapeHtml method to the main plugin class
  escapeHtml(text) {
    return text.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;");
  }
};
var PolishResultModal = class extends import_obsidian6.Modal {
  constructor(app, originalContent, polishedContent, onApply, plugin) {
    super(app);
    this.originalContent = originalContent;
    this.polishedContent = polishedContent;
    this.onApply = onApply;
    this.plugin = plugin;
  }
  // Method to generate diff DOM elements with highlighting
  generateDiffElements(original, modified) {
    try {
      if (this.plugin.diffMatchPatchLib) {
        return this.generateWordLevelDiffElements(original, modified);
      }
    } catch (e) {
      console.error("Error using diff-match-patch library:", e);
    }
    return this.generateParagraphLevelDiffElements(original, modified);
  }
  // Advanced word-level diff implementation that returns DOM elements
  generateWordLevelDiffElements(original, modified) {
    try {
      const dmp = new this.plugin.diffMatchPatchLib();
      const diffs = dmp.diff_main(original, modified);
      dmp.diff_cleanupSemantic(diffs);
      const fragment = document.createDocumentFragment();
      for (const [operation, text] of diffs) {
        const escText = this.plugin.escapeHtml(text);
        if (operation === -1) {
          const deletedSpan = document.createElement("span");
          deletedSpan.className = "polish-deleted";
          deletedSpan.textContent = text;
          fragment.appendChild(deletedSpan);
        } else if (operation === 1) {
          const addedSpan = document.createElement("span");
          addedSpan.className = "polish-highlight";
          addedSpan.textContent = text;
          fragment.appendChild(addedSpan);
        } else {
          fragment.appendChild(document.createTextNode(text));
        }
      }
      return fragment;
    } catch (e) {
      console.error("Error in word-level diff:", e);
      return this.generateParagraphLevelDiffElements(original, modified);
    }
  }
  // Basic paragraph-level diff that returns DOM elements
  generateParagraphLevelDiffElements(original, modified) {
    const originalParagraphs = original.split("\n");
    const modifiedParagraphs = modified.split("\n");
    const fragment = document.createDocumentFragment();
    if (Math.abs(originalParagraphs.length - modifiedParagraphs.length) > originalParagraphs.length * 0.5) {
      fragment.appendChild(document.createTextNode(modified));
      return fragment;
    }
    const maxLength = Math.max(originalParagraphs.length, modifiedParagraphs.length);
    for (let i = 0; i < maxLength; i++) {
      const origPara = i < originalParagraphs.length ? originalParagraphs[i] : "";
      const modPara = i < modifiedParagraphs.length ? modifiedParagraphs[i] : "";
      if (origPara === modPara) {
        fragment.appendChild(document.createTextNode(modPara));
      } else if (origPara && !modPara) {
        const deletedSpan = document.createElement("span");
        deletedSpan.className = "polish-deleted";
        deletedSpan.textContent = origPara;
        fragment.appendChild(deletedSpan);
      } else if (!origPara && modPara) {
        const addedSpan = document.createElement("span");
        addedSpan.className = "polish-highlight";
        addedSpan.textContent = modPara;
        fragment.appendChild(addedSpan);
      } else {
        const deletedSpan = document.createElement("span");
        deletedSpan.className = "polish-deleted";
        deletedSpan.textContent = origPara;
        fragment.appendChild(deletedSpan);
        fragment.appendChild(document.createElement("br"));
        const addedSpan = document.createElement("span");
        addedSpan.className = "polish-highlight";
        addedSpan.textContent = modPara;
        fragment.appendChild(addedSpan);
      }
      if (i < maxLength - 1) {
        fragment.appendChild(document.createElement("br"));
      }
    }
    return fragment;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.addClass("polish-result-modal");
    contentEl.createEl("h2", { text: "Polished Result", cls: "polish-header" });
    contentEl.createEl("p", {
      text: "The AI has polished your content. You can apply these changes or dismiss them.",
      cls: "polish-description"
    });
    const legendContainer = contentEl.createDiv({ cls: "polish-legend" });
    legendContainer.createEl("h3", { text: "Changes Legend:" });
    const legendItems = legendContainer.createDiv({ cls: "polish-legend-items" });
    const deletedItem = legendItems.createDiv({ cls: "polish-legend-item" });
    const deletedSample = deletedItem.createSpan({ cls: "polish-sample polish-deleted", text: "Deleted text" });
    deletedItem.createSpan({ text: " - Content that has been removed" });
    const addedItem = legendItems.createDiv({ cls: "polish-legend-item" });
    const addedSample = addedItem.createSpan({ cls: "polish-sample polish-highlight", text: "Added text" });
    addedItem.createSpan({ text: " - New or modified content" });
    const diffHtml = this.generateDiffHtml(this.originalContent, this.polishedContent);
    const contentContainer = contentEl.createDiv({ cls: "polish-result-container diff-rendered" });
    this.renderDiffContent(contentContainer, diffHtml);
    const buttonContainer = contentEl.createDiv({ cls: "polish-button-container" });
    const cancelButton = buttonContainer.createEl("button", { text: "Cancel" });
    cancelButton.addEventListener("click", () => {
      this.close();
    });
    const applyButton = buttonContainer.createEl("button", {
      text: "Apply Changes",
      cls: "mod-cta"
    });
    applyButton.addEventListener("click", () => {
      const cleanContent = this.cleanDiffMarkers(this.polishedContent);
      this.onApply(cleanContent);
      this.close();
    });
  }
  // Method to clean diff markers from content
  cleanDiffMarkers(content) {
    return content.replace(/<span class="polish-deleted">.*?<\/span>/g, "").replace(/<span class="polish-highlight">(.*?)<\/span>/g, "$1").replace(/\n\n+/g, "\n\n");
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
  // Add a new method to render diff content safely
  renderDiffContent(container, htmlContent) {
    const tempDiv = document.createElement("div");
    tempDiv.appendChild(htmlContent);
    const fragment = document.createDocumentFragment();
    Array.from(tempDiv.childNodes).forEach((node) => {
      if (node.nodeType === Node.TEXT_NODE) {
        fragment.appendChild(document.createTextNode(node.textContent || ""));
      } else if (node.nodeType === Node.ELEMENT_NODE) {
        const elem = node;
        if (elem.tagName === "SPAN") {
          const span = document.createElement("span");
          span.className = elem.className;
          span.textContent = elem.textContent || "";
          fragment.appendChild(span);
        } else if (elem.tagName === "BR") {
          fragment.appendChild(document.createElement("br"));
        }
      }
    });
    container.appendChild(fragment);
  }
  // Add escapeHtml to the PolishResultModal class
  escapeHtml(text) {
    return text.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;");
  }
  // Add the generateDiffHtml method to PolishResultModal
  generateDiffHtml(original, modified) {
    return this.generateDiffElements(original, modified);
  }
};
var CustomPromptInputModal = class extends import_obsidian6.Modal {
  constructor(app, onSubmit) {
    super(app);
    this.onSubmit = onSubmit;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("modal-content");
    contentEl.createEl("h2", { text: "Enter Your Custom Prompt" });
    const promptInput = contentEl.createEl("textarea", {
      placeholder: "Type your custom prompt here...",
      cls: "custom-prompt-input"
    });
    const buttonContainer = contentEl.createDiv({ cls: "button-container" });
    const submitBtn = buttonContainer.createEl("button", { text: "Submit" });
    const cancelBtn = buttonContainer.createEl("button", { text: "Cancel" });
    submitBtn.onclick = () => {
      const inputValue = promptInput.value.trim();
      if (inputValue) {
        this.onSubmit(inputValue);
        this.close();
      } else {
        new import_obsidian6.Notice("Please enter a prompt.");
      }
    };
    cancelBtn.onclick = () => {
      this.close();
    };
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var FeatureSelectionModal = class extends import_obsidian6.Modal {
  constructor(app, plugin) {
    super(app);
    this.plugin = plugin;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", { text: "Select AI Function" });
    const buttonContainer = contentEl.createDiv({ cls: "button-container" });
    const buttons = [
      { text: "Organize Text", action: () => this.plugin.organizeText() },
      { text: "Check Grammar", action: () => this.plugin.checkGrammar() },
      { text: "Generate Content", action: () => this.plugin.generateAIContent() },
      { text: "Engage in Dialogue", action: () => this.plugin.engageInDialogue() },
      { text: "Search Knowledge Base", action: () => __async(this, null, function* () {
        return yield this.plugin.searchKnowledgeBase();
      }) },
      { text: "Custom Prompt", action: () => this.plugin.handleCustomPrompt() }
    ];
    buttons.forEach(({ text, action }) => {
      const btn = buttonContainer.createEl("button", {
        text,
        cls: "feature-button"
      });
      btn.onclick = () => __async(this, null, function* () {
        this.close();
        yield action();
      });
    });
  }
  onClose() {
    this.contentEl.empty();
  }
};
var LoadingModal2 = class extends import_obsidian6.Modal {
  constructor(app, isProgress = false) {
    super(app);
    this.isProgress = isProgress;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    if (this.isProgress) {
      contentEl.addClass("loading-modal");
      contentEl.createEl("h2", { text: "Searching..." });
      this.statusEl = contentEl.createEl("p", { text: "Initializing..." });
      this.countEl = contentEl.createEl("p", { cls: "count-text" });
      this.progressEl = contentEl.createEl("p", { cls: "progress-text" });
    } else {
      contentEl.createEl("h2", { text: "Processing..." });
      contentEl.createEl("div", { text: "Please wait while the AI processes your text.", cls: "loading-text" });
      this.spinnerEl = contentEl.createDiv({ cls: "spinner" });
      for (let i = 0; i < 3; i++) {
        this.spinnerEl.createDiv({ cls: "bounce" + (i + 1) });
      }
    }
  }
  setProgress(progress, current, total) {
    if (!this.isProgress) return;
    const percentage = Math.round(progress * 100);
    this.progressEl.setText(`Progress: ${percentage}%`);
    this.countEl.setText(`Processing file ${current} of ${total}`);
  }
  setStatus(status) {
    if (!this.isProgress) return;
    this.statusEl.setText(status);
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var AIContentModal = class extends import_obsidian6.Modal {
  constructor(app, plugin, content, editor, onApply) {
    super(app);
    this.undoStack = [];
    this.plugin = plugin;
    this.content = content;
    this.editor = editor;
    this.onApply = onApply;
  }
  onOpen() {
    return __async(this, null, function* () {
      const { contentEl } = this;
      contentEl.empty();
      contentEl.createEl("h2", { text: "AI Generated Content" });
      const messageContainer = contentEl.createDiv({ cls: "message-container" });
      const msgDiv = messageContainer.createDiv({ cls: "ai-message" });
      const sanitizedContent = this.sanitizeContent(this.content);
      yield MarkdownRenderer.renderMarkdown(sanitizedContent, msgDiv, "", this.plugin);
      const actionContainer = msgDiv.createDiv({ cls: "message-actions hover-only" });
      const copyBtn = actionContainer.createEl("button", {
        cls: "message-action-button copy-button",
        attr: { "aria-label": "Copy content" }
      });
      (0, import_obsidian6.setIcon)(copyBtn, "copy");
      copyBtn.onclick = () => __async(this, null, function* () {
        try {
          yield navigator.clipboard.writeText(this.content);
          new import_obsidian6.Notice("Content copied to clipboard!", 2e3);
        } catch (err) {
          console.error("Failed to copy content:", err);
          new import_obsidian6.Notice("Failed to copy content");
        }
      });
      const insertBtn = actionContainer.createEl("button", {
        cls: "message-action-button insert-button",
        attr: { "aria-label": "Insert content" }
      });
      (0, import_obsidian6.setIcon)(insertBtn, "plus");
      insertBtn.onclick = () => {
        if (this.editor) {
          const startPos = this.editor.getCursor();
          const insertedContent = this.content;
          this.editor.replaceRange(insertedContent, startPos);
          const endOffset = this.editor.posToOffset(startPos) + insertedContent.length;
          const endPos = this.editor.offsetToPos(endOffset);
          this.undoStack.push({ from: startPos, to: endPos, text: "" });
          new import_obsidian6.Notice("Content inserted at cursor position!", 2e3);
        } else {
          new import_obsidian6.Notice("No active editor found.", 2e3);
        }
      };
    });
  }
  onClose() {
    this.contentEl.empty();
  }
  // Add this new method to sanitize content
  sanitizeContent(content) {
    return content.split("\n").map((line) => {
      if (line.trimStart().startsWith("=")) {
        return "\\" + line;
      }
      return line;
    }).join("\n");
  }
};
var ChatModal = class extends import_obsidian6.Modal {
  constructor(app, plugin, initialHistory = [], editor = null) {
    super(app);
    this.messageContainer = null;
    this.currentInput = null;
    this.history = [];
    this.plugin = plugin;
    this.history = initialHistory;
    this.editor = editor;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    const chatContainer = contentEl.createDiv({ cls: "chat-container" });
    const messageContainer = chatContainer.createDiv({ cls: "message-container" });
    this.messageContainer = messageContainer;
    this.renderChatHistory(messageContainer);
    const inputContainer = chatContainer.createDiv({ cls: "input-container" });
    const textarea = inputContainer.createEl("textarea", {
      cls: "chat-input",
      attr: { placeholder: "Type your message..." }
    });
    this.currentInput = textarea;
    const sendButton = inputContainer.createEl("button", { cls: "send-button" });
    (0, import_obsidian6.setIcon)(sendButton, "paper-plane");
    sendButton.onclick = () => this.handleSend();
  }
  handleSend() {
    return __async(this, null, function* () {
      var _a;
      if (!this.currentInput || !this.currentInput.value.trim()) return;
      const userMessage = this.currentInput.value.trim();
      this.currentInput.value = "";
      this.history.push({ role: "user", content: userMessage });
      yield this.renderMessage(userMessage, "user");
      try {
        const messageEl = (_a = this.messageContainer) == null ? void 0 : _a.createDiv({ cls: "message assistant-message" });
        const contentDiv = messageEl == null ? void 0 : messageEl.createDiv({ cls: "message-content" });
        const textDiv = contentDiv == null ? void 0 : contentDiv.createDiv({ cls: "message-text" });
        if (!messageEl || !contentDiv || !textDiv) {
          throw new Error("Failed to create message elements");
        }
        let streamedContent = "";
        const response = yield this.plugin.callAIChat(this.history, (chunk) => __async(this, null, function* () {
          streamedContent += chunk;
          yield MarkdownRenderer.renderMarkdown(streamedContent, textDiv, "", this.plugin);
          if (this.messageContainer && this.messageContainer.scrollHeight) {
            this.messageContainer.scrollTo({
              top: this.messageContainer.scrollHeight,
              behavior: "smooth"
            });
          }
        }));
        const actionContainer = messageEl.createDiv({ cls: "message-actions hover-only" });
        const copyButton = actionContainer.createEl("button", {
          cls: "message-action-button copy-button",
          attr: { "aria-label": "Copy message" }
        });
        (0, import_obsidian6.setIcon)(copyButton, "copy");
        copyButton.onclick = () => __async(this, null, function* () {
          try {
            yield navigator.clipboard.writeText(response);
            new import_obsidian6.Notice("Copied to clipboard", 2e3);
          } catch (err) {
            console.error("Failed to copy content:", err);
            new import_obsidian6.Notice("Failed to copy content", 2e3);
          }
        });
        const insertButton = actionContainer.createEl("button", {
          cls: "message-action-button insert-button",
          attr: { "aria-label": "Insert into editor" }
        });
        (0, import_obsidian6.setIcon)(insertButton, "plus");
        insertButton.onclick = () => {
          const activeLeaf = this.app.workspace.activeLeaf;
          if (!activeLeaf) {
            new import_obsidian6.Notice("Please open a markdown file first", 2e3);
            return;
          }
          const view = activeLeaf.view;
          if (!(view instanceof import_obsidian6.MarkdownView)) {
            new import_obsidian6.Notice("Please open a markdown file first", 2e3);
            return;
          }
          const editor = view.editor;
          const cursor = editor.getCursor();
          editor.replaceRange(response + "\n", cursor);
          editor.focus();
          new import_obsidian6.Notice("Content inserted into editor", 2e3);
        };
        this.history.push({ role: "assistant", content: response });
      } catch (error) {
        console.error("Error in chat:", error);
        new import_obsidian6.Notice("Error getting AI response: " + error.message, 2e3);
      }
    });
  }
  renderMessage(content, role) {
    return __async(this, null, function* () {
      if (!this.messageContainer) return;
      const messageEl = this.messageContainer.createDiv({ cls: `message ${role}-message` });
      const contentDiv = messageEl.createDiv({ cls: "message-content" });
      if (role === "assistant") {
        yield MarkdownRenderer.renderMarkdown(content, contentDiv, "", this.plugin);
        const actionContainer = messageEl.createDiv({ cls: "message-actions hover-only" });
        const copyButton = actionContainer.createEl("button", { cls: "message-action-button copy-button" });
        (0, import_obsidian6.setIcon)(copyButton, "copy");
        copyButton.setAttribute("aria-label", "Copy message");
        copyButton.onclick = () => __async(this, null, function* () {
          try {
            yield navigator.clipboard.writeText(content);
            new import_obsidian6.Notice("Copied to clipboard", 2e3);
          } catch (err) {
            console.error("Failed to copy content:", err);
            new import_obsidian6.Notice("Failed to copy content", 2e3);
          }
        });
        const insertButton = actionContainer.createEl("button", { cls: "message-action-button insert-button" });
        (0, import_obsidian6.setIcon)(insertButton, "plus");
        insertButton.setAttribute("aria-label", "Insert into editor");
        insertButton.onclick = () => {
          const activeLeaf = this.app.workspace.activeLeaf;
          if (!activeLeaf) {
            new import_obsidian6.Notice("Please open a markdown file first", 2e3);
            return;
          }
          const view = activeLeaf.view;
          if (!(view instanceof import_obsidian6.MarkdownView)) {
            new import_obsidian6.Notice("Please open a markdown file first", 2e3);
            return;
          }
          const editor = view.editor;
          const cursor = editor.getCursor();
          editor.replaceRange(content + "\n", cursor);
          editor.focus();
          new import_obsidian6.Notice("Content inserted into editor", 2e3);
        };
      } else {
        contentDiv.setText(content);
      }
      const container = this.messageContainer;
      if (container && container.scrollHeight) {
        container.scrollTo({
          top: container.scrollHeight,
          behavior: "smooth"
        });
      }
    });
  }
  renderChatHistory(container) {
    return __async(this, null, function* () {
      container.empty();
      this.messageContainer = container;
      for (const msg of this.history) {
        yield this.renderMessage(msg.content, msg.role);
      }
    });
  }
};
var SearchPromptModal = class extends import_obsidian6.Modal {
  constructor(app) {
    super(app);
    this.result = null;
    this.resolvePromise = () => {
    };
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("search-prompt-modal");
    contentEl.createEl("h2", { text: "Search Knowledge Base" });
    const inputEl = contentEl.createEl("input", {
      type: "text",
      placeholder: "Enter your search query...",
      cls: "search-prompt-input"
    });
    const buttonContainer = contentEl.createDiv({ cls: "search-prompt-buttons" });
    const searchBtn = buttonContainer.createEl("button", {
      text: "Search",
      cls: "search-button"
    });
    const cancelBtn = buttonContainer.createEl("button", {
      text: "Cancel",
      cls: "cancel-button"
    });
    inputEl.focus();
    searchBtn.onclick = () => {
      this.result = inputEl.value;
      this.close();
    };
    cancelBtn.onclick = () => {
      this.result = null;
      this.close();
    };
    inputEl.onkeydown = (e) => {
      if (e.key === "Enter") {
        this.result = inputEl.value;
        this.close();
      }
    };
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
    if (this.resolvePromise) {
      this.resolvePromise(this.result);
    }
  }
  openAndGetValue() {
    return __async(this, null, function* () {
      this.open();
      return new Promise((resolve) => {
        this.resolvePromise = resolve;
      });
    });
  }
};
var ConfirmModal2 = class extends import_obsidian6.Modal {
  constructor(app, message, onConfirm) {
    super(app);
    this.message = message;
    this.onConfirm = onConfirm;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("confirm-modal");
    contentEl.createEl("p", { text: this.message, cls: "confirm-message" });
    const buttonContainer = contentEl.createDiv({ cls: "confirm-button-container" });
    const confirmBtn = buttonContainer.createEl("button", { text: "Confirm", cls: "confirm-button" });
    const cancelBtn = buttonContainer.createEl("button", { text: "Cancel", cls: "cancel-button" });
    confirmBtn.onclick = () => {
      this.close();
      this.onConfirm();
    };
    cancelBtn.onclick = () => {
      this.close();
    };
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var SearchResultsModal = class extends import_obsidian6.Modal {
  constructor(app, results) {
    super(app);
    this.results = results;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("search-results-modal");
    contentEl.createEl("h2", { text: "Search Results" });
    const resultsContainer = contentEl.createDiv({ cls: "results-container" });
    this.results.forEach((result) => {
      const resultEl = resultsContainer.createDiv({ cls: "result-item" });
      resultEl.createEl("span", { text: `${result.file.basename} - Similarity: ${result.similarity.toFixed(2)}` });
      resultEl.addEventListener("click", () => __async(this, null, function* () {
        const leaf = this.app.workspace.getLeaf(false);
        if (leaf && result.file) {
          try {
            yield leaf.openFile(result.file);
          } catch (error) {
            console.error("Error opening file:", error);
            new import_obsidian6.Notice("Failed to open file", 2e3);
          }
        } else {
          new import_obsidian6.Notice("Could not open file", 2e3);
        }
      }));
    });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var AIPilotSettingTab = class extends import_obsidian6.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "AI Model Configuration" });
    containerEl.createEl("p", {
      text: "Configure your AI models to use with the plugin. All API keys are now managed here.",
      cls: "setting-item-description"
    });
    containerEl.createEl("div", {
      text: "The plugin has migrated to a multi-model system. Add models below to use them with the plugin.",
      cls: "model-migration-notice"
    });
    new import_obsidian6.Setting(containerEl).setName("AI Models").setDesc("Add, edit, or remove AI models").addButton((button) => button.setButtonText("Add Model").setCta().onClick(() => {
      this.openModelConfigModal();
    }));
    const modelsContainer = containerEl.createDiv({ cls: "models-container" });
    this.renderModelsList(modelsContainer);
    containerEl.createEl("h2", { text: "Chat History" });
    new import_obsidian6.Setting(containerEl).setName("Chat History Path").setDesc("Path to store chat history files (relative to vault)").addText((text) => text.setPlaceholder("AI_ChatHistory").setValue(this.plugin.settings.chatHistoryPath).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.chatHistoryPath = value;
      yield this.plugin.saveSettings();
    })));
    containerEl.createEl("h2", { text: "Functions" });
    containerEl.createEl("p", {
      text: "Configure all available functions that appear as icons in the chat view.",
      cls: "setting-item-description"
    });
    if (!this.plugin.settings.functions) {
      this.plugin.settings.functions = [];
    }
    if (this.plugin.settings.functions.length === 0 && DEFAULT_SETTINGS.functions) {
      this.plugin.settings.functions = [...DEFAULT_SETTINGS.functions];
      if (this.plugin.settings.customFunctions && this.plugin.settings.customFunctions.length > 0) {
        this.plugin.settings.functions.push(...this.plugin.settings.customFunctions);
      }
    }
    this.migratePromptsToFunctions();
    const functionsContainer = containerEl.createDiv({ cls: "functions-container" });
    this.displayFunctions(functionsContainer);
    new import_obsidian6.Setting(containerEl).addButton((button) => button.setButtonText("Add New Function").setCta().onClick(() => {
      const newCustomFunc = {
        name: "",
        icon: "star",
        prompt: "",
        tooltip: "",
        isBuiltIn: false
      };
      new CustomFunctionModal(this.app, newCustomFunc, (customFunc) => __async(this, null, function* () {
        this.plugin.settings.functions.push(customFunc);
        if (!this.plugin.settings.customFunctions) {
          this.plugin.settings.customFunctions = [];
        }
        this.plugin.settings.customFunctions.push(customFunc);
        yield this.plugin.saveSettings();
        this.display();
      })).open();
    }));
    containerEl.createEl("h2", { text: "Network Proxy Configuration" });
    const proxyConfig = this.plugin.settings.proxyConfig;
    new import_obsidian6.Setting(containerEl).setName("Enable Proxy").setDesc("Use a proxy for all API requests to LLM providers").addToggle((toggle) => toggle.setValue(proxyConfig.enabled).onChange((value) => __async(this, null, function* () {
      proxyConfig.enabled = value;
      yield this.plugin.saveSettings();
      this.plugin.modelManager.updateProxyConfig(proxyConfig);
    })));
    if (proxyConfig.enabled) {
      new import_obsidian6.Setting(containerEl).setName("Proxy Type").setDesc("Select the type of proxy to use").addDropdown((dropdown) => dropdown.addOption("http", "HTTP").addOption("https", "HTTPS").addOption("socks5", "SOCKS5").setValue(proxyConfig.type).onChange((value) => __async(this, null, function* () {
        proxyConfig.type = value;
        yield this.plugin.saveSettings();
        this.plugin.modelManager.updateProxyConfig(proxyConfig);
      })));
      new import_obsidian6.Setting(containerEl).setName("Proxy Address").setDesc("Enter the proxy server address").addText((text) => text.setPlaceholder("127.0.0.1").setValue(proxyConfig.address).onChange((value) => __async(this, null, function* () {
        proxyConfig.address = value;
        yield this.plugin.saveSettings();
        this.plugin.modelManager.updateProxyConfig(proxyConfig);
      })));
      new import_obsidian6.Setting(containerEl).setName("Proxy Port").setDesc("Enter the proxy server port").addText((text) => text.setPlaceholder("8080").setValue(proxyConfig.port).onChange((value) => __async(this, null, function* () {
        proxyConfig.port = value;
        yield this.plugin.saveSettings();
        this.plugin.modelManager.updateProxyConfig(proxyConfig);
      })));
      new import_obsidian6.Setting(containerEl).setName("Requires Authentication").setDesc("Does your proxy require username/password authentication?").addToggle((toggle) => toggle.setValue(proxyConfig.requiresAuth).onChange((value) => __async(this, null, function* () {
        proxyConfig.requiresAuth = value;
        yield this.plugin.saveSettings();
        this.plugin.modelManager.updateProxyConfig(proxyConfig);
        this.display();
      })));
      if (proxyConfig.requiresAuth) {
        new import_obsidian6.Setting(containerEl).setName("Proxy Username").addText((text) => text.setValue(proxyConfig.username || "").onChange((value) => __async(this, null, function* () {
          proxyConfig.username = value;
          yield this.plugin.saveSettings();
          this.plugin.modelManager.updateProxyConfig(proxyConfig);
        })));
        new import_obsidian6.Setting(containerEl).setName("Proxy Password").addText((text) => {
          const passwordInput = text.setPlaceholder("password").setValue(proxyConfig.password || "").onChange((value) => __async(this, null, function* () {
            proxyConfig.password = value;
            yield this.plugin.saveSettings();
            this.plugin.modelManager.updateProxyConfig(proxyConfig);
          }));
          passwordInput.inputEl.setAttribute("type", "password");
          return passwordInput;
        });
      }
    }
  }
  // Add to AIPilotSettingTab class
  migratePromptsToFunctions() {
    if (!this.plugin.settings.functions) {
      this.plugin.settings.functions = [];
    }
  }
  displayFunctions(container) {
    container.empty();
    if (!this.plugin.settings.functions || this.plugin.settings.functions.length === 0) {
      container.createEl("p", {
        text: 'No functions defined. Click "Add Custom Function" below to create one.',
        cls: "no-functions"
      });
      return;
    }
    const builtInFunctions = this.plugin.settings.functions.filter((f) => f.isBuiltIn);
    const customFunctions = this.plugin.settings.functions.filter((f) => !f.isBuiltIn);
    if (builtInFunctions.length > 0) {
      const builtInSection = container.createDiv({ cls: "function-section" });
      builtInSection.createEl("h3", { text: "Built-in Functions" });
      for (const func of builtInFunctions) {
        this.createFunctionItem(builtInSection, func, true);
      }
    }
    if (customFunctions.length > 0) {
      const customSection = container.createDiv({ cls: "function-section" });
      customSection.createEl("h3", { text: "Custom Functions" });
      for (const func of customFunctions) {
        this.createFunctionItem(customSection, func, false);
      }
    }
    const addButtonContainer = container.createDiv({ cls: "add-function-container" });
    const addButton = addButtonContainer.createEl("button", {
      text: "Add Custom Function",
      cls: "add-function-button"
    });
    addButton.addEventListener("click", () => {
      const newCustomFunc = {
        name: "",
        icon: "star",
        prompt: "",
        tooltip: "",
        isBuiltIn: false
      };
      new CustomFunctionModal(this.app, newCustomFunc, (updatedFunc) => __async(this, null, function* () {
        this.plugin.settings.functions.push(updatedFunc);
        yield this.plugin.saveSettings();
        this.displayFunctions(container);
      })).open();
    });
  }
  createFunctionItem(container, func, isBuiltIn) {
    const funcItem = container.createDiv({
      cls: `function-item ${isBuiltIn ? "built-in" : "custom"}`
    });
    const preview = funcItem.createDiv({ cls: "function-preview" });
    const iconEl = preview.createDiv({ cls: "function-icon" });
    (0, import_obsidian6.setIcon)(iconEl, func.icon || "star");
    preview.createEl("span", {
      text: func.name,
      cls: "function-name"
    });
    if (func.tooltip) {
      preview.createEl("span", {
        text: func.tooltip,
        cls: "function-tooltip"
      });
    }
    const actions = funcItem.createDiv({ cls: "function-actions" });
    const editBtn = actions.createEl("button", { cls: "function-edit" });
    (0, import_obsidian6.setIcon)(editBtn, "edit");
    editBtn.onclick = () => {
      new CustomFunctionModal(this.app, func, (updatedFunc) => __async(this, null, function* () {
        const index = this.plugin.settings.functions.findIndex((f) => f.name === func.name && f.isBuiltIn === isBuiltIn);
        if (index !== -1) {
          this.plugin.settings.functions[index] = updatedFunc;
          yield this.plugin.saveSettings();
          this.displayFunctions(container.parentElement);
        }
      })).open();
    };
    if (!isBuiltIn) {
      const deleteBtn = actions.createEl("button", { cls: "function-delete" });
      (0, import_obsidian6.setIcon)(deleteBtn, "trash");
      deleteBtn.onclick = () => __async(this, null, function* () {
        const confirmModal = new ConfirmModal2(
          this.app,
          `Are you sure you want to delete the "${func.name}" function?`,
          () => __async(this, null, function* () {
            this.plugin.settings.functions = this.plugin.settings.functions.filter((f) => !(f.name === func.name && !f.isBuiltIn));
            yield this.plugin.saveSettings();
            this.displayFunctions(container.parentElement);
          })
        );
        confirmModal.open();
      });
    }
  }
  openModelConfigModal(existingModel) {
    const modal = new ModelConfigModal(
      this.app,
      existingModel || null,
      // Use null when existingModel is undefined
      (updatedModel) => {
        if (existingModel) {
          const index = this.plugin.settings.models.findIndex((m) => m.id === existingModel.id);
          if (index !== -1) {
            this.plugin.settings.models[index] = updatedModel;
          }
        } else {
          this.plugin.settings.models.push(updatedModel);
        }
        this.plugin.saveSettings().then(() => {
          const container = document.querySelector(".models-container");
          if (container) {
            this.renderModelsList(container);
          }
        });
      }
    );
    modal.open();
  }
  renderModelsList(container) {
    if (!container) return;
    const htmlContainer = container;
    htmlContainer.empty();
    const models = this.plugin.settings.models || [];
    if (models.length === 0) {
      htmlContainer.createEl("div", {
        text: 'No models configured. Click "Add Model" to configure a new model.',
        cls: "no-models-message"
      });
      return;
    }
    for (const model of models) {
      const modelItem = htmlContainer.createDiv({ cls: "model-item" });
      const modelInfo = modelItem.createDiv({ cls: "model-info" });
      const titleEl = modelInfo.createEl("h3");
      titleEl.createSpan({ text: model.name });
      if (model.isDefault) {
        titleEl.createSpan({
          text: " (Default)",
          cls: "model-default-tag"
        });
        modelItem.addClass("model-default");
      }
      const modelMeta = modelInfo.createDiv({ cls: "model-meta" });
      modelMeta.createSpan({ text: `Type: ${model.type}` });
      if (model.modelName) {
        modelMeta.createSpan({ text: ` \u2022 Model: ${model.modelName}` });
      }
      if (model.active) {
        modelMeta.createSpan({
          text: " \u2022 Active",
          cls: "model-active-indicator"
        });
      }
      const modelActions = modelItem.createDiv({ cls: "model-actions" });
      if (!model.isDefault) {
        const defaultBtn = modelActions.createEl("button", {
          text: "Set Default",
          cls: "model-default-btn"
        });
        defaultBtn.onclick = () => __async(this, null, function* () {
          this.plugin.settings.models.forEach((m) => {
            m.isDefault = m.id === model.id;
          });
          yield this.plugin.saveSettings();
          this.renderModelsList(container);
        });
      }
      const editBtn = modelActions.createEl("button", {
        text: "Edit",
        cls: "model-edit"
      });
      editBtn.onclick = () => {
        this.openModelConfigModal(model);
      };
      const deleteBtn = modelActions.createEl("button", {
        text: "Delete",
        cls: "model-delete"
      });
      deleteBtn.onclick = () => __async(this, null, function* () {
        const confirmModal = new ConfirmModal2(
          this.app,
          `Are you sure you want to delete the "${model.name}" model?`,
          () => __async(this, null, function* () {
            this.plugin.settings.models = this.plugin.settings.models.filter((m) => m.id !== model.id);
            yield this.plugin.saveSettings();
            this.renderModelsList(container);
          })
        );
        confirmModal.open();
      });
    }
  }
};
var CustomFunctionModal = class extends import_obsidian6.Modal {
  constructor(app, customFunc, onSubmit) {
    var _a;
    super(app);
    this.plugin = ((_a = app.plugins) == null ? void 0 : _a.getPlugin("ai-pilot")) || null;
    this.customFunc = customFunc || {
      name: "",
      icon: "star",
      tooltip: "",
      prompt: "",
      isBuiltIn: false
    };
    this.onSubmit = onSubmit || (() => {
    });
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.createEl("h2", { text: this.customFunc.name ? "Edit Function" : "Create Function" });
    contentEl.createEl("label", { text: "Function Name (required)", cls: "setting-item-label" });
    const nameInput = contentEl.createEl("input", {
      type: "text",
      value: this.customFunc.name,
      cls: "setting-item-input"
    });
    contentEl.createEl("label", { text: "Icon", cls: "setting-item-label" });
    const iconInput = contentEl.createEl("input", {
      type: "text",
      value: this.customFunc.icon || "star",
      cls: "setting-item-input",
      placeholder: "Obsidian icon name (e.g. star, brain, pencil)"
    });
    const iconPreview = contentEl.createDiv({ cls: "icon-preview" });
    const updateIconPreview = () => {
      iconPreview.empty();
      (0, import_obsidian6.setIcon)(iconPreview, iconInput.value || "star");
    };
    updateIconPreview();
    iconInput.addEventListener("input", updateIconPreview);
    contentEl.createEl("label", { text: "Tooltip", cls: "setting-item-label" });
    const tooltipInput = contentEl.createEl("input", {
      type: "text",
      value: this.customFunc.tooltip || "",
      cls: "setting-item-input",
      placeholder: "Briefly describe what this function does"
    });
    contentEl.createEl("label", { text: "Prompt Template (required)", cls: "setting-item-label" });
    contentEl.createEl("p", {
      text: "Use {{content}} to reference the selected text.",
      cls: "setting-item-description"
    });
    const promptInput = contentEl.createEl("textarea", {
      cls: "setting-item-textarea",
      value: this.customFunc.prompt || "",
      placeholder: "Enter your prompt template here. Use {{content}} to reference the selected text."
    });
    promptInput.style.height = "150px";
    const buttonContainer = contentEl.createDiv({ cls: "button-container" });
    const cancelButton = buttonContainer.createEl("button", { text: "Cancel" });
    cancelButton.addEventListener("click", () => {
      this.close();
    });
    const submitButton = buttonContainer.createEl("button", {
      text: this.customFunc.name ? "Save" : "Create",
      cls: "mod-cta"
    });
    submitButton.addEventListener("click", () => {
      if (!nameInput.value.trim()) {
        new import_obsidian6.Notice("Function name is required");
        return;
      }
      if (!promptInput.value.trim()) {
        new import_obsidian6.Notice("Prompt template is required");
        return;
      }
      const updatedFunc = {
        name: nameInput.value.trim(),
        icon: iconInput.value.trim() || "star",
        prompt: promptInput.value.trim(),
        tooltip: tooltipInput.value.trim(),
        isBuiltIn: this.customFunc.isBuiltIn || false
      };
      this.onSubmit(updatedFunc);
      this.close();
    });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
