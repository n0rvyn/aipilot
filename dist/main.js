/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// src/main.ts
var main_exports = {};
__export(main_exports, {
  DEFAULT_SETTINGS: () => DEFAULT_SETTINGS,
  LoadingModal: () => LoadingModal2,
  PolishResultModal: () => PolishResultModal,
  default: () => AIPilotPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian9 = require("obsidian");

// src/ChatView.ts
var import_obsidian2 = require("obsidian");

// node_modules/marked/lib/marked.esm.js
function _getDefaults() {
  return {
    async: false,
    breaks: false,
    extensions: null,
    gfm: true,
    hooks: null,
    pedantic: false,
    renderer: null,
    silent: false,
    tokenizer: null,
    walkTokens: null
  };
}
var _defaults = _getDefaults();
function changeDefaults(newDefaults) {
  _defaults = newDefaults;
}
var noopTest = { exec: () => null };
function edit(regex, opt = "") {
  let source = typeof regex === "string" ? regex : regex.source;
  const obj = {
    replace: (name, val) => {
      let valSource = typeof val === "string" ? val : val.source;
      valSource = valSource.replace(other.caret, "$1");
      source = source.replace(name, valSource);
      return obj;
    },
    getRegex: () => {
      return new RegExp(source, opt);
    }
  };
  return obj;
}
var other = {
  codeRemoveIndent: /^(?: {1,4}| {0,3}\t)/gm,
  outputLinkReplace: /\\([\[\]])/g,
  indentCodeCompensation: /^(\s+)(?:```)/,
  beginningSpace: /^\s+/,
  endingHash: /#$/,
  startingSpaceChar: /^ /,
  endingSpaceChar: / $/,
  nonSpaceChar: /[^ ]/,
  newLineCharGlobal: /\n/g,
  tabCharGlobal: /\t/g,
  multipleSpaceGlobal: /\s+/g,
  blankLine: /^[ \t]*$/,
  doubleBlankLine: /\n[ \t]*\n[ \t]*$/,
  blockquoteStart: /^ {0,3}>/,
  blockquoteSetextReplace: /\n {0,3}((?:=+|-+) *)(?=\n|$)/g,
  blockquoteSetextReplace2: /^ {0,3}>[ \t]?/gm,
  listReplaceTabs: /^\t+/,
  listReplaceNesting: /^ {1,4}(?=( {4})*[^ ])/g,
  listIsTask: /^\[[ xX]\] /,
  listReplaceTask: /^\[[ xX]\] +/,
  anyLine: /\n.*\n/,
  hrefBrackets: /^<(.*)>$/,
  tableDelimiter: /[:|]/,
  tableAlignChars: /^\||\| *$/g,
  tableRowBlankLine: /\n[ \t]*$/,
  tableAlignRight: /^ *-+: *$/,
  tableAlignCenter: /^ *:-+: *$/,
  tableAlignLeft: /^ *:-+ *$/,
  startATag: /^<a /i,
  endATag: /^<\/a>/i,
  startPreScriptTag: /^<(pre|code|kbd|script)(\s|>)/i,
  endPreScriptTag: /^<\/(pre|code|kbd|script)(\s|>)/i,
  startAngleBracket: /^</,
  endAngleBracket: />$/,
  pedanticHrefTitle: /^([^'"]*[^\s])\s+(['"])(.*)\2/,
  unicodeAlphaNumeric: /[\p{L}\p{N}]/u,
  escapeTest: /[&<>"']/,
  escapeReplace: /[&<>"']/g,
  escapeTestNoEncode: /[<>"']|&(?!(#\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\w+);)/,
  escapeReplaceNoEncode: /[<>"']|&(?!(#\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\w+);)/g,
  unescapeTest: /&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/ig,
  caret: /(^|[^\[])\^/g,
  percentDecode: /%25/g,
  findPipe: /\|/g,
  splitPipe: / \|/,
  slashPipe: /\\\|/g,
  carriageReturn: /\r\n|\r/g,
  spaceLine: /^ +$/gm,
  notSpaceStart: /^\S*/,
  endingNewline: /\n$/,
  listItemRegex: (bull) => new RegExp(`^( {0,3}${bull})((?:[	 ][^\\n]*)?(?:\\n|$))`),
  nextBulletRegex: (indent) => new RegExp(`^ {0,${Math.min(3, indent - 1)}}(?:[*+-]|\\d{1,9}[.)])((?:[ 	][^\\n]*)?(?:\\n|$))`),
  hrRegex: (indent) => new RegExp(`^ {0,${Math.min(3, indent - 1)}}((?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$)`),
  fencesBeginRegex: (indent) => new RegExp(`^ {0,${Math.min(3, indent - 1)}}(?:\`\`\`|~~~)`),
  headingBeginRegex: (indent) => new RegExp(`^ {0,${Math.min(3, indent - 1)}}#`),
  htmlBeginRegex: (indent) => new RegExp(`^ {0,${Math.min(3, indent - 1)}}<(?:[a-z].*>|!--)`, "i")
};
var newline = /^(?:[ \t]*(?:\n|$))+/;
var blockCode = /^((?: {4}| {0,3}\t)[^\n]+(?:\n(?:[ \t]*(?:\n|$))*)?)+/;
var fences = /^ {0,3}(`{3,}(?=[^`\n]*(?:\n|$))|~{3,})([^\n]*)(?:\n|$)(?:|([\s\S]*?)(?:\n|$))(?: {0,3}\1[~`]* *(?=\n|$)|$)/;
var hr = /^ {0,3}((?:-[\t ]*){3,}|(?:_[ \t]*){3,}|(?:\*[ \t]*){3,})(?:\n+|$)/;
var heading = /^ {0,3}(#{1,6})(?=\s|$)(.*)(?:\n+|$)/;
var bullet = /(?:[*+-]|\d{1,9}[.)])/;
var lheadingCore = /^(?!bull |blockCode|fences|blockquote|heading|html|table)((?:.|\n(?!\s*?\n|bull |blockCode|fences|blockquote|heading|html|table))+?)\n {0,3}(=+|-+) *(?:\n+|$)/;
var lheading = edit(lheadingCore).replace(/bull/g, bullet).replace(/blockCode/g, /(?: {4}| {0,3}\t)/).replace(/fences/g, / {0,3}(?:`{3,}|~{3,})/).replace(/blockquote/g, / {0,3}>/).replace(/heading/g, / {0,3}#{1,6}/).replace(/html/g, / {0,3}<[^\n>]+>\n/).replace(/\|table/g, "").getRegex();
var lheadingGfm = edit(lheadingCore).replace(/bull/g, bullet).replace(/blockCode/g, /(?: {4}| {0,3}\t)/).replace(/fences/g, / {0,3}(?:`{3,}|~{3,})/).replace(/blockquote/g, / {0,3}>/).replace(/heading/g, / {0,3}#{1,6}/).replace(/html/g, / {0,3}<[^\n>]+>\n/).replace(/table/g, / {0,3}\|?(?:[:\- ]*\|)+[\:\- ]*\n/).getRegex();
var _paragraph = /^([^\n]+(?:\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\n)[^\n]+)*)/;
var blockText = /^[^\n]+/;
var _blockLabel = /(?!\s*\])(?:\\.|[^\[\]\\])+/;
var def = edit(/^ {0,3}\[(label)\]: *(?:\n[ \t]*)?([^<\s][^\s]*|<.*?>)(?:(?: +(?:\n[ \t]*)?| *\n[ \t]*)(title))? *(?:\n+|$)/).replace("label", _blockLabel).replace("title", /(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/).getRegex();
var list = edit(/^( {0,3}bull)([ \t][^\n]+?)?(?:\n|$)/).replace(/bull/g, bullet).getRegex();
var _tag = "address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option|p|param|search|section|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul";
var _comment = /<!--(?:-?>|[\s\S]*?(?:-->|$))/;
var html = edit("^ {0,3}(?:<(script|pre|style|textarea)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)|comment[^\\n]*(\\n+|$)|<\\?[\\s\\S]*?(?:\\?>\\n*|$)|<![A-Z][\\s\\S]*?(?:>\\n*|$)|<!\\[CDATA\\[[\\s\\S]*?(?:\\]\\]>\\n*|$)|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:(?:\\n[ 	]*)+\\n|$)|<(?!script|pre|style|textarea)([a-z][\\w-]*)(?:attribute)*? */?>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n[ 	]*)+\\n|$)|</(?!script|pre|style|textarea)[a-z][\\w-]*\\s*>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n[ 	]*)+\\n|$))", "i").replace("comment", _comment).replace("tag", _tag).replace("attribute", / +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/).getRegex();
var paragraph = edit(_paragraph).replace("hr", hr).replace("heading", " {0,3}#{1,6}(?:\\s|$)").replace("|lheading", "").replace("|table", "").replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", _tag).getRegex();
var blockquote = edit(/^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/).replace("paragraph", paragraph).getRegex();
var blockNormal = {
  blockquote,
  code: blockCode,
  def,
  fences,
  heading,
  hr,
  html,
  lheading,
  list,
  newline,
  paragraph,
  table: noopTest,
  text: blockText
};
var gfmTable = edit("^ *([^\\n ].*)\\n {0,3}((?:\\| *)?:?-+:? *(?:\\| *:?-+:? *)*(?:\\| *)?)(?:\\n((?:(?! *\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)").replace("hr", hr).replace("heading", " {0,3}#{1,6}(?:\\s|$)").replace("blockquote", " {0,3}>").replace("code", "(?: {4}| {0,3}	)[^\\n]").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", _tag).getRegex();
var blockGfm = __spreadProps(__spreadValues({}, blockNormal), {
  lheading: lheadingGfm,
  table: gfmTable,
  paragraph: edit(_paragraph).replace("hr", hr).replace("heading", " {0,3}#{1,6}(?:\\s|$)").replace("|lheading", "").replace("table", gfmTable).replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", _tag).getRegex()
});
var blockPedantic = __spreadProps(__spreadValues({}, blockNormal), {
  html: edit(`^ *(?:comment *(?:\\n|\\s*$)|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)|<tag(?:"[^"]*"|'[^']*'|\\s[^'"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))`).replace("comment", _comment).replace(/tag/g, "(?!(?:a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)\\b)\\w+(?!:|[^\\w\\s@]*@)\\b").getRegex(),
  def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/,
  heading: /^(#{1,6})(.*)(?:\n+|$)/,
  fences: noopTest,
  // fences not supported
  lheading: /^(.+?)\n {0,3}(=+|-+) *(?:\n+|$)/,
  paragraph: edit(_paragraph).replace("hr", hr).replace("heading", " *#{1,6} *[^\n]").replace("lheading", lheading).replace("|table", "").replace("blockquote", " {0,3}>").replace("|fences", "").replace("|list", "").replace("|html", "").replace("|tag", "").getRegex()
});
var escape$1 = /^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/;
var inlineCode = /^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/;
var br = /^( {2,}|\\)\n(?!\s*$)/;
var inlineText = /^(`+|[^`])(?:(?= {2,}\n)|[\s\S]*?(?:(?=[\\<!\[`*_]|\b_|$)|[^ ](?= {2,}\n)))/;
var _punctuation = /[\p{P}\p{S}]/u;
var _punctuationOrSpace = /[\s\p{P}\p{S}]/u;
var _notPunctuationOrSpace = /[^\s\p{P}\p{S}]/u;
var punctuation = edit(/^((?![*_])punctSpace)/, "u").replace(/punctSpace/g, _punctuationOrSpace).getRegex();
var _punctuationGfmStrongEm = /(?!~)[\p{P}\p{S}]/u;
var _punctuationOrSpaceGfmStrongEm = /(?!~)[\s\p{P}\p{S}]/u;
var _notPunctuationOrSpaceGfmStrongEm = /(?:[^\s\p{P}\p{S}]|~)/u;
var blockSkip = /\[[^[\]]*?\]\((?:\\.|[^\\\(\)]|\((?:\\.|[^\\\(\)])*\))*\)|`[^`]*?`|<[^<>]*?>/g;
var emStrongLDelimCore = /^(?:\*+(?:((?!\*)punct)|[^\s*]))|^_+(?:((?!_)punct)|([^\s_]))/;
var emStrongLDelim = edit(emStrongLDelimCore, "u").replace(/punct/g, _punctuation).getRegex();
var emStrongLDelimGfm = edit(emStrongLDelimCore, "u").replace(/punct/g, _punctuationGfmStrongEm).getRegex();
var emStrongRDelimAstCore = "^[^_*]*?__[^_*]*?\\*[^_*]*?(?=__)|[^*]+(?=[^*])|(?!\\*)punct(\\*+)(?=[\\s]|$)|notPunctSpace(\\*+)(?!\\*)(?=punctSpace|$)|(?!\\*)punctSpace(\\*+)(?=notPunctSpace)|[\\s](\\*+)(?!\\*)(?=punct)|(?!\\*)punct(\\*+)(?!\\*)(?=punct)|notPunctSpace(\\*+)(?=notPunctSpace)";
var emStrongRDelimAst = edit(emStrongRDelimAstCore, "gu").replace(/notPunctSpace/g, _notPunctuationOrSpace).replace(/punctSpace/g, _punctuationOrSpace).replace(/punct/g, _punctuation).getRegex();
var emStrongRDelimAstGfm = edit(emStrongRDelimAstCore, "gu").replace(/notPunctSpace/g, _notPunctuationOrSpaceGfmStrongEm).replace(/punctSpace/g, _punctuationOrSpaceGfmStrongEm).replace(/punct/g, _punctuationGfmStrongEm).getRegex();
var emStrongRDelimUnd = edit("^[^_*]*?\\*\\*[^_*]*?_[^_*]*?(?=\\*\\*)|[^_]+(?=[^_])|(?!_)punct(_+)(?=[\\s]|$)|notPunctSpace(_+)(?!_)(?=punctSpace|$)|(?!_)punctSpace(_+)(?=notPunctSpace)|[\\s](_+)(?!_)(?=punct)|(?!_)punct(_+)(?!_)(?=punct)", "gu").replace(/notPunctSpace/g, _notPunctuationOrSpace).replace(/punctSpace/g, _punctuationOrSpace).replace(/punct/g, _punctuation).getRegex();
var anyPunctuation = edit(/\\(punct)/, "gu").replace(/punct/g, _punctuation).getRegex();
var autolink = edit(/^<(scheme:[^\s\x00-\x1f<>]*|email)>/).replace("scheme", /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/).replace("email", /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/).getRegex();
var _inlineComment = edit(_comment).replace("(?:-->|$)", "-->").getRegex();
var tag = edit("^comment|^</[a-zA-Z][\\w:-]*\\s*>|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>|^<\\?[\\s\\S]*?\\?>|^<![a-zA-Z]+\\s[\\s\\S]*?>|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>").replace("comment", _inlineComment).replace("attribute", /\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/).getRegex();
var _inlineLabel = /(?:\[(?:\\.|[^\[\]\\])*\]|\\.|`[^`]*`|[^\[\]\\`])*?/;
var link = edit(/^!?\[(label)\]\(\s*(href)(?:\s+(title))?\s*\)/).replace("label", _inlineLabel).replace("href", /<(?:\\.|[^\n<>\\])+>|[^\s\x00-\x1f]*/).replace("title", /"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/).getRegex();
var reflink = edit(/^!?\[(label)\]\[(ref)\]/).replace("label", _inlineLabel).replace("ref", _blockLabel).getRegex();
var nolink = edit(/^!?\[(ref)\](?:\[\])?/).replace("ref", _blockLabel).getRegex();
var reflinkSearch = edit("reflink|nolink(?!\\()", "g").replace("reflink", reflink).replace("nolink", nolink).getRegex();
var inlineNormal = {
  _backpedal: noopTest,
  // only used for GFM url
  anyPunctuation,
  autolink,
  blockSkip,
  br,
  code: inlineCode,
  del: noopTest,
  emStrongLDelim,
  emStrongRDelimAst,
  emStrongRDelimUnd,
  escape: escape$1,
  link,
  nolink,
  punctuation,
  reflink,
  reflinkSearch,
  tag,
  text: inlineText,
  url: noopTest
};
var inlinePedantic = __spreadProps(__spreadValues({}, inlineNormal), {
  link: edit(/^!?\[(label)\]\((.*?)\)/).replace("label", _inlineLabel).getRegex(),
  reflink: edit(/^!?\[(label)\]\s*\[([^\]]*)\]/).replace("label", _inlineLabel).getRegex()
});
var inlineGfm = __spreadProps(__spreadValues({}, inlineNormal), {
  emStrongRDelimAst: emStrongRDelimAstGfm,
  emStrongLDelim: emStrongLDelimGfm,
  url: edit(/^((?:ftp|https?):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/, "i").replace("email", /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/).getRegex(),
  _backpedal: /(?:[^?!.,:;*_'"~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_'"~)]+(?!$))+/,
  del: /^(~~?)(?=[^\s~])((?:\\.|[^\\])*?(?:\\.|[^\s~\\]))\1(?=[^~]|$)/,
  text: /^([`~]+|[^`~])(?:(?= {2,}\n)|(?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)|[\s\S]*?(?:(?=[\\<!\[`*~_]|\b_|https?:\/\/|ftp:\/\/|www\.|$)|[^ ](?= {2,}\n)|[^a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-](?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)))/
});
var inlineBreaks = __spreadProps(__spreadValues({}, inlineGfm), {
  br: edit(br).replace("{2,}", "*").getRegex(),
  text: edit(inlineGfm.text).replace("\\b_", "\\b_| {2,}\\n").replace(/\{2,\}/g, "*").getRegex()
});
var block = {
  normal: blockNormal,
  gfm: blockGfm,
  pedantic: blockPedantic
};
var inline = {
  normal: inlineNormal,
  gfm: inlineGfm,
  breaks: inlineBreaks,
  pedantic: inlinePedantic
};
var escapeReplacements = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;"
};
var getEscapeReplacement = (ch) => escapeReplacements[ch];
function escape(html2, encode) {
  if (encode) {
    if (other.escapeTest.test(html2)) {
      return html2.replace(other.escapeReplace, getEscapeReplacement);
    }
  } else {
    if (other.escapeTestNoEncode.test(html2)) {
      return html2.replace(other.escapeReplaceNoEncode, getEscapeReplacement);
    }
  }
  return html2;
}
function cleanUrl(href) {
  try {
    href = encodeURI(href).replace(other.percentDecode, "%");
  } catch (e) {
    return null;
  }
  return href;
}
function splitCells(tableRow, count) {
  var _a;
  const row = tableRow.replace(other.findPipe, (match, offset, str) => {
    let escaped = false;
    let curr = offset;
    while (--curr >= 0 && str[curr] === "\\")
      escaped = !escaped;
    if (escaped) {
      return "|";
    } else {
      return " |";
    }
  }), cells = row.split(other.splitPipe);
  let i = 0;
  if (!cells[0].trim()) {
    cells.shift();
  }
  if (cells.length > 0 && !((_a = cells.at(-1)) == null ? void 0 : _a.trim())) {
    cells.pop();
  }
  if (count) {
    if (cells.length > count) {
      cells.splice(count);
    } else {
      while (cells.length < count)
        cells.push("");
    }
  }
  for (; i < cells.length; i++) {
    cells[i] = cells[i].trim().replace(other.slashPipe, "|");
  }
  return cells;
}
function rtrim(str, c, invert) {
  const l = str.length;
  if (l === 0) {
    return "";
  }
  let suffLen = 0;
  while (suffLen < l) {
    const currChar = str.charAt(l - suffLen - 1);
    if (currChar === c && true) {
      suffLen++;
    } else {
      break;
    }
  }
  return str.slice(0, l - suffLen);
}
function findClosingBracket(str, b) {
  if (str.indexOf(b[1]) === -1) {
    return -1;
  }
  let level = 0;
  for (let i = 0; i < str.length; i++) {
    if (str[i] === "\\") {
      i++;
    } else if (str[i] === b[0]) {
      level++;
    } else if (str[i] === b[1]) {
      level--;
      if (level < 0) {
        return i;
      }
    }
  }
  return -1;
}
function outputLink(cap, link2, raw, lexer2, rules) {
  const href = link2.href;
  const title = link2.title || null;
  const text = cap[1].replace(rules.other.outputLinkReplace, "$1");
  if (cap[0].charAt(0) !== "!") {
    lexer2.state.inLink = true;
    const token = {
      type: "link",
      raw,
      href,
      title,
      text,
      tokens: lexer2.inlineTokens(text)
    };
    lexer2.state.inLink = false;
    return token;
  }
  return {
    type: "image",
    raw,
    href,
    title,
    text
  };
}
function indentCodeCompensation(raw, text, rules) {
  const matchIndentToCode = raw.match(rules.other.indentCodeCompensation);
  if (matchIndentToCode === null) {
    return text;
  }
  const indentToCode = matchIndentToCode[1];
  return text.split("\n").map((node) => {
    const matchIndentInNode = node.match(rules.other.beginningSpace);
    if (matchIndentInNode === null) {
      return node;
    }
    const [indentInNode] = matchIndentInNode;
    if (indentInNode.length >= indentToCode.length) {
      return node.slice(indentToCode.length);
    }
    return node;
  }).join("\n");
}
var _Tokenizer = class {
  // set by the lexer
  constructor(options2) {
    __publicField(this, "options");
    __publicField(this, "rules");
    // set by the lexer
    __publicField(this, "lexer");
    this.options = options2 || _defaults;
  }
  space(src) {
    const cap = this.rules.block.newline.exec(src);
    if (cap && cap[0].length > 0) {
      return {
        type: "space",
        raw: cap[0]
      };
    }
  }
  code(src) {
    const cap = this.rules.block.code.exec(src);
    if (cap) {
      const text = cap[0].replace(this.rules.other.codeRemoveIndent, "");
      return {
        type: "code",
        raw: cap[0],
        codeBlockStyle: "indented",
        text: !this.options.pedantic ? rtrim(text, "\n") : text
      };
    }
  }
  fences(src) {
    const cap = this.rules.block.fences.exec(src);
    if (cap) {
      const raw = cap[0];
      const text = indentCodeCompensation(raw, cap[3] || "", this.rules);
      return {
        type: "code",
        raw,
        lang: cap[2] ? cap[2].trim().replace(this.rules.inline.anyPunctuation, "$1") : cap[2],
        text
      };
    }
  }
  heading(src) {
    const cap = this.rules.block.heading.exec(src);
    if (cap) {
      let text = cap[2].trim();
      if (this.rules.other.endingHash.test(text)) {
        const trimmed = rtrim(text, "#");
        if (this.options.pedantic) {
          text = trimmed.trim();
        } else if (!trimmed || this.rules.other.endingSpaceChar.test(trimmed)) {
          text = trimmed.trim();
        }
      }
      return {
        type: "heading",
        raw: cap[0],
        depth: cap[1].length,
        text,
        tokens: this.lexer.inline(text)
      };
    }
  }
  hr(src) {
    const cap = this.rules.block.hr.exec(src);
    if (cap) {
      return {
        type: "hr",
        raw: rtrim(cap[0], "\n")
      };
    }
  }
  blockquote(src) {
    const cap = this.rules.block.blockquote.exec(src);
    if (cap) {
      let lines = rtrim(cap[0], "\n").split("\n");
      let raw = "";
      let text = "";
      const tokens = [];
      while (lines.length > 0) {
        let inBlockquote = false;
        const currentLines = [];
        let i;
        for (i = 0; i < lines.length; i++) {
          if (this.rules.other.blockquoteStart.test(lines[i])) {
            currentLines.push(lines[i]);
            inBlockquote = true;
          } else if (!inBlockquote) {
            currentLines.push(lines[i]);
          } else {
            break;
          }
        }
        lines = lines.slice(i);
        const currentRaw = currentLines.join("\n");
        const currentText = currentRaw.replace(this.rules.other.blockquoteSetextReplace, "\n    $1").replace(this.rules.other.blockquoteSetextReplace2, "");
        raw = raw ? `${raw}
${currentRaw}` : currentRaw;
        text = text ? `${text}
${currentText}` : currentText;
        const top = this.lexer.state.top;
        this.lexer.state.top = true;
        this.lexer.blockTokens(currentText, tokens, true);
        this.lexer.state.top = top;
        if (lines.length === 0) {
          break;
        }
        const lastToken = tokens.at(-1);
        if ((lastToken == null ? void 0 : lastToken.type) === "code") {
          break;
        } else if ((lastToken == null ? void 0 : lastToken.type) === "blockquote") {
          const oldToken = lastToken;
          const newText = oldToken.raw + "\n" + lines.join("\n");
          const newToken = this.blockquote(newText);
          tokens[tokens.length - 1] = newToken;
          raw = raw.substring(0, raw.length - oldToken.raw.length) + newToken.raw;
          text = text.substring(0, text.length - oldToken.text.length) + newToken.text;
          break;
        } else if ((lastToken == null ? void 0 : lastToken.type) === "list") {
          const oldToken = lastToken;
          const newText = oldToken.raw + "\n" + lines.join("\n");
          const newToken = this.list(newText);
          tokens[tokens.length - 1] = newToken;
          raw = raw.substring(0, raw.length - lastToken.raw.length) + newToken.raw;
          text = text.substring(0, text.length - oldToken.raw.length) + newToken.raw;
          lines = newText.substring(tokens.at(-1).raw.length).split("\n");
          continue;
        }
      }
      return {
        type: "blockquote",
        raw,
        tokens,
        text
      };
    }
  }
  list(src) {
    let cap = this.rules.block.list.exec(src);
    if (cap) {
      let bull = cap[1].trim();
      const isordered = bull.length > 1;
      const list2 = {
        type: "list",
        raw: "",
        ordered: isordered,
        start: isordered ? +bull.slice(0, -1) : "",
        loose: false,
        items: []
      };
      bull = isordered ? `\\d{1,9}\\${bull.slice(-1)}` : `\\${bull}`;
      if (this.options.pedantic) {
        bull = isordered ? bull : "[*+-]";
      }
      const itemRegex = this.rules.other.listItemRegex(bull);
      let endsWithBlankLine = false;
      while (src) {
        let endEarly = false;
        let raw = "";
        let itemContents = "";
        if (!(cap = itemRegex.exec(src))) {
          break;
        }
        if (this.rules.block.hr.test(src)) {
          break;
        }
        raw = cap[0];
        src = src.substring(raw.length);
        let line = cap[2].split("\n", 1)[0].replace(this.rules.other.listReplaceTabs, (t) => " ".repeat(3 * t.length));
        let nextLine = src.split("\n", 1)[0];
        let blankLine = !line.trim();
        let indent = 0;
        if (this.options.pedantic) {
          indent = 2;
          itemContents = line.trimStart();
        } else if (blankLine) {
          indent = cap[1].length + 1;
        } else {
          indent = cap[2].search(this.rules.other.nonSpaceChar);
          indent = indent > 4 ? 1 : indent;
          itemContents = line.slice(indent);
          indent += cap[1].length;
        }
        if (blankLine && this.rules.other.blankLine.test(nextLine)) {
          raw += nextLine + "\n";
          src = src.substring(nextLine.length + 1);
          endEarly = true;
        }
        if (!endEarly) {
          const nextBulletRegex = this.rules.other.nextBulletRegex(indent);
          const hrRegex = this.rules.other.hrRegex(indent);
          const fencesBeginRegex = this.rules.other.fencesBeginRegex(indent);
          const headingBeginRegex = this.rules.other.headingBeginRegex(indent);
          const htmlBeginRegex = this.rules.other.htmlBeginRegex(indent);
          while (src) {
            const rawLine = src.split("\n", 1)[0];
            let nextLineWithoutTabs;
            nextLine = rawLine;
            if (this.options.pedantic) {
              nextLine = nextLine.replace(this.rules.other.listReplaceNesting, "  ");
              nextLineWithoutTabs = nextLine;
            } else {
              nextLineWithoutTabs = nextLine.replace(this.rules.other.tabCharGlobal, "    ");
            }
            if (fencesBeginRegex.test(nextLine)) {
              break;
            }
            if (headingBeginRegex.test(nextLine)) {
              break;
            }
            if (htmlBeginRegex.test(nextLine)) {
              break;
            }
            if (nextBulletRegex.test(nextLine)) {
              break;
            }
            if (hrRegex.test(nextLine)) {
              break;
            }
            if (nextLineWithoutTabs.search(this.rules.other.nonSpaceChar) >= indent || !nextLine.trim()) {
              itemContents += "\n" + nextLineWithoutTabs.slice(indent);
            } else {
              if (blankLine) {
                break;
              }
              if (line.replace(this.rules.other.tabCharGlobal, "    ").search(this.rules.other.nonSpaceChar) >= 4) {
                break;
              }
              if (fencesBeginRegex.test(line)) {
                break;
              }
              if (headingBeginRegex.test(line)) {
                break;
              }
              if (hrRegex.test(line)) {
                break;
              }
              itemContents += "\n" + nextLine;
            }
            if (!blankLine && !nextLine.trim()) {
              blankLine = true;
            }
            raw += rawLine + "\n";
            src = src.substring(rawLine.length + 1);
            line = nextLineWithoutTabs.slice(indent);
          }
        }
        if (!list2.loose) {
          if (endsWithBlankLine) {
            list2.loose = true;
          } else if (this.rules.other.doubleBlankLine.test(raw)) {
            endsWithBlankLine = true;
          }
        }
        let istask = null;
        let ischecked;
        if (this.options.gfm) {
          istask = this.rules.other.listIsTask.exec(itemContents);
          if (istask) {
            ischecked = istask[0] !== "[ ] ";
            itemContents = itemContents.replace(this.rules.other.listReplaceTask, "");
          }
        }
        list2.items.push({
          type: "list_item",
          raw,
          task: !!istask,
          checked: ischecked,
          loose: false,
          text: itemContents,
          tokens: []
        });
        list2.raw += raw;
      }
      const lastItem = list2.items.at(-1);
      if (lastItem) {
        lastItem.raw = lastItem.raw.trimEnd();
        lastItem.text = lastItem.text.trimEnd();
      } else {
        return;
      }
      list2.raw = list2.raw.trimEnd();
      for (let i = 0; i < list2.items.length; i++) {
        this.lexer.state.top = false;
        list2.items[i].tokens = this.lexer.blockTokens(list2.items[i].text, []);
        if (!list2.loose) {
          const spacers = list2.items[i].tokens.filter((t) => t.type === "space");
          const hasMultipleLineBreaks = spacers.length > 0 && spacers.some((t) => this.rules.other.anyLine.test(t.raw));
          list2.loose = hasMultipleLineBreaks;
        }
      }
      if (list2.loose) {
        for (let i = 0; i < list2.items.length; i++) {
          list2.items[i].loose = true;
        }
      }
      return list2;
    }
  }
  html(src) {
    const cap = this.rules.block.html.exec(src);
    if (cap) {
      const token = {
        type: "html",
        block: true,
        raw: cap[0],
        pre: cap[1] === "pre" || cap[1] === "script" || cap[1] === "style",
        text: cap[0]
      };
      return token;
    }
  }
  def(src) {
    const cap = this.rules.block.def.exec(src);
    if (cap) {
      const tag2 = cap[1].toLowerCase().replace(this.rules.other.multipleSpaceGlobal, " ");
      const href = cap[2] ? cap[2].replace(this.rules.other.hrefBrackets, "$1").replace(this.rules.inline.anyPunctuation, "$1") : "";
      const title = cap[3] ? cap[3].substring(1, cap[3].length - 1).replace(this.rules.inline.anyPunctuation, "$1") : cap[3];
      return {
        type: "def",
        tag: tag2,
        raw: cap[0],
        href,
        title
      };
    }
  }
  table(src) {
    var _a;
    const cap = this.rules.block.table.exec(src);
    if (!cap) {
      return;
    }
    if (!this.rules.other.tableDelimiter.test(cap[2])) {
      return;
    }
    const headers = splitCells(cap[1]);
    const aligns = cap[2].replace(this.rules.other.tableAlignChars, "").split("|");
    const rows = ((_a = cap[3]) == null ? void 0 : _a.trim()) ? cap[3].replace(this.rules.other.tableRowBlankLine, "").split("\n") : [];
    const item = {
      type: "table",
      raw: cap[0],
      header: [],
      align: [],
      rows: []
    };
    if (headers.length !== aligns.length) {
      return;
    }
    for (const align of aligns) {
      if (this.rules.other.tableAlignRight.test(align)) {
        item.align.push("right");
      } else if (this.rules.other.tableAlignCenter.test(align)) {
        item.align.push("center");
      } else if (this.rules.other.tableAlignLeft.test(align)) {
        item.align.push("left");
      } else {
        item.align.push(null);
      }
    }
    for (let i = 0; i < headers.length; i++) {
      item.header.push({
        text: headers[i],
        tokens: this.lexer.inline(headers[i]),
        header: true,
        align: item.align[i]
      });
    }
    for (const row of rows) {
      item.rows.push(splitCells(row, item.header.length).map((cell, i) => {
        return {
          text: cell,
          tokens: this.lexer.inline(cell),
          header: false,
          align: item.align[i]
        };
      }));
    }
    return item;
  }
  lheading(src) {
    const cap = this.rules.block.lheading.exec(src);
    if (cap) {
      return {
        type: "heading",
        raw: cap[0],
        depth: cap[2].charAt(0) === "=" ? 1 : 2,
        text: cap[1],
        tokens: this.lexer.inline(cap[1])
      };
    }
  }
  paragraph(src) {
    const cap = this.rules.block.paragraph.exec(src);
    if (cap) {
      const text = cap[1].charAt(cap[1].length - 1) === "\n" ? cap[1].slice(0, -1) : cap[1];
      return {
        type: "paragraph",
        raw: cap[0],
        text,
        tokens: this.lexer.inline(text)
      };
    }
  }
  text(src) {
    const cap = this.rules.block.text.exec(src);
    if (cap) {
      return {
        type: "text",
        raw: cap[0],
        text: cap[0],
        tokens: this.lexer.inline(cap[0])
      };
    }
  }
  escape(src) {
    const cap = this.rules.inline.escape.exec(src);
    if (cap) {
      return {
        type: "escape",
        raw: cap[0],
        text: cap[1]
      };
    }
  }
  tag(src) {
    const cap = this.rules.inline.tag.exec(src);
    if (cap) {
      if (!this.lexer.state.inLink && this.rules.other.startATag.test(cap[0])) {
        this.lexer.state.inLink = true;
      } else if (this.lexer.state.inLink && this.rules.other.endATag.test(cap[0])) {
        this.lexer.state.inLink = false;
      }
      if (!this.lexer.state.inRawBlock && this.rules.other.startPreScriptTag.test(cap[0])) {
        this.lexer.state.inRawBlock = true;
      } else if (this.lexer.state.inRawBlock && this.rules.other.endPreScriptTag.test(cap[0])) {
        this.lexer.state.inRawBlock = false;
      }
      return {
        type: "html",
        raw: cap[0],
        inLink: this.lexer.state.inLink,
        inRawBlock: this.lexer.state.inRawBlock,
        block: false,
        text: cap[0]
      };
    }
  }
  link(src) {
    const cap = this.rules.inline.link.exec(src);
    if (cap) {
      const trimmedUrl = cap[2].trim();
      if (!this.options.pedantic && this.rules.other.startAngleBracket.test(trimmedUrl)) {
        if (!this.rules.other.endAngleBracket.test(trimmedUrl)) {
          return;
        }
        const rtrimSlash = rtrim(trimmedUrl.slice(0, -1), "\\");
        if ((trimmedUrl.length - rtrimSlash.length) % 2 === 0) {
          return;
        }
      } else {
        const lastParenIndex = findClosingBracket(cap[2], "()");
        if (lastParenIndex > -1) {
          const start = cap[0].indexOf("!") === 0 ? 5 : 4;
          const linkLen = start + cap[1].length + lastParenIndex;
          cap[2] = cap[2].substring(0, lastParenIndex);
          cap[0] = cap[0].substring(0, linkLen).trim();
          cap[3] = "";
        }
      }
      let href = cap[2];
      let title = "";
      if (this.options.pedantic) {
        const link2 = this.rules.other.pedanticHrefTitle.exec(href);
        if (link2) {
          href = link2[1];
          title = link2[3];
        }
      } else {
        title = cap[3] ? cap[3].slice(1, -1) : "";
      }
      href = href.trim();
      if (this.rules.other.startAngleBracket.test(href)) {
        if (this.options.pedantic && !this.rules.other.endAngleBracket.test(trimmedUrl)) {
          href = href.slice(1);
        } else {
          href = href.slice(1, -1);
        }
      }
      return outputLink(cap, {
        href: href ? href.replace(this.rules.inline.anyPunctuation, "$1") : href,
        title: title ? title.replace(this.rules.inline.anyPunctuation, "$1") : title
      }, cap[0], this.lexer, this.rules);
    }
  }
  reflink(src, links) {
    let cap;
    if ((cap = this.rules.inline.reflink.exec(src)) || (cap = this.rules.inline.nolink.exec(src))) {
      const linkString = (cap[2] || cap[1]).replace(this.rules.other.multipleSpaceGlobal, " ");
      const link2 = links[linkString.toLowerCase()];
      if (!link2) {
        const text = cap[0].charAt(0);
        return {
          type: "text",
          raw: text,
          text
        };
      }
      return outputLink(cap, link2, cap[0], this.lexer, this.rules);
    }
  }
  emStrong(src, maskedSrc, prevChar = "") {
    let match = this.rules.inline.emStrongLDelim.exec(src);
    if (!match)
      return;
    if (match[3] && prevChar.match(this.rules.other.unicodeAlphaNumeric))
      return;
    const nextChar = match[1] || match[2] || "";
    if (!nextChar || !prevChar || this.rules.inline.punctuation.exec(prevChar)) {
      const lLength = [...match[0]].length - 1;
      let rDelim, rLength, delimTotal = lLength, midDelimTotal = 0;
      const endReg = match[0][0] === "*" ? this.rules.inline.emStrongRDelimAst : this.rules.inline.emStrongRDelimUnd;
      endReg.lastIndex = 0;
      maskedSrc = maskedSrc.slice(-1 * src.length + lLength);
      while ((match = endReg.exec(maskedSrc)) != null) {
        rDelim = match[1] || match[2] || match[3] || match[4] || match[5] || match[6];
        if (!rDelim)
          continue;
        rLength = [...rDelim].length;
        if (match[3] || match[4]) {
          delimTotal += rLength;
          continue;
        } else if (match[5] || match[6]) {
          if (lLength % 3 && !((lLength + rLength) % 3)) {
            midDelimTotal += rLength;
            continue;
          }
        }
        delimTotal -= rLength;
        if (delimTotal > 0)
          continue;
        rLength = Math.min(rLength, rLength + delimTotal + midDelimTotal);
        const lastCharLength = [...match[0]][0].length;
        const raw = src.slice(0, lLength + match.index + lastCharLength + rLength);
        if (Math.min(lLength, rLength) % 2) {
          const text2 = raw.slice(1, -1);
          return {
            type: "em",
            raw,
            text: text2,
            tokens: this.lexer.inlineTokens(text2)
          };
        }
        const text = raw.slice(2, -2);
        return {
          type: "strong",
          raw,
          text,
          tokens: this.lexer.inlineTokens(text)
        };
      }
    }
  }
  codespan(src) {
    const cap = this.rules.inline.code.exec(src);
    if (cap) {
      let text = cap[2].replace(this.rules.other.newLineCharGlobal, " ");
      const hasNonSpaceChars = this.rules.other.nonSpaceChar.test(text);
      const hasSpaceCharsOnBothEnds = this.rules.other.startingSpaceChar.test(text) && this.rules.other.endingSpaceChar.test(text);
      if (hasNonSpaceChars && hasSpaceCharsOnBothEnds) {
        text = text.substring(1, text.length - 1);
      }
      return {
        type: "codespan",
        raw: cap[0],
        text
      };
    }
  }
  br(src) {
    const cap = this.rules.inline.br.exec(src);
    if (cap) {
      return {
        type: "br",
        raw: cap[0]
      };
    }
  }
  del(src) {
    const cap = this.rules.inline.del.exec(src);
    if (cap) {
      return {
        type: "del",
        raw: cap[0],
        text: cap[2],
        tokens: this.lexer.inlineTokens(cap[2])
      };
    }
  }
  autolink(src) {
    const cap = this.rules.inline.autolink.exec(src);
    if (cap) {
      let text, href;
      if (cap[2] === "@") {
        text = cap[1];
        href = "mailto:" + text;
      } else {
        text = cap[1];
        href = text;
      }
      return {
        type: "link",
        raw: cap[0],
        text,
        href,
        tokens: [
          {
            type: "text",
            raw: text,
            text
          }
        ]
      };
    }
  }
  url(src) {
    var _a, _b;
    let cap;
    if (cap = this.rules.inline.url.exec(src)) {
      let text, href;
      if (cap[2] === "@") {
        text = cap[0];
        href = "mailto:" + text;
      } else {
        let prevCapZero;
        do {
          prevCapZero = cap[0];
          cap[0] = (_b = (_a = this.rules.inline._backpedal.exec(cap[0])) == null ? void 0 : _a[0]) != null ? _b : "";
        } while (prevCapZero !== cap[0]);
        text = cap[0];
        if (cap[1] === "www.") {
          href = "http://" + cap[0];
        } else {
          href = cap[0];
        }
      }
      return {
        type: "link",
        raw: cap[0],
        text,
        href,
        tokens: [
          {
            type: "text",
            raw: text,
            text
          }
        ]
      };
    }
  }
  inlineText(src) {
    const cap = this.rules.inline.text.exec(src);
    if (cap) {
      const escaped = this.lexer.state.inRawBlock;
      return {
        type: "text",
        raw: cap[0],
        text: cap[0],
        escaped
      };
    }
  }
};
var _Lexer = class __Lexer {
  constructor(options2) {
    __publicField(this, "tokens");
    __publicField(this, "options");
    __publicField(this, "state");
    __publicField(this, "tokenizer");
    __publicField(this, "inlineQueue");
    this.tokens = [];
    this.tokens.links = /* @__PURE__ */ Object.create(null);
    this.options = options2 || _defaults;
    this.options.tokenizer = this.options.tokenizer || new _Tokenizer();
    this.tokenizer = this.options.tokenizer;
    this.tokenizer.options = this.options;
    this.tokenizer.lexer = this;
    this.inlineQueue = [];
    this.state = {
      inLink: false,
      inRawBlock: false,
      top: true
    };
    const rules = {
      other,
      block: block.normal,
      inline: inline.normal
    };
    if (this.options.pedantic) {
      rules.block = block.pedantic;
      rules.inline = inline.pedantic;
    } else if (this.options.gfm) {
      rules.block = block.gfm;
      if (this.options.breaks) {
        rules.inline = inline.breaks;
      } else {
        rules.inline = inline.gfm;
      }
    }
    this.tokenizer.rules = rules;
  }
  /**
   * Expose Rules
   */
  static get rules() {
    return {
      block,
      inline
    };
  }
  /**
   * Static Lex Method
   */
  static lex(src, options2) {
    const lexer2 = new __Lexer(options2);
    return lexer2.lex(src);
  }
  /**
   * Static Lex Inline Method
   */
  static lexInline(src, options2) {
    const lexer2 = new __Lexer(options2);
    return lexer2.inlineTokens(src);
  }
  /**
   * Preprocessing
   */
  lex(src) {
    src = src.replace(other.carriageReturn, "\n");
    this.blockTokens(src, this.tokens);
    for (let i = 0; i < this.inlineQueue.length; i++) {
      const next = this.inlineQueue[i];
      this.inlineTokens(next.src, next.tokens);
    }
    this.inlineQueue = [];
    return this.tokens;
  }
  blockTokens(src, tokens = [], lastParagraphClipped = false) {
    var _a, _b, _c;
    if (this.options.pedantic) {
      src = src.replace(other.tabCharGlobal, "    ").replace(other.spaceLine, "");
    }
    while (src) {
      let token;
      if ((_b = (_a = this.options.extensions) == null ? void 0 : _a.block) == null ? void 0 : _b.some((extTokenizer) => {
        if (token = extTokenizer.call({ lexer: this }, src, tokens)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          return true;
        }
        return false;
      })) {
        continue;
      }
      if (token = this.tokenizer.space(src)) {
        src = src.substring(token.raw.length);
        const lastToken = tokens.at(-1);
        if (token.raw.length === 1 && lastToken !== void 0) {
          lastToken.raw += "\n";
        } else {
          tokens.push(token);
        }
        continue;
      }
      if (token = this.tokenizer.code(src)) {
        src = src.substring(token.raw.length);
        const lastToken = tokens.at(-1);
        if ((lastToken == null ? void 0 : lastToken.type) === "paragraph" || (lastToken == null ? void 0 : lastToken.type) === "text") {
          lastToken.raw += "\n" + token.raw;
          lastToken.text += "\n" + token.text;
          this.inlineQueue.at(-1).src = lastToken.text;
        } else {
          tokens.push(token);
        }
        continue;
      }
      if (token = this.tokenizer.fences(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.heading(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.hr(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.blockquote(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.list(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.html(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.def(src)) {
        src = src.substring(token.raw.length);
        const lastToken = tokens.at(-1);
        if ((lastToken == null ? void 0 : lastToken.type) === "paragraph" || (lastToken == null ? void 0 : lastToken.type) === "text") {
          lastToken.raw += "\n" + token.raw;
          lastToken.text += "\n" + token.raw;
          this.inlineQueue.at(-1).src = lastToken.text;
        } else if (!this.tokens.links[token.tag]) {
          this.tokens.links[token.tag] = {
            href: token.href,
            title: token.title
          };
        }
        continue;
      }
      if (token = this.tokenizer.table(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.lheading(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      let cutSrc = src;
      if ((_c = this.options.extensions) == null ? void 0 : _c.startBlock) {
        let startIndex = Infinity;
        const tempSrc = src.slice(1);
        let tempStart;
        this.options.extensions.startBlock.forEach((getStartIndex) => {
          tempStart = getStartIndex.call({ lexer: this }, tempSrc);
          if (typeof tempStart === "number" && tempStart >= 0) {
            startIndex = Math.min(startIndex, tempStart);
          }
        });
        if (startIndex < Infinity && startIndex >= 0) {
          cutSrc = src.substring(0, startIndex + 1);
        }
      }
      if (this.state.top && (token = this.tokenizer.paragraph(cutSrc))) {
        const lastToken = tokens.at(-1);
        if (lastParagraphClipped && (lastToken == null ? void 0 : lastToken.type) === "paragraph") {
          lastToken.raw += "\n" + token.raw;
          lastToken.text += "\n" + token.text;
          this.inlineQueue.pop();
          this.inlineQueue.at(-1).src = lastToken.text;
        } else {
          tokens.push(token);
        }
        lastParagraphClipped = cutSrc.length !== src.length;
        src = src.substring(token.raw.length);
        continue;
      }
      if (token = this.tokenizer.text(src)) {
        src = src.substring(token.raw.length);
        const lastToken = tokens.at(-1);
        if ((lastToken == null ? void 0 : lastToken.type) === "text") {
          lastToken.raw += "\n" + token.raw;
          lastToken.text += "\n" + token.text;
          this.inlineQueue.pop();
          this.inlineQueue.at(-1).src = lastToken.text;
        } else {
          tokens.push(token);
        }
        continue;
      }
      if (src) {
        const errMsg = "Infinite loop on byte: " + src.charCodeAt(0);
        if (this.options.silent) {
          console.error(errMsg);
          break;
        } else {
          throw new Error(errMsg);
        }
      }
    }
    this.state.top = true;
    return tokens;
  }
  inline(src, tokens = []) {
    this.inlineQueue.push({ src, tokens });
    return tokens;
  }
  /**
   * Lexing/Compiling
   */
  inlineTokens(src, tokens = []) {
    var _a, _b, _c;
    let maskedSrc = src;
    let match = null;
    if (this.tokens.links) {
      const links = Object.keys(this.tokens.links);
      if (links.length > 0) {
        while ((match = this.tokenizer.rules.inline.reflinkSearch.exec(maskedSrc)) != null) {
          if (links.includes(match[0].slice(match[0].lastIndexOf("[") + 1, -1))) {
            maskedSrc = maskedSrc.slice(0, match.index) + "[" + "a".repeat(match[0].length - 2) + "]" + maskedSrc.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex);
          }
        }
      }
    }
    while ((match = this.tokenizer.rules.inline.blockSkip.exec(maskedSrc)) != null) {
      maskedSrc = maskedSrc.slice(0, match.index) + "[" + "a".repeat(match[0].length - 2) + "]" + maskedSrc.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);
    }
    while ((match = this.tokenizer.rules.inline.anyPunctuation.exec(maskedSrc)) != null) {
      maskedSrc = maskedSrc.slice(0, match.index) + "++" + maskedSrc.slice(this.tokenizer.rules.inline.anyPunctuation.lastIndex);
    }
    let keepPrevChar = false;
    let prevChar = "";
    while (src) {
      if (!keepPrevChar) {
        prevChar = "";
      }
      keepPrevChar = false;
      let token;
      if ((_b = (_a = this.options.extensions) == null ? void 0 : _a.inline) == null ? void 0 : _b.some((extTokenizer) => {
        if (token = extTokenizer.call({ lexer: this }, src, tokens)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          return true;
        }
        return false;
      })) {
        continue;
      }
      if (token = this.tokenizer.escape(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.tag(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.link(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.reflink(src, this.tokens.links)) {
        src = src.substring(token.raw.length);
        const lastToken = tokens.at(-1);
        if (token.type === "text" && (lastToken == null ? void 0 : lastToken.type) === "text") {
          lastToken.raw += token.raw;
          lastToken.text += token.text;
        } else {
          tokens.push(token);
        }
        continue;
      }
      if (token = this.tokenizer.emStrong(src, maskedSrc, prevChar)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.codespan(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.br(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.del(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.autolink(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (!this.state.inLink && (token = this.tokenizer.url(src))) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      let cutSrc = src;
      if ((_c = this.options.extensions) == null ? void 0 : _c.startInline) {
        let startIndex = Infinity;
        const tempSrc = src.slice(1);
        let tempStart;
        this.options.extensions.startInline.forEach((getStartIndex) => {
          tempStart = getStartIndex.call({ lexer: this }, tempSrc);
          if (typeof tempStart === "number" && tempStart >= 0) {
            startIndex = Math.min(startIndex, tempStart);
          }
        });
        if (startIndex < Infinity && startIndex >= 0) {
          cutSrc = src.substring(0, startIndex + 1);
        }
      }
      if (token = this.tokenizer.inlineText(cutSrc)) {
        src = src.substring(token.raw.length);
        if (token.raw.slice(-1) !== "_") {
          prevChar = token.raw.slice(-1);
        }
        keepPrevChar = true;
        const lastToken = tokens.at(-1);
        if ((lastToken == null ? void 0 : lastToken.type) === "text") {
          lastToken.raw += token.raw;
          lastToken.text += token.text;
        } else {
          tokens.push(token);
        }
        continue;
      }
      if (src) {
        const errMsg = "Infinite loop on byte: " + src.charCodeAt(0);
        if (this.options.silent) {
          console.error(errMsg);
          break;
        } else {
          throw new Error(errMsg);
        }
      }
    }
    return tokens;
  }
};
var _Renderer = class {
  // set by the parser
  constructor(options2) {
    __publicField(this, "options");
    __publicField(this, "parser");
    this.options = options2 || _defaults;
  }
  space(token) {
    return "";
  }
  code({ text, lang, escaped }) {
    var _a;
    const langString = (_a = (lang || "").match(other.notSpaceStart)) == null ? void 0 : _a[0];
    const code = text.replace(other.endingNewline, "") + "\n";
    if (!langString) {
      return "<pre><code>" + (escaped ? code : escape(code, true)) + "</code></pre>\n";
    }
    return '<pre><code class="language-' + escape(langString) + '">' + (escaped ? code : escape(code, true)) + "</code></pre>\n";
  }
  blockquote({ tokens }) {
    const body = this.parser.parse(tokens);
    return `<blockquote>
${body}</blockquote>
`;
  }
  html({ text }) {
    return text;
  }
  heading({ tokens, depth }) {
    return `<h${depth}>${this.parser.parseInline(tokens)}</h${depth}>
`;
  }
  hr(token) {
    return "<hr>\n";
  }
  list(token) {
    const ordered = token.ordered;
    const start = token.start;
    let body = "";
    for (let j = 0; j < token.items.length; j++) {
      const item = token.items[j];
      body += this.listitem(item);
    }
    const type = ordered ? "ol" : "ul";
    const startAttr = ordered && start !== 1 ? ' start="' + start + '"' : "";
    return "<" + type + startAttr + ">\n" + body + "</" + type + ">\n";
  }
  listitem(item) {
    var _a;
    let itemBody = "";
    if (item.task) {
      const checkbox = this.checkbox({ checked: !!item.checked });
      if (item.loose) {
        if (((_a = item.tokens[0]) == null ? void 0 : _a.type) === "paragraph") {
          item.tokens[0].text = checkbox + " " + item.tokens[0].text;
          if (item.tokens[0].tokens && item.tokens[0].tokens.length > 0 && item.tokens[0].tokens[0].type === "text") {
            item.tokens[0].tokens[0].text = checkbox + " " + escape(item.tokens[0].tokens[0].text);
            item.tokens[0].tokens[0].escaped = true;
          }
        } else {
          item.tokens.unshift({
            type: "text",
            raw: checkbox + " ",
            text: checkbox + " ",
            escaped: true
          });
        }
      } else {
        itemBody += checkbox + " ";
      }
    }
    itemBody += this.parser.parse(item.tokens, !!item.loose);
    return `<li>${itemBody}</li>
`;
  }
  checkbox({ checked }) {
    return "<input " + (checked ? 'checked="" ' : "") + 'disabled="" type="checkbox">';
  }
  paragraph({ tokens }) {
    return `<p>${this.parser.parseInline(tokens)}</p>
`;
  }
  table(token) {
    let header = "";
    let cell = "";
    for (let j = 0; j < token.header.length; j++) {
      cell += this.tablecell(token.header[j]);
    }
    header += this.tablerow({ text: cell });
    let body = "";
    for (let j = 0; j < token.rows.length; j++) {
      const row = token.rows[j];
      cell = "";
      for (let k = 0; k < row.length; k++) {
        cell += this.tablecell(row[k]);
      }
      body += this.tablerow({ text: cell });
    }
    if (body)
      body = `<tbody>${body}</tbody>`;
    return "<table>\n<thead>\n" + header + "</thead>\n" + body + "</table>\n";
  }
  tablerow({ text }) {
    return `<tr>
${text}</tr>
`;
  }
  tablecell(token) {
    const content = this.parser.parseInline(token.tokens);
    const type = token.header ? "th" : "td";
    const tag2 = token.align ? `<${type} align="${token.align}">` : `<${type}>`;
    return tag2 + content + `</${type}>
`;
  }
  /**
   * span level renderer
   */
  strong({ tokens }) {
    return `<strong>${this.parser.parseInline(tokens)}</strong>`;
  }
  em({ tokens }) {
    return `<em>${this.parser.parseInline(tokens)}</em>`;
  }
  codespan({ text }) {
    return `<code>${escape(text, true)}</code>`;
  }
  br(token) {
    return "<br>";
  }
  del({ tokens }) {
    return `<del>${this.parser.parseInline(tokens)}</del>`;
  }
  link({ href, title, tokens }) {
    const text = this.parser.parseInline(tokens);
    const cleanHref = cleanUrl(href);
    if (cleanHref === null) {
      return text;
    }
    href = cleanHref;
    let out = '<a href="' + href + '"';
    if (title) {
      out += ' title="' + escape(title) + '"';
    }
    out += ">" + text + "</a>";
    return out;
  }
  image({ href, title, text }) {
    const cleanHref = cleanUrl(href);
    if (cleanHref === null) {
      return escape(text);
    }
    href = cleanHref;
    let out = `<img src="${href}" alt="${text}"`;
    if (title) {
      out += ` title="${escape(title)}"`;
    }
    out += ">";
    return out;
  }
  text(token) {
    return "tokens" in token && token.tokens ? this.parser.parseInline(token.tokens) : "escaped" in token && token.escaped ? token.text : escape(token.text);
  }
};
var _TextRenderer = class {
  // no need for block level renderers
  strong({ text }) {
    return text;
  }
  em({ text }) {
    return text;
  }
  codespan({ text }) {
    return text;
  }
  del({ text }) {
    return text;
  }
  html({ text }) {
    return text;
  }
  text({ text }) {
    return text;
  }
  link({ text }) {
    return "" + text;
  }
  image({ text }) {
    return "" + text;
  }
  br() {
    return "";
  }
};
var _Parser = class __Parser {
  constructor(options2) {
    __publicField(this, "options");
    __publicField(this, "renderer");
    __publicField(this, "textRenderer");
    this.options = options2 || _defaults;
    this.options.renderer = this.options.renderer || new _Renderer();
    this.renderer = this.options.renderer;
    this.renderer.options = this.options;
    this.renderer.parser = this;
    this.textRenderer = new _TextRenderer();
  }
  /**
   * Static Parse Method
   */
  static parse(tokens, options2) {
    const parser2 = new __Parser(options2);
    return parser2.parse(tokens);
  }
  /**
   * Static Parse Inline Method
   */
  static parseInline(tokens, options2) {
    const parser2 = new __Parser(options2);
    return parser2.parseInline(tokens);
  }
  /**
   * Parse Loop
   */
  parse(tokens, top = true) {
    var _a, _b;
    let out = "";
    for (let i = 0; i < tokens.length; i++) {
      const anyToken = tokens[i];
      if ((_b = (_a = this.options.extensions) == null ? void 0 : _a.renderers) == null ? void 0 : _b[anyToken.type]) {
        const genericToken = anyToken;
        const ret = this.options.extensions.renderers[genericToken.type].call({ parser: this }, genericToken);
        if (ret !== false || !["space", "hr", "heading", "code", "table", "blockquote", "list", "html", "paragraph", "text"].includes(genericToken.type)) {
          out += ret || "";
          continue;
        }
      }
      const token = anyToken;
      switch (token.type) {
        case "space": {
          out += this.renderer.space(token);
          continue;
        }
        case "hr": {
          out += this.renderer.hr(token);
          continue;
        }
        case "heading": {
          out += this.renderer.heading(token);
          continue;
        }
        case "code": {
          out += this.renderer.code(token);
          continue;
        }
        case "table": {
          out += this.renderer.table(token);
          continue;
        }
        case "blockquote": {
          out += this.renderer.blockquote(token);
          continue;
        }
        case "list": {
          out += this.renderer.list(token);
          continue;
        }
        case "html": {
          out += this.renderer.html(token);
          continue;
        }
        case "paragraph": {
          out += this.renderer.paragraph(token);
          continue;
        }
        case "text": {
          let textToken = token;
          let body = this.renderer.text(textToken);
          while (i + 1 < tokens.length && tokens[i + 1].type === "text") {
            textToken = tokens[++i];
            body += "\n" + this.renderer.text(textToken);
          }
          if (top) {
            out += this.renderer.paragraph({
              type: "paragraph",
              raw: body,
              text: body,
              tokens: [{ type: "text", raw: body, text: body, escaped: true }]
            });
          } else {
            out += body;
          }
          continue;
        }
        default: {
          const errMsg = 'Token with "' + token.type + '" type was not found.';
          if (this.options.silent) {
            console.error(errMsg);
            return "";
          } else {
            throw new Error(errMsg);
          }
        }
      }
    }
    return out;
  }
  /**
   * Parse Inline Tokens
   */
  parseInline(tokens, renderer = this.renderer) {
    var _a, _b;
    let out = "";
    for (let i = 0; i < tokens.length; i++) {
      const anyToken = tokens[i];
      if ((_b = (_a = this.options.extensions) == null ? void 0 : _a.renderers) == null ? void 0 : _b[anyToken.type]) {
        const ret = this.options.extensions.renderers[anyToken.type].call({ parser: this }, anyToken);
        if (ret !== false || !["escape", "html", "link", "image", "strong", "em", "codespan", "br", "del", "text"].includes(anyToken.type)) {
          out += ret || "";
          continue;
        }
      }
      const token = anyToken;
      switch (token.type) {
        case "escape": {
          out += renderer.text(token);
          break;
        }
        case "html": {
          out += renderer.html(token);
          break;
        }
        case "link": {
          out += renderer.link(token);
          break;
        }
        case "image": {
          out += renderer.image(token);
          break;
        }
        case "strong": {
          out += renderer.strong(token);
          break;
        }
        case "em": {
          out += renderer.em(token);
          break;
        }
        case "codespan": {
          out += renderer.codespan(token);
          break;
        }
        case "br": {
          out += renderer.br(token);
          break;
        }
        case "del": {
          out += renderer.del(token);
          break;
        }
        case "text": {
          out += renderer.text(token);
          break;
        }
        default: {
          const errMsg = 'Token with "' + token.type + '" type was not found.';
          if (this.options.silent) {
            console.error(errMsg);
            return "";
          } else {
            throw new Error(errMsg);
          }
        }
      }
    }
    return out;
  }
};
var _Hooks = class {
  constructor(options2) {
    __publicField(this, "options");
    __publicField(this, "block");
    this.options = options2 || _defaults;
  }
  /**
   * Process markdown before marked
   */
  preprocess(markdown) {
    return markdown;
  }
  /**
   * Process HTML after marked is finished
   */
  postprocess(html2) {
    return html2;
  }
  /**
   * Process all tokens before walk tokens
   */
  processAllTokens(tokens) {
    return tokens;
  }
  /**
   * Provide function to tokenize markdown
   */
  provideLexer() {
    return this.block ? _Lexer.lex : _Lexer.lexInline;
  }
  /**
   * Provide function to parse tokens
   */
  provideParser() {
    return this.block ? _Parser.parse : _Parser.parseInline;
  }
};
__publicField(_Hooks, "passThroughHooks", /* @__PURE__ */ new Set([
  "preprocess",
  "postprocess",
  "processAllTokens"
]));
var Marked = class {
  constructor(...args) {
    __publicField(this, "defaults", _getDefaults());
    __publicField(this, "options", this.setOptions);
    __publicField(this, "parse", this.parseMarkdown(true));
    __publicField(this, "parseInline", this.parseMarkdown(false));
    __publicField(this, "Parser", _Parser);
    __publicField(this, "Renderer", _Renderer);
    __publicField(this, "TextRenderer", _TextRenderer);
    __publicField(this, "Lexer", _Lexer);
    __publicField(this, "Tokenizer", _Tokenizer);
    __publicField(this, "Hooks", _Hooks);
    this.use(...args);
  }
  /**
   * Run callback for every token
   */
  walkTokens(tokens, callback) {
    var _a, _b;
    let values = [];
    for (const token of tokens) {
      values = values.concat(callback.call(this, token));
      switch (token.type) {
        case "table": {
          const tableToken = token;
          for (const cell of tableToken.header) {
            values = values.concat(this.walkTokens(cell.tokens, callback));
          }
          for (const row of tableToken.rows) {
            for (const cell of row) {
              values = values.concat(this.walkTokens(cell.tokens, callback));
            }
          }
          break;
        }
        case "list": {
          const listToken = token;
          values = values.concat(this.walkTokens(listToken.items, callback));
          break;
        }
        default: {
          const genericToken = token;
          if ((_b = (_a = this.defaults.extensions) == null ? void 0 : _a.childTokens) == null ? void 0 : _b[genericToken.type]) {
            this.defaults.extensions.childTokens[genericToken.type].forEach((childTokens) => {
              const tokens2 = genericToken[childTokens].flat(Infinity);
              values = values.concat(this.walkTokens(tokens2, callback));
            });
          } else if (genericToken.tokens) {
            values = values.concat(this.walkTokens(genericToken.tokens, callback));
          }
        }
      }
    }
    return values;
  }
  use(...args) {
    const extensions = this.defaults.extensions || { renderers: {}, childTokens: {} };
    args.forEach((pack) => {
      const opts = __spreadValues({}, pack);
      opts.async = this.defaults.async || opts.async || false;
      if (pack.extensions) {
        pack.extensions.forEach((ext) => {
          if (!ext.name) {
            throw new Error("extension name required");
          }
          if ("renderer" in ext) {
            const prevRenderer = extensions.renderers[ext.name];
            if (prevRenderer) {
              extensions.renderers[ext.name] = function(...args2) {
                let ret = ext.renderer.apply(this, args2);
                if (ret === false) {
                  ret = prevRenderer.apply(this, args2);
                }
                return ret;
              };
            } else {
              extensions.renderers[ext.name] = ext.renderer;
            }
          }
          if ("tokenizer" in ext) {
            if (!ext.level || ext.level !== "block" && ext.level !== "inline") {
              throw new Error("extension level must be 'block' or 'inline'");
            }
            const extLevel = extensions[ext.level];
            if (extLevel) {
              extLevel.unshift(ext.tokenizer);
            } else {
              extensions[ext.level] = [ext.tokenizer];
            }
            if (ext.start) {
              if (ext.level === "block") {
                if (extensions.startBlock) {
                  extensions.startBlock.push(ext.start);
                } else {
                  extensions.startBlock = [ext.start];
                }
              } else if (ext.level === "inline") {
                if (extensions.startInline) {
                  extensions.startInline.push(ext.start);
                } else {
                  extensions.startInline = [ext.start];
                }
              }
            }
          }
          if ("childTokens" in ext && ext.childTokens) {
            extensions.childTokens[ext.name] = ext.childTokens;
          }
        });
        opts.extensions = extensions;
      }
      if (pack.renderer) {
        const renderer = this.defaults.renderer || new _Renderer(this.defaults);
        for (const prop in pack.renderer) {
          if (!(prop in renderer)) {
            throw new Error(`renderer '${prop}' does not exist`);
          }
          if (["options", "parser"].includes(prop)) {
            continue;
          }
          const rendererProp = prop;
          const rendererFunc = pack.renderer[rendererProp];
          const prevRenderer = renderer[rendererProp];
          renderer[rendererProp] = (...args2) => {
            let ret = rendererFunc.apply(renderer, args2);
            if (ret === false) {
              ret = prevRenderer.apply(renderer, args2);
            }
            return ret || "";
          };
        }
        opts.renderer = renderer;
      }
      if (pack.tokenizer) {
        const tokenizer = this.defaults.tokenizer || new _Tokenizer(this.defaults);
        for (const prop in pack.tokenizer) {
          if (!(prop in tokenizer)) {
            throw new Error(`tokenizer '${prop}' does not exist`);
          }
          if (["options", "rules", "lexer"].includes(prop)) {
            continue;
          }
          const tokenizerProp = prop;
          const tokenizerFunc = pack.tokenizer[tokenizerProp];
          const prevTokenizer = tokenizer[tokenizerProp];
          tokenizer[tokenizerProp] = (...args2) => {
            let ret = tokenizerFunc.apply(tokenizer, args2);
            if (ret === false) {
              ret = prevTokenizer.apply(tokenizer, args2);
            }
            return ret;
          };
        }
        opts.tokenizer = tokenizer;
      }
      if (pack.hooks) {
        const hooks = this.defaults.hooks || new _Hooks();
        for (const prop in pack.hooks) {
          if (!(prop in hooks)) {
            throw new Error(`hook '${prop}' does not exist`);
          }
          if (["options", "block"].includes(prop)) {
            continue;
          }
          const hooksProp = prop;
          const hooksFunc = pack.hooks[hooksProp];
          const prevHook = hooks[hooksProp];
          if (_Hooks.passThroughHooks.has(prop)) {
            hooks[hooksProp] = (arg) => {
              if (this.defaults.async) {
                return Promise.resolve(hooksFunc.call(hooks, arg)).then((ret2) => {
                  return prevHook.call(hooks, ret2);
                });
              }
              const ret = hooksFunc.call(hooks, arg);
              return prevHook.call(hooks, ret);
            };
          } else {
            hooks[hooksProp] = (...args2) => {
              let ret = hooksFunc.apply(hooks, args2);
              if (ret === false) {
                ret = prevHook.apply(hooks, args2);
              }
              return ret;
            };
          }
        }
        opts.hooks = hooks;
      }
      if (pack.walkTokens) {
        const walkTokens2 = this.defaults.walkTokens;
        const packWalktokens = pack.walkTokens;
        opts.walkTokens = function(token) {
          let values = [];
          values.push(packWalktokens.call(this, token));
          if (walkTokens2) {
            values = values.concat(walkTokens2.call(this, token));
          }
          return values;
        };
      }
      this.defaults = __spreadValues(__spreadValues({}, this.defaults), opts);
    });
    return this;
  }
  setOptions(opt) {
    this.defaults = __spreadValues(__spreadValues({}, this.defaults), opt);
    return this;
  }
  lexer(src, options2) {
    return _Lexer.lex(src, options2 != null ? options2 : this.defaults);
  }
  parser(tokens, options2) {
    return _Parser.parse(tokens, options2 != null ? options2 : this.defaults);
  }
  parseMarkdown(blockType) {
    const parse = (src, options2) => {
      const origOpt = __spreadValues({}, options2);
      const opt = __spreadValues(__spreadValues({}, this.defaults), origOpt);
      const throwError = this.onError(!!opt.silent, !!opt.async);
      if (this.defaults.async === true && origOpt.async === false) {
        return throwError(new Error("marked(): The async option was set to true by an extension. Remove async: false from the parse options object to return a Promise."));
      }
      if (typeof src === "undefined" || src === null) {
        return throwError(new Error("marked(): input parameter is undefined or null"));
      }
      if (typeof src !== "string") {
        return throwError(new Error("marked(): input parameter is of type " + Object.prototype.toString.call(src) + ", string expected"));
      }
      if (opt.hooks) {
        opt.hooks.options = opt;
        opt.hooks.block = blockType;
      }
      const lexer2 = opt.hooks ? opt.hooks.provideLexer() : blockType ? _Lexer.lex : _Lexer.lexInline;
      const parser2 = opt.hooks ? opt.hooks.provideParser() : blockType ? _Parser.parse : _Parser.parseInline;
      if (opt.async) {
        return Promise.resolve(opt.hooks ? opt.hooks.preprocess(src) : src).then((src2) => lexer2(src2, opt)).then((tokens) => opt.hooks ? opt.hooks.processAllTokens(tokens) : tokens).then((tokens) => opt.walkTokens ? Promise.all(this.walkTokens(tokens, opt.walkTokens)).then(() => tokens) : tokens).then((tokens) => parser2(tokens, opt)).then((html2) => opt.hooks ? opt.hooks.postprocess(html2) : html2).catch(throwError);
      }
      try {
        if (opt.hooks) {
          src = opt.hooks.preprocess(src);
        }
        let tokens = lexer2(src, opt);
        if (opt.hooks) {
          tokens = opt.hooks.processAllTokens(tokens);
        }
        if (opt.walkTokens) {
          this.walkTokens(tokens, opt.walkTokens);
        }
        let html2 = parser2(tokens, opt);
        if (opt.hooks) {
          html2 = opt.hooks.postprocess(html2);
        }
        return html2;
      } catch (e) {
        return throwError(e);
      }
    };
    return parse;
  }
  onError(silent, async) {
    return (e) => {
      e.message += "\nPlease report this to https://github.com/markedjs/marked.";
      if (silent) {
        const msg = "<p>An error occurred:</p><pre>" + escape(e.message + "", true) + "</pre>";
        if (async) {
          return Promise.resolve(msg);
        }
        return msg;
      }
      if (async) {
        return Promise.reject(e);
      }
      throw e;
    };
  }
};
var markedInstance = new Marked();
function marked(src, opt) {
  return markedInstance.parse(src, opt);
}
marked.options = marked.setOptions = function(options2) {
  markedInstance.setOptions(options2);
  marked.defaults = markedInstance.defaults;
  changeDefaults(marked.defaults);
  return marked;
};
marked.getDefaults = _getDefaults;
marked.defaults = _defaults;
marked.use = function(...args) {
  markedInstance.use(...args);
  marked.defaults = markedInstance.defaults;
  changeDefaults(marked.defaults);
  return marked;
};
marked.walkTokens = function(tokens, callback) {
  return markedInstance.walkTokens(tokens, callback);
};
marked.parseInline = markedInstance.parseInline;
marked.Parser = _Parser;
marked.parser = _Parser.parse;
marked.Renderer = _Renderer;
marked.TextRenderer = _TextRenderer;
marked.Lexer = _Lexer;
marked.lexer = _Lexer.lex;
marked.Tokenizer = _Tokenizer;
marked.Hooks = _Hooks;
marked.parse = marked;
var options = marked.options;
var setOptions = marked.setOptions;
var use = marked.use;
var walkTokens = marked.walkTokens;
var parseInline = marked.parseInline;
var parser = _Parser.parse;
var lexer = _Lexer.lex;

// src/MarkdownRenderer.ts
var import_obsidian = require("obsidian");
var MarkdownRenderer = class _MarkdownRenderer extends import_obsidian.Component {
  constructor(container, content, app) {
    super();
    this.container = container;
    this.content = content;
    this.app = app;
  }
  static renderMarkdown(content, container, sourcePath, component) {
    return __async(this, null, function* () {
      const renderer = new _MarkdownRenderer(container, content, component.app);
      yield renderer.render();
    });
  }
  render() {
    return __async(this, null, function* () {
      try {
        this.container.empty();
        this.container.addClass("markdown-rendered");
        const rendered = yield marked.parse(this.content, { async: true });
        const tempDiv = document.createElement("div");
        tempDiv.innerHTML = rendered;
        const fragment = document.createDocumentFragment();
        while (tempDiv.firstChild) {
          fragment.appendChild(tempDiv.firstChild);
        }
        this.container.appendChild(fragment);
      } catch (error) {
        console.error("Error rendering markdown:", error);
        this.container.setText("Error rendering content: " + error.message);
      }
    });
  }
  /**
   * Get content from the current editor
   */
  static getCurrentFileContent(app) {
    try {
      const activeLeaf = app.workspace.activeLeaf;
      if (!activeLeaf) return null;
      const view = activeLeaf.view;
      if (!view || !("editor" in view)) return null;
      return view.editor.getValue();
    } catch (error) {
      console.error("Error getting file content:", error);
      return null;
    }
  }
  /**
   * Get the active editor and selected text
   * @returns Object containing the editor and selected text, or null if no editor is found
   */
  static getActiveEditorAndSelection(app) {
    try {
      const markdownViews = app.workspace.getLeavesOfType("markdown").map((leaf) => leaf.view).filter((view) => view instanceof import_obsidian.MarkdownView);
      let activeView = app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
      if (!activeView || !activeView.editor.somethingSelected()) {
        const viewWithSelection = markdownViews.find((view) => view.editor.somethingSelected());
        activeView = viewWithSelection || null;
      }
      if (activeView && activeView.editor) {
        const selection = activeView.editor.getSelection();
        if (selection && selection.trim().length > 0) {
          return {
            editor: activeView.editor,
            selectedText: selection
          };
        }
      }
      return null;
    } catch (error) {
      console.error("Error getting active editor and selection:", error);
      return null;
    }
  }
  /**
   * Get the selected text from the active editor
   * @returns The selected text, or empty string if no selection
   */
  static getSelectedText(app) {
    const result = this.getActiveEditorAndSelection(app);
    return (result == null ? void 0 : result.selectedText) || "";
  }
  /**
   * Get the active editor
   * @returns The active editor, or null if no editor is found
   */
  static getActiveEditor(app) {
    const result = this.getActiveEditorAndSelection(app);
    return (result == null ? void 0 : result.editor) || null;
  }
};

// src/ChatView.ts
var VIEW_TYPE_CHAT = "chat-view";
var ChatView = class extends import_obsidian2.ItemView {
  // No more search mode, only chat
  constructor(leaf, plugin, modelManager) {
    super(leaf);
    this.messages = [];
    this.currentInput = null;
    this.isGenerating = false;
    this.currentMessage = null;
    this.controller = null;
    this.conversationId = null;
    this.requestId = null;
    this.lastHistorySave = 0;
    this.isEndingConversation = false;
    this.currentFunctionMode = "none";
    this.currentMode = "chat";
    this.plugin = plugin;
    this.modelManager = modelManager;
    this.requestId = plugin.requestId;
  }
  getViewType() {
    return VIEW_TYPE_CHAT;
  }
  getDisplayText() {
    return "AI Chat Assistant";
  }
  onOpen() {
    return __async(this, null, function* () {
      this.contentEl.addClass("chat-view-container");
      this.viewContainer = this.contentEl.createDiv({ cls: "view-container" });
      this.initializeChatView();
    });
  }
  initializeChatView() {
    return __async(this, null, function* () {
      this.chatContainer = this.viewContainer.createDiv({ cls: "chat-container" });
      this.chatHistoryButton = this.chatContainer.createDiv({ cls: "chat-history-button" });
      (0, import_obsidian2.setIcon)(this.chatHistoryButton, "history");
      this.chatHistoryButton.setAttribute("aria-label", "View chat history");
      this.chatHistoryButton.addEventListener("click", () => this.showChatHistory());
      const newChatButton = this.chatContainer.createDiv({ cls: "new-chat-button" });
      (0, import_obsidian2.setIcon)(newChatButton, "plus-circle");
      newChatButton.setAttribute("aria-label", "Start new chat");
      newChatButton.addEventListener("click", () => this.startNewChat());
      this.messagesContainer = this.chatContainer.createDiv({ cls: "messages-container" });
      this.inputContainer = this.chatContainer.createDiv({ cls: "input-container" });
      const inputWrapper = this.inputContainer.createDiv({ cls: "input-wrapper" });
      this.currentInput = inputWrapper.createEl("textarea", {
        cls: "chat-input",
        attr: { placeholder: "Type your message... (Press Enter to send) \u23CE" }
      });
      const functionIconsContainer = this.inputContainer.createDiv({ cls: "function-icons-container" });
      this.createFunctionButtons(functionIconsContainer);
      this.setupInputAutoResize();
      this.setupInputEvents();
      yield this.loadOrInitializeChat();
    });
  }
  // Add necessary methods for creating function buttons
  createFunctionButtons(container) {
    this.ensureFunctionsInitialized();
    this.plugin.settings.functions.forEach((func) => {
      const iconButton = container.createEl("button", {
        cls: `function-icon-button ${func.isBuiltIn ? "built-in" : "custom-function"}`,
        attr: { "aria-label": `${func.name} ${func.tooltip ? `(${func.tooltip})` : ""}` }
      });
      try {
        (0, import_obsidian2.setIcon)(iconButton, func.icon);
      } catch (e) {
        (0, import_obsidian2.setIcon)(iconButton, "bot");
        console.warn(`Invalid icon '${func.icon}' for function '${func.name}'`);
      }
      const tooltipEl = iconButton.createSpan({ cls: "function-icon-tooltip" });
      tooltipEl.setText(func.tooltip || func.name);
      if (func.isBuiltIn) {
        switch (func.name) {
          case "Organize":
            iconButton.onclick = () => this.handleOrganize();
            break;
          case "Grammar":
            iconButton.onclick = () => this.handleGrammar();
            break;
          case "Generate":
            iconButton.onclick = () => this.handleGenerate();
            break;
          case "Dialogue":
            iconButton.onclick = () => this.handleDialogue();
            break;
          case "Summarize":
            iconButton.onclick = () => this.handleSummarize();
            break;
          case "Polish":
            iconButton.onclick = () => this.handlePolish();
            break;
          default:
            iconButton.onclick = () => this.handleCustomFunction(func);
        }
      } else {
        iconButton.onclick = () => this.handleCustomFunction(func);
      }
    });
  }
  // Helper method to ensure functions array is initialized
  ensureFunctionsInitialized() {
    if (!this.plugin.settings.functions) {
      console.log("Initializing functions array from defaults");
      this.plugin.settings.functions = DEFAULT_SETTINGS.functions ? [...DEFAULT_SETTINGS.functions] : [];
      if (this.plugin.settings.customFunctions && this.plugin.settings.customFunctions.length > 0) {
        this.plugin.settings.functions.push(...this.plugin.settings.customFunctions);
      }
      this.plugin.saveSettings();
    } else if (this.plugin.settings.functions.length === 0) {
      this.plugin.settings.functions = DEFAULT_SETTINGS.functions ? [...DEFAULT_SETTINGS.functions] : [];
      this.plugin.saveSettings();
    }
    if (!this.plugin.settings.functions.some((f) => f.name === "Polish")) {
      this.plugin.settings.functions.push({
        name: "Polish",
        prompt: "Please polish and refine the following text to improve clarity, flow, and style while preserving the original meaning and language. Enhance the expression, eliminate redundancies, and make it more engaging. Return the polished version only, without explanations:",
        icon: "bird",
        tooltip: "Polish and refine text",
        isBuiltIn: true
      });
      this.plugin.saveSettings();
    }
  }
  // Add method stubs for required functionality
  showChatHistory() {
  }
  startNewChat() {
    return __async(this, null, function* () {
    });
  }
  setupInputAutoResize() {
    if (!this.currentInput) return;
    const adjustHeight = () => {
      const input = this.currentInput;
      if (!input) return;
      input.style.height = "auto";
      const newHeight = Math.min(input.scrollHeight, 200);
      input.style.height = newHeight + "px";
    };
    this.currentInput.addEventListener("input", adjustHeight);
    setTimeout(adjustHeight, 0);
  }
  setupInputEvents() {
    if (!this.currentInput) return;
    this.currentInput.addEventListener("keydown", (e) => {
      if (e.key === "Enter" && !e.shiftKey && !e.ctrlKey && !e.altKey) {
        e.preventDefault();
        this.sendMessage();
      }
    });
  }
  loadOrInitializeChat() {
    return __async(this, null, function* () {
      this.showWelcomeMessage();
    });
  }
  showWelcomeMessage() {
    if (!this.messagesContainer) return;
    this.messagesContainer.empty();
    const welcomeEl = this.messagesContainer.createDiv({ cls: "welcome-message" });
    welcomeEl.createEl("h3", { text: "Welcome to AI Chat Assistant" });
    welcomeEl.createEl("p", { text: "Type a message to start chatting with the AI assistant." });
  }
  sendMessage() {
    return __async(this, null, function* () {
      var _a, _b;
      if (!this.currentInput || this.isGenerating) return;
      const userMessage = this.currentInput.value.trim();
      if (!userMessage) return;
      try {
        const defaultModel = this.modelManager.getDefaultModel();
        if (!defaultModel) {
          throw new Error("No default model configured. Please set a default model in settings.");
        }
        this.addMessage("user", userMessage);
        this.currentInput.value = "";
        this.currentInput.style.height = "auto";
        this.isGenerating = true;
        const assistantMessageId = `msg-${Date.now()}`;
        this.currentMessage = this.addMessage("assistant", "", assistantMessageId);
        const loadingIndicator = this.currentMessage.createDiv({ cls: "loading-indicator" });
        loadingIndicator.innerHTML = '<span class="dot"></span><span class="dot"></span><span class="dot"></span>';
        this.controller = new AbortController();
        let accumulatedResponse = "";
        const response = yield this.modelManager.callModel(
          defaultModel.id,
          userMessage,
          {
            streaming: true,
            onChunk: (chunk) => {
              try {
                if (this.currentMessage) {
                  const contentDiv = this.currentMessage.querySelector(".message-content");
                  if (contentDiv) {
                    accumulatedResponse += chunk;
                    contentDiv.empty();
                    MarkdownRenderer.renderMarkdown(accumulatedResponse, contentDiv, "", this.plugin);
                    this.scrollToBottom();
                  }
                }
              } catch (error) {
                console.error("Error handling stream chunk:", error);
              }
            },
            signal: this.controller.signal
          }
        );
        loadingIndicator == null ? void 0 : loadingIndicator.remove();
        this.isGenerating = false;
        this.controller = null;
        this.currentMessage = null;
        if (this.shouldSaveHistory()) {
          yield this.saveChatHistory();
        }
      } catch (error) {
        console.error("Error sending message:", error);
        (_b = (_a = this.currentMessage) == null ? void 0 : _a.querySelector(".loading-indicator")) == null ? void 0 : _b.remove();
        if (this.currentMessage) {
          const contentDiv = this.currentMessage.querySelector(".message-content");
          if (contentDiv) {
            contentDiv.empty();
            const errorMessage = error instanceof Error ? error.message : "Failed to generate response";
            contentDiv.createEl("div", {
              cls: "error-message",
              text: `Error: ${errorMessage}. Please try again.`
            });
          }
        }
        this.isGenerating = false;
        this.controller = null;
        this.currentMessage = null;
      }
    });
  }
  // Add messages to the chat
  addMessage(role, content, id) {
    const message = { role, content };
    this.messages.push(message);
    const messageEl = this.messagesContainer.createDiv({
      cls: `message ${role}-message`,
      attr: id ? { id } : {}
    });
    const contentDiv = messageEl.createDiv({ cls: "message-content" });
    if (role === "assistant") {
      MarkdownRenderer.renderMarkdown(content, contentDiv, "", this.plugin);
      if (content) {
        this.addMessageActions(messageEl);
      }
    } else {
      contentDiv.setText(content);
    }
    this.scrollToBottom();
    return messageEl;
  }
  // Add action buttons to assistant messages
  addMessageActions(messageEl) {
    const actionContainer = messageEl.createDiv({ cls: "message-actions hover-only" });
    const copyButton = actionContainer.createEl("button", {
      cls: "message-action-button copy-button",
      attr: { "aria-label": "Copy message" }
    });
    (0, import_obsidian2.setIcon)(copyButton, "copy");
    copyButton.onclick = () => __async(this, null, function* () {
      try {
        const contentDiv = messageEl.querySelector(".message-content");
        if (contentDiv) {
          yield navigator.clipboard.writeText(contentDiv.textContent || "");
          new import_obsidian2.Notice("Copied to clipboard", 2e3);
        }
      } catch (err) {
        console.error("Failed to copy content:", err);
        new import_obsidian2.Notice("Failed to copy content", 2e3);
      }
    });
    const insertButton = actionContainer.createEl("button", {
      cls: "message-action-button insert-button",
      attr: { "aria-label": "Insert into editor" }
    });
    (0, import_obsidian2.setIcon)(insertButton, "file-plus");
    insertButton.onclick = () => {
      const contentDiv = messageEl.querySelector(".message-content");
      if (!contentDiv) return;
      const activeView = this.app.workspace.getActiveViewOfType(import_obsidian2.MarkdownView);
      if (!activeView) {
        new import_obsidian2.Notice("Please open a markdown file first", 3e3);
        return;
      }
      const editor = activeView.editor;
      const content = contentDiv.textContent || "";
      editor.replaceSelection(content);
      new import_obsidian2.Notice("Content inserted at cursor position", 2e3);
    };
    const applyButton = actionContainer.createEl("button", {
      cls: "message-action-button apply-button",
      attr: { "aria-label": "Apply changes" }
    });
    (0, import_obsidian2.setIcon)(applyButton, "check");
    applyButton.onclick = () => {
      const contentDiv = messageEl.querySelector(".message-content");
      if (!contentDiv) return;
      const activeView = this.app.workspace.getActiveViewOfType(import_obsidian2.MarkdownView);
      if (!activeView) {
        new import_obsidian2.Notice("Please open a markdown file first", 3e3);
        return;
      }
      const editor = activeView.editor;
      const newText = contentDiv.textContent || "";
      const originalText = editor.somethingSelected() ? editor.getSelection() : editor.getValue();
      this.showDiffModal(editor, originalText, newText);
    };
  }
  // Scroll to bottom of messages container
  scrollToBottom() {
    if (this.messagesContainer) {
      this.messagesContainer.scrollTo({
        top: this.messagesContainer.scrollHeight,
        behavior: "smooth"
      });
    }
  }
  // Function handlers with proper diff functionality
  handleOrganize() {
    var _a;
    if (!this.currentInput) return;
    const selectedText = this.getSelectedTextFromEditor();
    if (selectedText) {
      const prompt = `${((_a = this.plugin.settings.functions.find((f) => f.name === "Organize")) == null ? void 0 : _a.prompt) || ""} ${selectedText}`;
      this.currentInput.value = prompt;
      this.currentFunctionMode = "organize";
      this.sendMessageWithDiff(selectedText);
    } else {
      new import_obsidian2.Notice("No text available. Please open a markdown file or select text.", 3e3);
    }
  }
  handleGrammar() {
    var _a;
    if (!this.currentInput) return;
    const selectedText = this.getSelectedTextFromEditor();
    if (selectedText) {
      const prompt = `${((_a = this.plugin.settings.functions.find((f) => f.name === "Grammar")) == null ? void 0 : _a.prompt) || ""} ${selectedText}`;
      this.currentInput.value = prompt;
      this.currentFunctionMode = "grammar";
      this.sendMessageWithDiff(selectedText);
    } else {
      new import_obsidian2.Notice("No text available. Please open a markdown file or select text.", 3e3);
    }
  }
  handleGenerate() {
    var _a;
    if (!this.currentInput) return;
    const selectedText = this.getSelectedTextFromEditor();
    if (selectedText) {
      const prompt = `${((_a = this.plugin.settings.functions.find((f) => f.name === "Generate")) == null ? void 0 : _a.prompt) || ""} ${selectedText}`;
      this.currentInput.value = prompt;
      this.currentFunctionMode = "generate";
      this.sendMessageWithDiff(selectedText);
    } else {
      new import_obsidian2.Notice("No text available. Please open a markdown file or select text.", 3e3);
    }
  }
  handleDialogue() {
    var _a;
    if (!this.currentInput) return;
    const selectedText = this.getSelectedTextFromEditor();
    if (selectedText) {
      const prompt = `${((_a = this.plugin.settings.functions.find((f) => f.name === "Dialogue")) == null ? void 0 : _a.prompt) || ""} ${selectedText}`;
      this.currentInput.value = prompt;
      this.currentFunctionMode = "dialogue";
      this.sendMessageWithDiff(selectedText);
    } else {
      new import_obsidian2.Notice("No text available. Please open a markdown file or select text.", 3e3);
    }
  }
  handleSummarize() {
    var _a;
    if (!this.currentInput) return;
    const selectedText = this.getSelectedTextFromEditor();
    if (selectedText) {
      const prompt = `${((_a = this.plugin.settings.functions.find((f) => f.name === "Summarize")) == null ? void 0 : _a.prompt) || ""} ${selectedText}`;
      this.currentInput.value = prompt;
      this.currentFunctionMode = "summary";
      this.sendMessageWithDiff(selectedText);
    } else {
      new import_obsidian2.Notice("No text available. Please open a markdown file or select text.", 3e3);
    }
  }
  handlePolish() {
    var _a;
    if (!this.currentInput) return;
    const selectedText = this.getSelectedTextFromEditor();
    if (selectedText) {
      const prompt = `${((_a = this.plugin.settings.functions.find((f) => f.name === "Polish")) == null ? void 0 : _a.prompt) || ""} ${selectedText}`;
      this.currentInput.value = prompt;
      this.currentFunctionMode = "polish";
      this.sendMessageWithDiff(selectedText);
    } else {
      new import_obsidian2.Notice("No text available. Please open a markdown file or select text.", 3e3);
    }
  }
  handleCustomFunction(func) {
    if (!this.currentInput) return;
    const selectedText = this.getSelectedTextFromEditor();
    if (selectedText) {
      const prompt = `${func.prompt} ${selectedText}`;
      this.currentInput.value = prompt;
      this.currentFunctionMode = "custom";
      this.sendMessageWithDiff(selectedText);
    } else {
      this.currentInput.value = func.prompt;
      this.currentFunctionMode = "custom";
      this.currentInput.focus();
    }
  }
  // Add debugging and improved detection of active view
  getSelectedTextFromEditor() {
    console.log("Getting selected text from editor");
    return MarkdownRenderer.getSelectedText(this.app);
  }
  // Add method for sending message with diff functionality
  sendMessageWithDiff(originalText) {
    return __async(this, null, function* () {
      var _a, _b;
      if (!this.currentInput || this.isGenerating) return;
      const userMessage = this.currentInput.value.trim();
      if (!userMessage) return;
      try {
        const defaultModel = this.modelManager.getDefaultModel();
        if (!defaultModel) {
          throw new Error("No default model configured. Please set a default model in settings.");
        }
        this.addMessage("user", userMessage);
        this.currentInput.value = "";
        this.currentInput.style.height = "auto";
        this.isGenerating = true;
        const assistantMessageId = `msg-${Date.now()}`;
        this.currentMessage = this.addMessage("assistant", "", assistantMessageId);
        const loadingIndicator = this.currentMessage.createDiv({ cls: "loading-indicator" });
        loadingIndicator.innerHTML = '<span class="dot"></span><span class="dot"></span><span class="dot"></span>';
        this.controller = new AbortController();
        let accumulatedResponse = "";
        const response = yield this.modelManager.callModel(
          defaultModel.id,
          userMessage,
          {
            streaming: true,
            onChunk: (chunk) => {
              try {
                if (this.currentMessage) {
                  const contentDiv = this.currentMessage.querySelector(".message-content");
                  if (contentDiv) {
                    accumulatedResponse += chunk;
                    contentDiv.empty();
                    MarkdownRenderer.renderMarkdown(accumulatedResponse, contentDiv, "", this.plugin);
                    this.scrollToBottom();
                  }
                }
              } catch (error) {
                console.error("Error handling stream chunk:", error);
              }
            },
            signal: this.controller.signal
          }
        );
        loadingIndicator == null ? void 0 : loadingIndicator.remove();
        this.isGenerating = false;
        this.controller = null;
        const responseText = ((_b = (_a = this.currentMessage) == null ? void 0 : _a.querySelector(".message-content")) == null ? void 0 : _b.textContent) || "";
        this.currentMessage = null;
        if (this.currentFunctionMode !== "none") {
          this.addApplyButton(originalText, responseText);
        }
        if (this.shouldSaveHistory()) {
          yield this.saveChatHistory();
        }
      } catch (error) {
        console.error("Error sending message:", error);
        if (this.currentMessage) {
          const contentDiv = this.currentMessage.querySelector(".message-content");
          if (contentDiv) {
            contentDiv.textContent = "Error: Failed to generate response. Please try again.";
          }
        }
        this.isGenerating = false;
        this.controller = null;
        this.currentMessage = null;
      }
    });
  }
  // Method to add apply button for diffs with improved active editor checking
  addApplyButton(originalText, responseText) {
    const messages = this.messagesContainer.querySelectorAll(".message.assistant-message");
    if (messages.length === 0) return;
    const lastMessage = messages[messages.length - 1];
    if (!lastMessage) return;
    let actionContainer = lastMessage.querySelector(".message-actions");
    if (!actionContainer) {
      actionContainer = lastMessage.createDiv({ cls: "message-actions hover-only" });
    }
    const applyButton = actionContainer.createEl("button", {
      cls: "message-action-button apply-button",
      attr: { "aria-label": "Apply changes" }
    });
    (0, import_obsidian2.setIcon)(applyButton, "check");
    applyButton.createSpan({ cls: "action-tooltip", text: "Apply changes" });
    applyButton.onclick = () => {
      let activeView = this.app.workspace.getActiveViewOfType(import_obsidian2.MarkdownView);
      if (!activeView) {
        const activeLeaf = this.app.workspace.activeLeaf;
        if (activeLeaf && activeLeaf.view instanceof import_obsidian2.MarkdownView) {
          activeView = activeLeaf.view;
        }
      }
      if (!activeView || !activeView.editor) {
        new import_obsidian2.Notice("Please open a markdown file first", 3e3);
        return;
      }
      this.showDiffModal(activeView.editor, originalText, responseText);
    };
  }
  // Method to show diff modal
  showDiffModal(editor, originalText, newText) {
    const modal = new import_obsidian2.Modal(this.app);
    modal.titleEl.setText("Review Changes");
    modal.contentEl.addClass("diff-modal");
    const diffContainer = modal.contentEl.createDiv({ cls: "diff-container" });
    this.visualizeDiff(diffContainer, originalText, newText);
    const buttonContainer = modal.contentEl.createDiv({ cls: "diff-actions" });
    const applyButton = buttonContainer.createEl("button", {
      text: "Apply Changes",
      cls: "diff-apply-button"
    });
    const cancelButton = buttonContainer.createEl("button", {
      text: "Cancel",
      cls: "diff-cancel-button"
    });
    applyButton.onclick = () => {
      if (editor.somethingSelected()) {
        editor.replaceSelection(newText);
      } else {
        editor.setValue(newText);
      }
      modal.close();
      new import_obsidian2.Notice("Changes applied successfully", 2e3);
    };
    cancelButton.onclick = () => {
      modal.close();
    };
    modal.open();
  }
  // Method to visualize diff
  visualizeDiff(container, originalText, newText) {
    if (this.plugin.diffMatchPatchLib) {
      try {
        const dmp = new this.plugin.diffMatchPatchLib();
        const diffs = dmp.diff_main(originalText, newText);
        dmp.diff_cleanupSemantic(diffs);
        const diffView = container.createDiv({ cls: "diff-view" });
        for (const [op, text] of diffs) {
          const span = diffView.createSpan({
            cls: op === -1 ? "diff-delete" : op === 1 ? "diff-add" : "diff-equal",
            text
          });
        }
      } catch (error) {
        console.error("Error creating diff:", error);
        this.createSimpleDiffView(container, originalText, newText);
      }
    } else {
      this.createSimpleDiffView(container, originalText, newText);
    }
  }
  // Create a simple side-by-side diff view
  createSimpleDiffView(container, originalText, newText) {
    const diffContainer = container.createDiv({ cls: "simple-diff-container" });
    const originalCol = diffContainer.createDiv({ cls: "diff-column original-column" });
    originalCol.createEl("h3", { text: "Original" });
    const originalContent = originalCol.createDiv({ cls: "diff-content" });
    originalContent.setText(originalText);
    const newCol = diffContainer.createDiv({ cls: "diff-column new-column" });
    newCol.createEl("h3", { text: "New Version" });
    const newContent = newCol.createDiv({ cls: "diff-content" });
    newContent.setText(newText);
  }
  // Add shouldSaveHistory method
  shouldSaveHistory() {
    if (this.messages.length % 5 === 0 && this.messages.length > 0) {
      return true;
    }
    const lastSaveTime = this.lastHistorySave || 0;
    const TEN_MINUTES = 10 * 60 * 1e3;
    if (this.messages.length > 0 && Date.now() - lastSaveTime > TEN_MINUTES) {
      return true;
    }
    return false;
  }
  // Add saveChatHistory method
  saveChatHistory() {
    return __async(this, null, function* () {
      try {
        let chatTitle = "Chat " + (/* @__PURE__ */ new Date()).toLocaleString();
        if (this.messages.length > 0 && this.messages[0].role === "user") {
          const firstMessage = this.messages[0].content;
          chatTitle = firstMessage.split(" ").slice(0, 5).join(" ");
          if (firstMessage.length > chatTitle.length) {
            chatTitle += "...";
          }
        }
        const history = {
          id: this.conversationId || `chat-${Date.now()}`,
          title: chatTitle,
          date: Date.now(),
          messages: this.messages,
          requestId: this.requestId
        };
        if (!this.plugin.settings.chatHistoryPath) {
          this.plugin.settings.chatHistoryPath = "chat-history";
          yield this.plugin.saveSettings();
        }
        const folderPath = this.plugin.settings.chatHistoryPath;
        const folder = this.app.vault.getAbstractFileByPath(folderPath);
        if (!folder) {
          yield this.app.vault.createFolder(folderPath);
        }
        const fileName = `${folderPath}/${history.id}.json`;
        yield this.app.vault.adapter.write(
          fileName,
          JSON.stringify(history, null, 2)
        );
        if (!this.conversationId) {
          this.conversationId = history.id;
        }
        this.lastHistorySave = Date.now();
        console.log(`Chat history saved to ${fileName}`);
      } catch (error) {
        console.error("Failed to save chat history:", error);
      }
    });
  }
};

// src/models/ModelManager.ts
var ModelManager = class {
  // 1 hour
  constructor(plugin, initialModels = [], initialEmbeddingModels = [], initialProxyConfig = {
    enabled: false,
    address: "",
    port: "",
    type: "http",
    requiresAuth: false
  }, saveCallback) {
    this.plugin = plugin;
    this.models = [];
    this.embeddingModels = [];
    this.embeddingCache = /* @__PURE__ */ new Map();
    this.CACHE_DURATION = 1e3 * 60 * 60;
    this.models = initialModels;
    this.embeddingModels = initialEmbeddingModels;
    this.proxyConfig = initialProxyConfig;
    this.saveSettingsCallback = saveCallback;
  }
  loadConfigs(models, embeddingModels, proxyConfig) {
    this.models = models || [];
    this.embeddingModels = embeddingModels || [];
    this.proxyConfig = proxyConfig || {
      enabled: false,
      address: "",
      port: "",
      type: "http",
      requiresAuth: false
    };
  }
  getModels() {
    return [...this.models];
  }
  getActiveModels() {
    return this.models.filter((model) => model.active);
  }
  getModelById(id) {
    return this.models.find((m) => m.id === id);
  }
  addModel(model) {
    if (model.isDefault) {
      this.models.forEach((m) => {
        if (m.id !== model.id) {
          m.isDefault = false;
        }
      });
    }
    const existingIndex = this.models.findIndex((m) => m.id === model.id);
    if (existingIndex >= 0) {
      this.models[existingIndex] = model;
    } else {
      this.models.push(model);
    }
    this.saveModels();
  }
  updateModel(id, updates) {
    const modelIndex = this.models.findIndex((m) => m.id === id);
    if (modelIndex >= 0) {
      if (updates.isDefault) {
        this.models.forEach((m) => {
          if (m.id !== id) {
            m.isDefault = false;
          }
        });
      }
      this.models[modelIndex] = __spreadValues(__spreadValues({}, this.models[modelIndex]), updates);
      this.saveModels();
    }
  }
  removeModel(id) {
    this.models = this.models.filter((model) => model.id !== id);
    this.saveModels();
  }
  getProxyConfig() {
    return this.proxyConfig;
  }
  updateProxyConfig(config) {
    this.proxyConfig = __spreadValues(__spreadValues({}, this.proxyConfig), config);
    this.saveProxyConfig();
  }
  getEmbeddingModels() {
    return this.embeddingModels;
  }
  getActiveEmbeddingModel() {
    return this.embeddingModels.find((m) => m.active);
  }
  addEmbeddingModel(model) {
    if (model.active) {
      this.embeddingModels.forEach((m) => m.active = false);
    }
    this.embeddingModels.push(model);
    this.saveModels();
  }
  updateEmbeddingModel(id, updates) {
    const index = this.embeddingModels.findIndex((m) => m.id === id);
    if (index !== -1) {
      if (updates.active) {
        this.embeddingModels.forEach((m) => m.active = false);
      }
      this.embeddingModels[index] = __spreadValues(__spreadValues({}, this.embeddingModels[index]), updates);
      this.saveModels();
    }
  }
  removeEmbeddingModel(id) {
    this.embeddingModels = this.embeddingModels.filter((m) => m.id !== id);
    this.saveModels();
  }
  saveModels() {
    this.saveSettingsCallback();
  }
  saveProxyConfig() {
    this.saveSettingsCallback();
  }
  callModel(_0, _1) {
    return __async(this, arguments, function* (modelId, prompt, options2 = {}) {
      const model = this.getModelById(modelId);
      if (!model) throw new Error(`Model ${modelId} not found`);
      const useProxy = model.useProxy !== void 0 ? model.useProxy : this.proxyConfig.enabled;
      let result = "";
      try {
        console.log(`Calling model: ${model.name} (${model.type}) with prompt: ${prompt.substring(0, 50)}...`);
        switch (model.type) {
          case "openai":
            result = yield this.callOpenAI(model, prompt, useProxy, options2);
            break;
          case "ollama":
            result = yield this.callOllama(model, prompt, useProxy, options2);
            break;
          case "claude":
            result = yield this.callClaude(model, prompt, useProxy, options2);
            break;
          case "zhipu":
          case "zhipuai":
            result = yield this.callZhipu(model, prompt, useProxy, options2);
            break;
          case "baidu":
            result = yield this.callBaidu(model, prompt, useProxy, options2);
            break;
          case "custom":
            result = yield this.callCustomAPI(model, prompt, useProxy, options2);
            break;
          default:
            throw new Error(`Model type ${model.type} not supported`);
        }
        return result;
      } catch (error) {
        console.error(`Error calling model ${model.name} (${model.type}):`, error);
        throw error;
      }
    });
  }
  callOpenAI(model, prompt, useProxy, options2) {
    return __async(this, null, function* () {
      const url = model.baseUrl || "https://api.openai.com/v1/chat/completions";
      const headers = {
        "Content-Type": "application/json",
        "Authorization": `Bearer ${model.apiKey}`
      };
      const payload = {
        model: options2.modelName || model.modelName || "gpt-3.5-turbo",
        messages: [
          { role: "system", content: model.systemPrompt || "You are a helpful assistant." },
          { role: "user", content: prompt }
        ],
        temperature: options2.temperature || 0.7,
        max_tokens: options2.maxTokens || 2048
      };
      const response = yield this.fetchWithProxy(url, {
        method: "POST",
        headers,
        body: JSON.stringify(payload)
      }, useProxy);
      const data = yield response.json();
      return data.choices[0].message.content;
    });
  }
  callOllama(model, prompt, useProxy, options2) {
    return __async(this, null, function* () {
      const url = model.baseUrl || "http://localhost:11434/api/generate";
      const headers = {
        "Content-Type": "application/json"
      };
      const payload = {
        model: options2.modelName || model.modelName || "llama2",
        prompt,
        system: model.systemPrompt || "You are a helpful assistant.",
        options: {
          temperature: options2.temperature || 0.7,
          num_predict: options2.maxTokens || 2048
        }
      };
      const response = yield this.fetchWithProxy(url, {
        method: "POST",
        headers,
        body: JSON.stringify(payload)
      }, useProxy);
      const data = yield response.json();
      return data.response;
    });
  }
  callClaude(model, prompt, useProxy, options2) {
    return __async(this, null, function* () {
      const url = model.baseUrl || "https://api.anthropic.com/v1/messages";
      const headers = {
        "Content-Type": "application/json",
        "anthropic-version": "2023-06-01"
      };
      if (model.apiKey) {
        headers["x-api-key"] = model.apiKey;
      }
      const payload = {
        model: options2.modelName || model.modelName || "claude-3-opus-20240229",
        messages: [
          { role: "user", content: prompt }
        ],
        system: model.systemPrompt || "You are Claude, a helpful AI assistant.",
        max_tokens: options2.maxTokens || 2048
      };
      const response = yield this.fetchWithProxy(url, {
        method: "POST",
        headers,
        body: JSON.stringify(payload)
      }, useProxy);
      const data = yield response.json();
      return data.content[0].text;
    });
  }
  callZhipu(model, prompt, useProxy, options2) {
    return __async(this, null, function* () {
      var _a, _b, _c, _d, _e, _f, _g;
      const isZhipuAI = model.type === "zhipuai";
      let baseUrl = "";
      if (model.baseUrl) {
        baseUrl = model.baseUrl;
        if (baseUrl.endsWith("/v4") || baseUrl.endsWith("/v3")) {
          baseUrl += "/chat/completions";
        }
      } else {
        baseUrl = isZhipuAI ? "https://open.bigmodel.cn/api/paas/v4/chat/completions" : "https://open.bigmodel.cn/api/paas/v3/chat/completions";
      }
      console.log(`ZhipuAI: Using endpoint ${baseUrl} for model type ${model.type}`);
      let headers = {
        "Content-Type": "application/json"
      };
      if (model.apiKey) {
        headers["Authorization"] = `Bearer ${model.apiKey}`;
      }
      const modelNameMap = {
        "GLM-4-Long": "glm-4",
        "GLM-4-Air": "glm-4",
        "GLM-4": "glm-4",
        "GLM-3-Turbo": "glm-3-turbo",
        "GLM-4V": "glm-4v"
      };
      const modelIdentifier = modelNameMap[model.modelName] || model.modelName || options2.modelName || "glm-4";
      const streaming = !!options2.streaming;
      const onChunk = options2.onChunk;
      const payload = {
        model: modelIdentifier,
        messages: options2.conversation || [
          { role: "system", content: model.systemPrompt || "You are a helpful assistant." },
          { role: "user", content: prompt }
        ],
        temperature: options2.temperature || 0.7,
        max_tokens: options2.maxTokens || 2048,
        stream: streaming
      };
      try {
        console.log(`ZhipuAI: Using model ${modelIdentifier} (mapped from ${model.modelName}), streaming: ${streaming}`);
        if (streaming && typeof onChunk === "function") {
          let fullResponse = "";
          const response2 = yield this.fetchWithProxy(baseUrl, {
            method: "POST",
            headers,
            body: JSON.stringify(payload)
          }, useProxy);
          if (!response2.ok) {
            const errorData = yield response2.text();
            console.error(`ZhipuAI API error (${response2.status}): ${errorData}`);
            throw new Error(`ZhipuAI API error: ${response2.status} ${response2.statusText}`);
          }
          const reader = (_a = response2.body) == null ? void 0 : _a.getReader();
          if (!reader) {
            throw new Error("Failed to get response reader for streaming");
          }
          const decoder = new TextDecoder();
          let buffer = "";
          while (true) {
            const { done, value } = yield reader.read();
            if (done) break;
            buffer += decoder.decode(value, { stream: true });
            let newlineIndex;
            while ((newlineIndex = buffer.indexOf("\n")) !== -1) {
              const line = buffer.slice(0, newlineIndex).trim();
              buffer = buffer.slice(newlineIndex + 1);
              if (line.startsWith("data:")) {
                const jsonData = line.slice(5).trim();
                if (jsonData === "" || jsonData === "[DONE]") continue;
                try {
                  const parsedData = JSON.parse(jsonData);
                  if ((_d = (_c = (_b = parsedData.choices) == null ? void 0 : _b[0]) == null ? void 0 : _c.delta) == null ? void 0 : _d.content) {
                    const content = parsedData.choices[0].delta.content;
                    fullResponse += content;
                    onChunk(content);
                  }
                } catch (e) {
                  console.error("Error parsing streaming data:", e, jsonData);
                }
              }
            }
          }
          return fullResponse;
        }
        const response = yield this.fetchWithProxy(baseUrl, {
          method: "POST",
          headers,
          body: JSON.stringify(payload)
        }, useProxy);
        if (!response.ok) {
          const errorData = yield response.text();
          console.error(`ZhipuAI API error (${response.status}): ${errorData}`);
          if (response.status === 404) {
            console.error("ZhipuAI API endpoint not found. Please verify the correct endpoint URL.");
            throw new Error(`ZhipuAI API endpoint not found. Please check your model configuration and API documentation for the correct URL. Status: ${response.status}`);
          }
          throw new Error(`ZhipuAI API error: ${response.status} ${response.statusText}`);
        }
        const data = yield response.json();
        console.log("ZhipuAI response:", JSON.stringify(data).substring(0, 200) + "...");
        if (data.choices && ((_f = (_e = data.choices[0]) == null ? void 0 : _e.message) == null ? void 0 : _f.content)) {
          return data.choices[0].message.content;
        } else if (data.data && data.data.choices && ((_g = data.data.choices[0]) == null ? void 0 : _g.content)) {
          return data.data.choices[0].content;
        } else if (data.response) {
          return data.response;
        } else {
          console.warn("Unexpected ZhipuAI response format:", data);
          return JSON.stringify(data);
        }
      } catch (error) {
        console.error("Error calling ZhipuAI:", error);
        throw error;
      }
    });
  }
  callBaidu(model, prompt, useProxy, options2) {
    return __async(this, null, function* () {
      const url = model.baseUrl || "https://aip.baidubce.com/rpc/2.0/ai_custom/v1/wenxinworkshop/chat/";
      const headers = {
        "Content-Type": "application/json",
        "Authorization": `Bearer ${model.apiKey}`
      };
      const payload = {
        messages: [
          { role: "system", content: model.systemPrompt || "You are a helpful assistant." },
          { role: "user", content: prompt }
        ],
        temperature: options2.temperature || 0.7,
        max_tokens: options2.maxTokens || 2048
      };
      const response = yield this.fetchWithProxy(url, {
        method: "POST",
        headers,
        body: JSON.stringify(payload)
      }, useProxy);
      const data = yield response.json();
      return data.result;
    });
  }
  callCustomAPI(model, prompt, useProxy, options2) {
    return __async(this, null, function* () {
      if (!model.baseUrl) throw new Error("Base URL is required for custom API model");
      const headers = {
        "Content-Type": "application/json"
      };
      if (model.apiKey) {
        headers["Authorization"] = `Bearer ${model.apiKey}`;
      }
      const payload = {
        prompt,
        system_prompt: model.systemPrompt || "You are a helpful assistant.",
        temperature: options2.temperature || 0.7,
        max_tokens: options2.maxTokens || 2048
      };
      const response = yield this.fetchWithProxy(model.baseUrl, {
        method: "POST",
        headers,
        body: JSON.stringify(payload)
      }, useProxy);
      const data = yield response.json();
      return data.response || data.result || data.text || JSON.stringify(data);
    });
  }
  fetchWithProxy(url, options2, useProxy) {
    return __async(this, null, function* () {
      try {
        console.log(`Making request to: ${url}`);
        if (!useProxy || !this.proxyConfig.enabled) {
          return fetch(url, options2);
        }
        console.log(`Using proxy: ${this.proxyConfig.type}://${this.proxyConfig.address}:${this.proxyConfig.port}`);
        return fetch(url, options2);
      } catch (error) {
        console.error(`Fetch error for ${url}:`, error);
        throw error;
      }
    });
  }
  callMultipleModels(_0, _1) {
    return __async(this, arguments, function* (modelIds, prompt, options2 = {}) {
      const results = {};
      yield Promise.all(modelIds.map((modelId) => __async(this, null, function* () {
        try {
          const result = yield this.callModel(modelId, prompt, options2);
          results[modelId] = result;
        } catch (error) {
          console.error(`Error calling model ${modelId}:`, error);
          results[modelId] = `Error: ${error.message}`;
        }
      })));
      return results;
    });
  }
  getDefaultModel() {
    const defaultModel = this.models.find((m) => m.isDefault && m.active);
    if (defaultModel) {
      return defaultModel;
    }
    const firstActive = this.models.find((m) => m.active);
    return firstActive || null;
  }
  getCacheKey(text, modelId) {
    return `${modelId}:${text}`;
  }
  getCachedEmbedding(text, modelId) {
    return __async(this, null, function* () {
      const key = this.getCacheKey(text, modelId);
      const cached = this.embeddingCache.get(key);
      if (cached) {
        const now = Date.now();
        if (now - cached.timestamp < this.CACHE_DURATION) {
          return cached.vector;
        } else {
          this.embeddingCache.delete(key);
        }
      }
      return null;
    });
  }
  setCachedEmbedding(text, modelId, vector) {
    const key = this.getCacheKey(text, modelId);
    this.embeddingCache.set(key, {
      vector,
      timestamp: Date.now(),
      modelId
    });
    const now = Date.now();
    for (const [key2, value] of this.embeddingCache.entries()) {
      if (now - value.timestamp > this.CACHE_DURATION) {
        this.embeddingCache.delete(key2);
      }
    }
  }
  getEmbedding(text) {
    return __async(this, null, function* () {
      const activeModel = this.getActiveEmbeddingModel();
      if (!activeModel) {
        throw new Error("No active embedding model configured");
      }
      try {
        const cached = yield this.getCachedEmbedding(text, activeModel.id);
        if (cached) {
          return cached;
        }
        console.log(`Getting embedding using provider: ${activeModel.type}, model: ${activeModel.modelName}`);
        let vector;
        switch (activeModel.type) {
          case "openai":
            vector = yield this.getOpenAIEmbedding(activeModel, text, activeModel.useProxy !== void 0 ? activeModel.useProxy : this.proxyConfig.enabled);
            break;
          case "zhipuai":
          case "zhipu":
            vector = yield this.getZhipuEmbedding(activeModel, text, activeModel.useProxy !== void 0 ? activeModel.useProxy : this.proxyConfig.enabled);
            break;
          case "custom":
            vector = yield this.getCustomEmbedding(activeModel, text, activeModel.useProxy !== void 0 ? activeModel.useProxy : this.proxyConfig.enabled);
            break;
          default:
            throw new Error(`Embedding not supported for provider: ${activeModel.type}`);
        }
        this.setCachedEmbedding(text, activeModel.id, vector);
        return vector;
      } catch (error) {
        console.error(`Error getting embedding:`, error);
        throw error;
      }
    });
  }
  getOpenAIEmbedding(model, text, useProxy) {
    return __async(this, null, function* () {
      var _a, _b;
      const url = model.baseUrl || "https://api.openai.com/v1/embeddings";
      if (!model.apiKey) {
        throw new Error("API key is required for OpenAI embeddings");
      }
      const headers = {
        "Authorization": `Bearer ${model.apiKey}`,
        "Content-Type": "application/json"
      };
      const payload = {
        model: model.modelName,
        input: text
      };
      const response = yield this.fetchWithProxy(url, {
        method: "POST",
        headers,
        body: JSON.stringify(payload)
      }, useProxy);
      const data = yield response.json();
      if (!((_b = (_a = data.data) == null ? void 0 : _a[0]) == null ? void 0 : _b.embedding)) {
        throw new Error("Invalid embedding response from OpenAI");
      }
      return data.data[0].embedding;
    });
  }
  getZhipuEmbedding(model, text, useProxy) {
    return __async(this, null, function* () {
      const version = model.modelName === "embedding-2" ? "v3" : "v4";
      const baseUrl = model.baseUrl || `https://open.bigmodel.cn/api/paas/${version}/embeddings`;
      const headers = {
        "Content-Type": "application/json"
      };
      if (model.apiKey) {
        headers["Authorization"] = `Bearer ${model.apiKey}`;
      }
      const payload = {
        model: model.modelName,
        input: text
      };
      try {
        console.log(`Making request to: ${baseUrl}`);
        const response = yield this.fetchWithProxy(baseUrl, {
          method: "POST",
          headers,
          body: JSON.stringify(payload)
        }, useProxy);
        if (!response.ok) {
          const errorText = yield response.text();
          console.error(`ZhipuAI embedding API error (${response.status}):`, errorText);
          throw new Error(`ZhipuAI embedding API error: ${response.status} ${response.statusText}`);
        }
        const data = yield response.json();
        if (data.data && data.data[0] && data.data[0].embedding) {
          return data.data[0].embedding;
        } else if (data.data && data.data.embedding) {
          return data.data.embedding;
        } else {
          console.error("Unexpected ZhipuAI embedding response format:", data);
          throw new Error("Invalid embedding response format from ZhipuAI");
        }
      } catch (error) {
        console.error("Error getting ZhipuAI embedding:", error);
        throw error;
      }
    });
  }
  getCustomEmbedding(model, text, useProxy) {
    return __async(this, null, function* () {
      var _a, _b;
      if (!model.baseUrl) {
        throw new Error("Base URL is required for custom embedding API");
      }
      const headers = {
        "Content-Type": "application/json"
      };
      if (model.apiKey) {
        headers["Authorization"] = `Bearer ${model.apiKey}`;
      }
      const payload = {
        model: model.modelName,
        input: text,
        dimensions: model.dimensions
      };
      const response = yield this.fetchWithProxy(model.baseUrl + "/embeddings", {
        method: "POST",
        headers,
        body: JSON.stringify(payload)
      }, useProxy);
      const data = yield response.json();
      if (!((_b = (_a = data.data) == null ? void 0 : _a[0]) == null ? void 0 : _b.embedding)) {
        throw new Error("Invalid embedding response from custom API");
      }
      return data.data[0].embedding;
    });
  }
};

// src/debate/DebatePanel.ts
var import_obsidian3 = require("obsidian");

// src/debate/AgentDebateEngine.ts
var Agent = class {
  constructor(id, name, rolePrompt, modelId, modelManager) {
    this.id = id;
    this.name = name;
    this.rolePrompt = rolePrompt;
    this.modelId = modelId;
    this.modelManager = modelManager;
  }
  think(message, context = "", onChunk) {
    return __async(this, null, function* () {
      const fullPrompt = `${context}

${this.rolePrompt}

${message}`;
      try {
        return yield this.modelManager.callModel(
          this.modelId,
          fullPrompt,
          {
            streaming: !!onChunk,
            onChunk
          }
        );
      } catch (error) {
        console.error(`Error in agent ${this.name} thinking:`, error);
        return `[Agent ${this.name} encountered an error: ${error.message}]`;
      }
    });
  }
};
var AgentDebateEngine = class _AgentDebateEngine {
  // Default language
  constructor(agents, hostAgent, maxRounds = 3, language = "English") {
    this.round = 0;
    this.agents = [];
    this.messages = [];
    this.currentAgentIndex = 0;
    this.isRunning = false;
    this.isComplete = false;
    this.onMessageCallback = null;
    this.onCompleteCallback = null;
    this.onMessageUpdateCallback = null;
    this.language = "English";
    this.agents = agents;
    this.hostAgent = hostAgent;
    this.maxRounds = maxRounds;
    this.language = language;
  }
  getMessages() {
    return [...this.messages];
  }
  getStatus() {
    return {
      currentRound: this.round,
      currentAgentIndex: this.currentAgentIndex,
      isComplete: this.isComplete,
      messages: [...this.messages]
    };
  }
  onMessage(callback) {
    this.onMessageCallback = callback;
  }
  onComplete(callback) {
    this.onCompleteCallback = callback;
  }
  onMessageUpdate(callback) {
    this.onMessageUpdateCallback = callback;
  }
  resetDebate() {
    this.round = 0;
    this.messages = [];
    this.currentAgentIndex = 0;
    this.isRunning = false;
    this.isComplete = false;
  }
  startDebate(topic) {
    return __async(this, null, function* () {
      if (this.isRunning) {
        throw new Error("Debate is already running");
      }
      this.resetDebate();
      this.isRunning = true;
      try {
        const config = this.getConfig();
        const language = (config == null ? void 0 : config.language) || "English";
        const hostPrompt = `You are the host of a debate or discussion. Your role is to introduce the topic, establish the key points to be discussed, and guide the conversation.
      
      First, provide a thoughtful introduction to this topic: "${topic}"
      
      Then, outline the key aspects that should be discussed by our participants. What are the main points to consider?
      
      Please respond in ${language}.`;
        const hostMessageId = `msg_${Date.now()}`;
        const hostMessage = {
          id: hostMessageId,
          agentId: this.hostAgent.id,
          content: "",
          timestamp: Date.now(),
          round: 0,
          streaming: true
        };
        this.messages.push(hostMessage);
        if (this.onMessageCallback) {
          this.onMessageCallback(hostMessage);
        }
        const hostIntro = yield this.hostAgent.think(hostPrompt, "", (chunk) => {
          const messageIndex = this.messages.findIndex((m) => m.id === hostMessageId);
          if (messageIndex >= 0) {
            this.messages[messageIndex].content += chunk;
            if (this.onMessageUpdateCallback) {
              this.onMessageUpdateCallback(this.messages[messageIndex]);
            }
          }
        });
        const finalMessageIndex = this.messages.findIndex((m) => m.id === hostMessageId);
        if (finalMessageIndex >= 0) {
          this.messages[finalMessageIndex].streaming = false;
          if (this.onMessageUpdateCallback) {
            this.onMessageUpdateCallback(this.messages[finalMessageIndex]);
          }
        }
        yield this.runDebateRounds(topic);
        yield this.generateConclusion(topic);
        this.isComplete = true;
        this.isRunning = false;
        if (this.onCompleteCallback) {
          this.onCompleteCallback();
        }
      } catch (error) {
        console.error("Error running debate:", error);
        this.isRunning = false;
        throw error;
      }
    });
  }
  runDebateRounds(topic) {
    return __async(this, null, function* () {
      const context = this.buildDebateContext();
      const config = this.getConfig();
      const language = (config == null ? void 0 : config.language) || "English";
      for (this.round = 1; this.round <= this.maxRounds; this.round++) {
        for (let i = 0; i < this.agents.length; i++) {
          this.currentAgentIndex = i;
          const agent = this.agents[i];
          const updatedContext = this.buildDebateContext();
          const agentPrompt = `We are in round ${this.round} of the debate on: "${topic}"

Previous messages:
${updatedContext}

Based on the previous discussion, provide your perspective as ${agent.name}. 
Address points made by other participants if relevant, and further develop your own arguments.

Please respond in ${language}.`;
          const messageId = `msg_${Date.now()}_${agent.id}_${this.round}`;
          const message = {
            id: messageId,
            agentId: agent.id,
            content: "",
            timestamp: Date.now(),
            round: this.round,
            streaming: true
          };
          this.messages.push(message);
          if (this.onMessageCallback) {
            this.onMessageCallback(message);
          }
          yield agent.think(agentPrompt, "", (chunk) => {
            const messageIndex = this.messages.findIndex((m) => m.id === messageId);
            if (messageIndex >= 0) {
              this.messages[messageIndex].content += chunk;
              if (this.onMessageUpdateCallback) {
                this.onMessageUpdateCallback(this.messages[messageIndex]);
              }
            }
          });
          const finalMessageIndex = this.messages.findIndex((m) => m.id === messageId);
          if (finalMessageIndex >= 0) {
            this.messages[finalMessageIndex].streaming = false;
            if (this.onMessageUpdateCallback) {
              this.onMessageUpdateCallback(this.messages[finalMessageIndex]);
            }
          }
        }
      }
    });
  }
  generateConclusion(topic) {
    return __async(this, null, function* () {
      const context = this.buildDebateContext();
      const config = this.getConfig();
      const language = (config == null ? void 0 : config.language) || "English";
      const conclusionPrompt = `Now that we've completed ${this.maxRounds} rounds of our debate on "${topic}", please provide a thoughtful conclusion.

Summarize the key points made by each participant, identify areas of agreement and disagreement, and provide your own synthesis of the discussion.

The full debate transcript:
${context}

Please respond in ${language}.`;
      const conclusionId = `msg_conclusion_${Date.now()}`;
      const conclusionMessage = {
        id: conclusionId,
        agentId: this.hostAgent.id,
        content: "",
        timestamp: Date.now(),
        round: this.maxRounds + 1,
        streaming: true
      };
      this.messages.push(conclusionMessage);
      if (this.onMessageCallback) {
        this.onMessageCallback(conclusionMessage);
      }
      yield this.hostAgent.think(conclusionPrompt, "", (chunk) => {
        const messageIndex = this.messages.findIndex((m) => m.id === conclusionId);
        if (messageIndex >= 0) {
          this.messages[messageIndex].content += chunk;
          if (this.onMessageUpdateCallback) {
            this.onMessageUpdateCallback(this.messages[messageIndex]);
          }
        }
      });
      const finalMessageIndex = this.messages.findIndex((m) => m.id === conclusionId);
      if (finalMessageIndex >= 0) {
        this.messages[finalMessageIndex].streaming = false;
        if (this.onMessageUpdateCallback) {
          this.onMessageUpdateCallback(this.messages[finalMessageIndex]);
        }
      }
    });
  }
  buildDebateContext() {
    return this.messages.map((msg) => {
      const agent = this.agents.find((a) => a.id === msg.agentId) || this.hostAgent;
      return `[Round ${msg.round}] ${agent.name}: ${msg.content}`;
    }).join("\n\n");
  }
  static createFromConfig(config, modelManager) {
    const agents = config.agents.filter((a) => a.active).map((agentConfig) => new Agent(
      agentConfig.id,
      agentConfig.name,
      agentConfig.rolePrompt,
      agentConfig.modelId,
      modelManager
    ));
    const hostAgent = new Agent(
      config.hostAgent.id,
      config.hostAgent.name,
      config.hostAgent.rolePrompt,
      config.hostAgent.modelId,
      modelManager
    );
    return new _AgentDebateEngine(
      agents,
      hostAgent,
      config.maxRounds,
      config.language
    );
  }
  static generateDebatePrompts(mode) {
    const prompts = {
      host: "You are the host and moderator of this discussion. Your role is to introduce the topic, guide the conversation, ask probing questions, and ensure all perspectives are heard. At the end, you'll summarize the key points and provide a balanced conclusion.",
      positive: "You are advocating for the positive or affirmative position on this topic. Present the strongest arguments in favor, backed by reasoning and evidence where possible. Address counterarguments in a respectful way.",
      negative: "You are advocating for the negative or critical position on this topic. Present the strongest arguments against, backed by reasoning and evidence where possible. Address counterarguments in a respectful way.",
      blue: "Blue Hat (Process): You focus on managing the thinking process and ensuring productive discussion. You think about how to approach the problem, what thinking tools to use, and how to organize the conversation.",
      red: "Red Hat (Emotions): You focus on intuition, feelings, and emotional reactions. Express how the topic makes you feel, and consider the emotional aspects and impacts on people.",
      yellow: "Yellow Hat (Benefits): You focus on positivity, optimism, and benefits. Identify advantages, opportunities, and potential gains related to the topic.",
      green: "Green Hat (Creativity): You focus on creativity, alternatives, and new ideas. Propose innovative solutions, possibilities, and 'what if' scenarios related to the topic.",
      white: "White Hat (Facts): You focus on data, information, and objective facts. Provide relevant statistics, research findings, and verified information about the topic.",
      black: "Black Hat (Caution): You focus on critical judgment and potential problems. Identify risks, difficulties, and challenges related to the topic.",
      custom: "You are a participant in this discussion. Share your unique perspective on the topic based on your expertise and viewpoint."
    };
    switch (mode) {
      case "debate":
        prompts.host = "You are the host and moderator of this Pro vs Con debate. Your role is to introduce the topic, present both sides of the argument, and ensure a balanced discussion. Ask probing questions to both the proponent and opponent, ensuring key points are explored. At the end, summarize the main arguments from both sides without showing bias.";
        break;
      case "sixHats":
        prompts.host = "You are the host and facilitator of this Six Thinking Hats discussion. Your role is to introduce the topic and explain how the Six Thinking Hats method works. Guide the conversation through different perspectives: White Hat (facts), Red Hat (emotions), Black Hat (caution), Yellow Hat (benefits), Green Hat (creativity), and Blue Hat (process). Ensure each 'hat' perspective is explored fully before moving on. At the end, synthesize insights from all perspectives.";
        break;
      case "roundtable":
        prompts.host = "You are the host and moderator of this roundtable discussion. Your role is to introduce the topic, facilitate conversation between diverse experts, and ensure all perspectives are heard. Ask thought-provoking questions, find connections between different viewpoints, and guide the discussion toward deeper insights. At the end, summarize the key points and emergent themes.";
        break;
      case "smart":
        prompts.host = "You are the facilitator of a SMART goal-setting session. Your role is to guide participants in developing goals that are Specific, Measurable, Achievable, Relevant, and Time-bound. Introduce the topic and explain the SMART framework, then facilitate a structured conversation where each aspect of SMART is thoroughly explored. Help participants refine the goal until it meets all criteria. At the end, summarize the complete SMART goal that has been developed.";
        break;
      case "okr":
        prompts.host = "You are the facilitator of an OKR (Objectives and Key Results) development session. Your role is to guide participants in creating inspiring, qualitative Objectives paired with measurable Key Results. Introduce the topic and explain the OKR framework, then facilitate a structured conversation to first identify ambitious Objectives and then establish concrete Key Results to measure progress. At the end, summarize the complete OKR set that has been developed.";
        break;
      case "swot":
        prompts.host = "You are the facilitator of a SWOT analysis session. Your role is to guide participants in analyzing Strengths, Weaknesses, Opportunities, and Threats related to the topic. Introduce the topic and explain the SWOT framework, then facilitate a structured conversation where internal factors (Strengths and Weaknesses) and external factors (Opportunities and Threats) are thoroughly explored. At the end, synthesize the analysis into actionable insights.";
        break;
      case "pest":
        prompts.host = "You are the facilitator of a PEST analysis session. Your role is to guide participants in analyzing Political, Economic, Social, and Technological factors impacting the topic. Introduce the topic and explain the PEST framework, then facilitate a structured exploration of each factor and its implications. At the end, synthesize the analysis to provide a comprehensive view of the external environment affecting the topic.";
        break;
      case "premortem":
        prompts.host = "You are the facilitator of a Pre-Mortem analysis session. Your role is to guide participants in imagining that a project has failed completely, then working backward to identify what could have gone wrong. Introduce the topic and explain the Pre-Mortem concept, then facilitate a structured conversation that begins with visualizing failure and moves toward identifying risks and preventative measures. At the end, summarize the key risks and mitigation strategies identified.";
        break;
      case "fivewhys":
        prompts.host = "You are the facilitator of a 5 Whys analysis session. Your role is to guide participants in identifying the root cause of a problem by repeatedly asking 'Why?' Introduce the problem and explain the 5 Whys technique, then facilitate a deep-dive conversation that progressively moves from symptoms to root causes. At the end, summarize the root cause(s) identified and the potential solutions that address these fundamental issues.";
        break;
      case "fishbone":
        prompts.host = "You are the facilitator of a Fishbone Diagram (Cause and Effect) analysis session. Your role is to guide participants in identifying multiple categories of causes contributing to a problem. Introduce the problem and explain the Fishbone Diagram concept, then facilitate a structured conversation exploring different causal categories such as People, Process, Equipment, Materials, Environment, and Management. At the end, synthesize the analysis to provide a comprehensive view of the problem's causes.";
        break;
      case "rubberduck":
        prompts.host = "You are the facilitator of a Rubber Duck Debugging session. Your role is to guide participants in articulating their problem clearly by explaining it step by step, as if to a rubber duck. Introduce the concept and explain how the act of detailed explanation often reveals solutions. Your primary job is to ask clarifying questions that prompt deeper explanation, occasionally asking 'And what happens next?' or 'Why does that work that way?' At the end, help synthesize any insights or solutions that emerged through the explanation process.";
        break;
      case "scamper":
        prompts.host = "You are the facilitator of a SCAMPER ideation session. Your role is to guide participants in generating creative ideas by applying the SCAMPER techniques: Substitute, Combine, Adapt, Modify, Put to another use, Eliminate, and Reverse. Introduce the topic and explain the SCAMPER method, then facilitate a structured conversation exploring each technique. At the end, summarize the most promising ideas generated through this creative process.";
        break;
      case "lateralthinking":
        prompts.host = "You are the facilitator of a Lateral Thinking session. Your role is to guide participants in breaking conventional thinking patterns to generate novel solutions. Introduce the topic and explain lateral thinking techniques, such as challenging assumptions, using random stimuli, considering alternatives, and provocative thinking. As you facilitate, encourage participants to make unexpected connections and explore ideas that initially seem unrelated or impractical. At the end, summarize the innovative insights and approaches that emerged.";
        break;
      case "pmi":
        prompts.host = "You are the facilitator of a PMI (Plus, Minus, Interesting) analysis session. Your role is to guide participants in evaluating an idea by systematically identifying its positive aspects, negative aspects, and interesting implications. Introduce the topic and explain the PMI framework, then facilitate a structured conversation that explores each category without bias. At the end, synthesize the analysis to provide a balanced evaluation that acknowledges benefits, drawbacks, and thought-provoking dimensions.";
        break;
      case "doublediamond":
        prompts.host = "You are the facilitator of a Double Diamond design thinking session. Your role is to guide participants through the four phases: Discover (exploring the problem space), Define (focusing on the specific problem), Develop (exploring potential solutions), and Deliver (focusing on a specific solution). Introduce the topic and explain the Double Diamond framework, then facilitate a structured conversation that alternates between divergent and convergent thinking. At the end, summarize the journey from problem exploration to solution delivery.";
        break;
      case "feynman":
        prompts.host = "You are the facilitator of a Feynman Technique learning session. Your role is to guide participants in explaining a complex concept in simple terms, identifying knowledge gaps, and refining the explanation until it demonstrates complete understanding. Introduce the topic and explain the Feynman Technique, then facilitate a process where participants attempt to explain the concept simply, identify gaps in their understanding, and refine their explanation. At the end, help participants synthesize the clear, jargon-free explanation that has emerged.";
        break;
      case "grow":
        prompts.host = "You are the facilitator of a GROW coaching model session. Your role is to guide participants through the four phases: establishing Goals, examining Reality, exploring Options, and determining the Way forward (Will). Introduce the topic and explain the GROW framework, then facilitate a structured conversation that methodically explores each element. Ask powerful questions in each phase to prompt reflection and clarity. At the end, ensure participants have a clear action plan with specific commitments.";
        break;
    }
    return prompts;
  }
  static generateDefaultConfig(topic, mode, defaultModelId, language = "English") {
    const prompts = _AgentDebateEngine.generateDebatePrompts(mode);
    const timestamp = Date.now();
    let agents = [];
    switch (mode) {
      case "debate":
        agents = [
          {
            id: `agent_positive_${timestamp}`,
            name: "Proponent",
            role: "positive",
            rolePrompt: prompts.positive,
            modelId: defaultModelId,
            active: true
          },
          {
            id: `agent_negative_${timestamp}`,
            name: "Opponent",
            role: "negative",
            rolePrompt: prompts.negative,
            modelId: defaultModelId,
            active: true
          }
        ];
        break;
      case "sixHats":
        agents = [
          {
            id: `agent_white_${timestamp}`,
            name: "White Hat (Facts)",
            role: "white",
            rolePrompt: prompts.white,
            modelId: defaultModelId,
            active: true
          },
          {
            id: `agent_red_${timestamp}`,
            name: "Red Hat (Emotions)",
            role: "red",
            rolePrompt: prompts.red,
            modelId: defaultModelId,
            active: true
          },
          {
            id: `agent_black_${timestamp}`,
            name: "Black Hat (Caution)",
            role: "black",
            rolePrompt: prompts.black,
            modelId: defaultModelId,
            active: true
          },
          {
            id: `agent_yellow_${timestamp}`,
            name: "Yellow Hat (Benefits)",
            role: "yellow",
            rolePrompt: prompts.yellow,
            modelId: defaultModelId,
            active: true
          },
          {
            id: `agent_green_${timestamp}`,
            name: "Green Hat (Creativity)",
            role: "green",
            rolePrompt: prompts.green,
            modelId: defaultModelId,
            active: true
          },
          {
            id: `agent_blue_${timestamp}`,
            name: "Blue Hat (Process)",
            role: "blue",
            rolePrompt: prompts.blue,
            modelId: defaultModelId,
            active: true
          }
        ];
        break;
      case "roundtable":
        agents = [
          {
            id: `agent_expert1_${timestamp}`,
            name: "Subject Matter Expert",
            role: "custom",
            rolePrompt: "You are a subject matter expert with deep knowledge of this topic. Provide factual information, historical context, and technical details that help illuminate the discussion.",
            modelId: defaultModelId,
            active: true
          },
          {
            id: `agent_critic_${timestamp}`,
            name: "Critical Analyst",
            role: "custom",
            rolePrompt: "You analyze the topic critically, looking for logical flaws, inconsistencies, and areas that deserve more scrutiny. Your goal is to strengthen the discussion through thoughtful criticism.",
            modelId: defaultModelId,
            active: true
          },
          {
            id: `agent_innovator_${timestamp}`,
            name: "Innovator",
            role: "custom",
            rolePrompt: "You specialize in finding new approaches and creative solutions. Consider how the topic could be reimagined or what novel perspectives might add value to the discussion.",
            modelId: defaultModelId,
            active: true
          },
          {
            id: `agent_custom_${timestamp}`,
            name: "Custom",
            role: "custom",
            rolePrompt: "You are a custom participant in this discussion. Share your unique perspective on the topic based on your expertise and viewpoint.",
            modelId: defaultModelId,
            active: true
          }
        ];
        break;
      // Strategic & Goal Setting Models
      case "smart":
        agents = [
          {
            id: `agent_specific_${timestamp}`,
            name: "Specific Focus",
            role: "custom",
            rolePrompt: "You focus on ensuring goals are specific and well-defined. Analyze the topic to identify precisely what needs to be accomplished, addressing the what, why, and how.",
            modelId: defaultModelId,
            active: true
          },
          {
            id: `agent_measurable_${timestamp}`,
            name: "Measurable Criteria",
            role: "custom",
            rolePrompt: "You specialize in establishing measurable criteria for success. Identify how progress and success will be tracked and quantified for this goal or project.",
            modelId: defaultModelId,
            active: true
          },
          {
            id: `agent_achievable_${timestamp}`,
            name: "Achievability Analyst",
            role: "custom",
            rolePrompt: "You assess whether goals are realistically achievable. Evaluate the resources, constraints, and capabilities to determine if the objective is actually attainable.",
            modelId: defaultModelId,
            active: true
          },
          {
            id: `agent_relevant_${timestamp}`,
            name: "Relevance Advisor",
            role: "custom",
            rolePrompt: "You focus on ensuring goals are relevant to broader objectives. Analyze how this specific goal aligns with overall strategy, mission, and priorities.",
            modelId: defaultModelId,
            active: true
          },
          {
            id: `agent_timebound_${timestamp}`,
            name: "Time Constraints",
            role: "custom",
            rolePrompt: "You specialize in establishing appropriate timeframes. Determine realistic deadlines, milestones, and time constraints for achieving this goal.",
            modelId: defaultModelId,
            active: true
          }
        ];
        break;
      case "okr":
        agents = [
          {
            id: `agent_objective_${timestamp}`,
            name: "Objective Setter",
            role: "custom",
            rolePrompt: "You focus on defining clear, inspiring objectives. Create ambitious, qualitative goals that are aligned with the organization's mission and vision.",
            modelId: defaultModelId,
            active: true
          },
          {
            id: `agent_keyresults_${timestamp}`,
            name: "Key Results Definer",
            role: "custom",
            rolePrompt: "You specialize in establishing measurable key results. Define specific, quantifiable outcomes that will indicate whether the objective has been achieved.",
            modelId: defaultModelId,
            active: true
          },
          {
            id: `agent_alignment_${timestamp}`,
            name: "Alignment Specialist",
            role: "custom",
            rolePrompt: "You analyze how OKRs align across different levels. Ensure that individual and team OKRs support organizational objectives and create coherent direction.",
            modelId: defaultModelId,
            active: true
          },
          {
            id: `agent_stretch_${timestamp}`,
            name: "Stretch Goals Advocate",
            role: "custom",
            rolePrompt: "You advocate for setting ambitious stretch goals. Push for aspirational targets that encourage innovation and breakthrough thinking.",
            modelId: defaultModelId,
            active: true
          }
        ];
        break;
      case "swot":
        agents = [
          {
            id: `agent_strengths_${timestamp}`,
            name: "Strengths Analyst",
            role: "custom",
            rolePrompt: "You identify internal strengths and advantages. Analyze what the organization or idea does well, its unique resources, and competitive advantages.",
            modelId: defaultModelId,
            active: true
          },
          {
            id: `agent_weaknesses_${timestamp}`,
            name: "Weaknesses Evaluator",
            role: "custom",
            rolePrompt: "You identify internal weaknesses and limitations. Analyze areas for improvement, resource gaps, and competitive disadvantages.",
            modelId: defaultModelId,
            active: true
          },
          {
            id: `agent_opportunities_${timestamp}`,
            name: "Opportunities Scout",
            role: "custom",
            rolePrompt: "You identify external opportunities. Analyze market trends, technological advancements, and changes in the environment that could be beneficial.",
            modelId: defaultModelId,
            active: true
          },
          {
            id: `agent_threats_${timestamp}`,
            name: "Threats Monitor",
            role: "custom",
            rolePrompt: "You identify external threats and challenges. Analyze competitive pressures, shifting regulations, and other risks from the environment.",
            modelId: defaultModelId,
            active: true
          }
        ];
        break;
      case "pest":
        agents = [
          {
            id: `agent_political_${timestamp}`,
            name: "Political Factors Analyst",
            role: "custom",
            rolePrompt: "You analyze political factors affecting the topic. Consider government policies, political stability, regulations, and legal frameworks that impact the situation.",
            modelId: defaultModelId,
            active: true
          },
          {
            id: `agent_economic_${timestamp}`,
            name: "Economic Factors Analyst",
            role: "custom",
            rolePrompt: "You analyze economic factors affecting the topic. Consider economic trends, market dynamics, inflation, interest rates, and financial considerations.",
            modelId: defaultModelId,
            active: true
          },
          {
            id: `agent_social_${timestamp}`,
            name: "Social Factors Analyst",
            role: "custom",
            rolePrompt: "You analyze social and cultural factors affecting the topic. Consider demographics, cultural trends, social values, consumer behavior, and lifestyle changes.",
            modelId: defaultModelId,
            active: true
          },
          {
            id: `agent_technological_${timestamp}`,
            name: "Technological Factors Analyst",
            role: "custom",
            rolePrompt: "You analyze technological factors affecting the topic. Consider innovations, digital transformation, research advancements, and technological disruptions.",
            modelId: defaultModelId,
            active: true
          }
        ];
        break;
      // Problem Finding Models
      case "premortem":
        agents = [
          {
            id: `agent_failure_scenario_${timestamp}`,
            name: "Failure Scenario Creator",
            role: "custom",
            rolePrompt: "You imagine the project has completely failed. Vividly describe what this failure looks like and its consequences, working backward from this hypothetical disaster.",
            modelId: defaultModelId,
            active: true
          },
          {
            id: `agent_risk_identifier_${timestamp}`,
            name: "Risk Identifier",
            role: "custom",
            rolePrompt: "You identify specific risks that could lead to failure. List and analyze potential problems, obstacles, and failure points that might arise during implementation.",
            modelId: defaultModelId,
            active: true
          },
          {
            id: `agent_prevention_${timestamp}`,
            name: "Prevention Strategist",
            role: "custom",
            rolePrompt: "You develop strategies to prevent identified risks. Propose specific preventative measures and contingency plans to address each potential failure point.",
            modelId: defaultModelId,
            active: true
          },
          {
            id: `agent_resilience_${timestamp}`,
            name: "Resilience Builder",
            role: "custom",
            rolePrompt: "You focus on building resilience into the plan. Suggest ways to make the project more robust and able to recover quickly if things go wrong.",
            modelId: defaultModelId,
            active: true
          }
        ];
        break;
      case "fivewhys":
        agents = [
          {
            id: `agent_problem_${timestamp}`,
            name: "Problem Definer",
            role: "custom",
            rolePrompt: "You clearly define the initial problem. Articulate exactly what issue we're trying to solve and establish the starting point for analysis.",
            modelId: defaultModelId,
            active: true
          },
          {
            id: `agent_why1_${timestamp}`,
            name: "First Why Explorer",
            role: "custom",
            rolePrompt: "You ask the first 'why' question. Identify the immediate causes of the problem and begin peeling back the first layer.",
            modelId: defaultModelId,
            active: true
          },
          {
            id: `agent_why2_${timestamp}`,
            name: "Second Why Explorer",
            role: "custom",
            rolePrompt: "You ask the second 'why' question. Dig deeper into the causes identified in the first round and explore the next layer of causation.",
            modelId: defaultModelId,
            active: true
          },
          {
            id: `agent_why3_${timestamp}`,
            name: "Third Why Explorer",
            role: "custom",
            rolePrompt: "You ask the third 'why' question. Continue probing deeper into root causes, moving beyond symptoms and obvious explanations.",
            modelId: defaultModelId,
            active: true
          },
          {
            id: `agent_solution_${timestamp}`,
            name: "Root Cause Analyst",
            role: "custom",
            rolePrompt: "You synthesize the findings from all the 'why' questions to identify the root cause. Then propose sustainable solutions that address this fundamental issue.",
            modelId: defaultModelId,
            active: true
          }
        ];
        break;
      case "fishbone":
        agents = [
          {
            id: `agent_problem_definer_${timestamp}`,
            name: "Problem Definer",
            role: "custom",
            rolePrompt: "You clearly articulate the problem or effect being analyzed. Define what issue we're trying to understand the causes of.",
            modelId: defaultModelId,
            active: true
          },
          {
            id: `agent_people_${timestamp}`,
            name: "People Factors Analyst",
            role: "custom",
            rolePrompt: "You analyze how people-related factors contribute to the problem. Consider skills, training, staffing, communication, and human factors.",
            modelId: defaultModelId,
            active: true
          },
          {
            id: `agent_process_${timestamp}`,
            name: "Process Factors Analyst",
            role: "custom",
            rolePrompt: "You analyze how process-related factors contribute to the problem. Consider workflows, procedures, efficiency, and methodologies.",
            modelId: defaultModelId,
            active: true
          },
          {
            id: `agent_environment_${timestamp}`,
            name: "Environment Factors Analyst",
            role: "custom",
            rolePrompt: "You analyze how environmental factors contribute to the problem. Consider physical conditions, organizational culture, and external influences.",
            modelId: defaultModelId,
            active: true
          },
          {
            id: `agent_materials_${timestamp}`,
            name: "Materials Factors Analyst",
            role: "custom",
            rolePrompt: "You analyze how materials and resources contribute to the problem. Consider quality, availability, and appropriateness of inputs.",
            modelId: defaultModelId,
            active: true
          }
        ];
        break;
      case "rubberduck":
        agents = [
          {
            id: `agent_problem_articulator_${timestamp}`,
            name: "Problem Articulator",
            role: "custom",
            rolePrompt: "You help the user clearly explain the problem they're facing. Ask clarifying questions to ensure the problem is fully articulated.",
            modelId: defaultModelId,
            active: true
          },
          {
            id: `agent_solution_explorer_${timestamp}`,
            name: "Solution Explorer",
            role: "custom",
            rolePrompt: "You ask questions about potential solutions and approaches. Help the user talk through their ideas for solving the problem.",
            modelId: defaultModelId,
            active: true
          },
          {
            id: `agent_logic_checker_${timestamp}`,
            name: "Logic Checker",
            role: "custom",
            rolePrompt: "You look for logical inconsistencies or gaps in reasoning. Point out areas where the user's approach might have flaws or assumptions.",
            modelId: defaultModelId,
            active: true
          },
          {
            id: `agent_rubberduck_${timestamp}`,
            name: "Rubber Duck",
            role: "custom",
            rolePrompt: "You are the rubber duck. Listen attentively, occasionally ask 'And then what happens?' or 'Why does that work?' to prompt deeper explanation. Your goal is to help the user reach their own insights.",
            modelId: defaultModelId,
            active: true
          }
        ];
        break;
      // Creative Thinking Models
      case "scamper":
        agents = [
          {
            id: `agent_substitute_${timestamp}`,
            name: "Substitute Thinker",
            role: "custom",
            rolePrompt: "You focus on substitution possibilities. Explore what could replace or change parts of the current solution, product, or approach.",
            modelId: defaultModelId,
            active: true
          },
          {
            id: `agent_combine_${timestamp}`,
            name: "Combination Expert",
            role: "custom",
            rolePrompt: "You focus on combination possibilities. Explore how to merge components, ideas, or functions to create new solutions.",
            modelId: defaultModelId,
            active: true
          },
          {
            id: `agent_adapt_${timestamp}`,
            name: "Adaptation Specialist",
            role: "custom",
            rolePrompt: "You focus on adaptation possibilities. Explore how existing solutions from other contexts could be adapted to solve this problem.",
            modelId: defaultModelId,
            active: true
          },
          {
            id: `agent_modify_${timestamp}`,
            name: "Modification Expert",
            role: "custom",
            rolePrompt: "You focus on modification possibilities. Explore how to change the size, shape, or other attributes to improve the solution.",
            modelId: defaultModelId,
            active: true
          },
          {
            id: `agent_purpose_${timestamp}`,
            name: "Purpose Reevaluator",
            role: "custom",
            rolePrompt: "You focus on purpose possibilities. Explore alternative uses or applications for existing ideas or products.",
            modelId: defaultModelId,
            active: true
          }
        ];
        break;
      case "lateralthinking":
        agents = [
          {
            id: `agent_assumptionchallenger_${timestamp}`,
            name: "Assumption Challenger",
            role: "custom",
            rolePrompt: "You identify and challenge assumptions. Question the conventional thinking and established boundaries that may be limiting solutions.",
            modelId: defaultModelId,
            active: true
          },
          {
            id: `agent_randomstimuli_${timestamp}`,
            name: "Random Stimuli Provider",
            role: "custom",
            rolePrompt: "You introduce unexpected concepts or ideas. Bring in seemingly unrelated elements to spark new connections and directions of thought.",
            modelId: defaultModelId,
            active: true
          },
          {
            id: `agent_reversethinker_${timestamp}`,
            name: "Reverse Thinker",
            role: "custom",
            rolePrompt: "You consider reverse or opposite approaches. Explore what would happen if we did the opposite of what seems logical or expected.",
            modelId: defaultModelId,
            active: true
          },
          {
            id: `agent_provocateur_${timestamp}`,
            name: "Provocateur",
            role: "custom",
            rolePrompt: "You make provocative statements to disrupt thinking patterns. Propose unexpected or even seemingly absurd ideas to break conventional thinking.",
            modelId: defaultModelId,
            active: true
          }
        ];
        break;
      case "pmi":
        agents = [
          {
            id: `agent_plus_${timestamp}`,
            name: "Plus Points Identifier",
            role: "custom",
            rolePrompt: "You identify all positive aspects of the idea or proposal. Analyze benefits, advantages, and potential gains without criticism.",
            modelId: defaultModelId,
            active: true
          },
          {
            id: `agent_minus_${timestamp}`,
            name: "Minus Points Identifier",
            role: "custom",
            rolePrompt: "You identify all negative aspects of the idea or proposal. Analyze drawbacks, risks, and potential problems without bias.",
            modelId: defaultModelId,
            active: true
          },
          {
            id: `agent_interesting_${timestamp}`,
            name: "Interesting Points Identifier",
            role: "custom",
            rolePrompt: "You identify all interesting or neutral aspects that are neither clearly positive nor negative. Analyze implications, questions raised, and potential consequences.",
            modelId: defaultModelId,
            active: true
          },
          {
            id: `agent_conclusion_${timestamp}`,
            name: "Balanced Evaluator",
            role: "custom",
            rolePrompt: "You synthesize the Plus, Minus, and Interesting points to form a balanced evaluation. Weigh all factors to provide a comprehensive assessment.",
            modelId: defaultModelId,
            active: true
          }
        ];
        break;
      case "doublediamond":
        agents = [
          {
            id: `agent_discover_${timestamp}`,
            name: "Problem Discoverer",
            role: "custom",
            rolePrompt: "You focus on the Discover phase. Explore broadly to gather insights about user needs, market context, and existing solutions, taking a divergent thinking approach to understanding the problem space.",
            modelId: defaultModelId,
            active: true
          },
          {
            id: `agent_define_${timestamp}`,
            name: "Problem Definer",
            role: "custom",
            rolePrompt: "You focus on the Define phase. Synthesize findings from discovery to clearly articulate the core problem, taking a convergent thinking approach to create a focused problem statement.",
            modelId: defaultModelId,
            active: true
          },
          {
            id: `agent_develop_${timestamp}`,
            name: "Solution Developer",
            role: "custom",
            rolePrompt: "You focus on the Develop phase. Generate multiple potential solutions to address the defined problem, taking a divergent thinking approach to explore various possible solutions.",
            modelId: defaultModelId,
            active: true
          },
          {
            id: `agent_deliver_${timestamp}`,
            name: "Solution Deliverer",
            role: "custom",
            rolePrompt: "You focus on the Deliver phase. Refine and finalize the most promising solution concept, taking a convergent thinking approach to create a concrete, implementable solution.",
            modelId: defaultModelId,
            active: true
          }
        ];
        break;
      // Learning Models
      case "feynman":
        agents = [
          {
            id: `agent_conceptexplainer_${timestamp}`,
            name: "Concept Explainer",
            role: "custom",
            rolePrompt: "You explain complex concepts in simple language. Break down the topic into its most fundamental components and explain them as if to a complete beginner.",
            modelId: defaultModelId,
            active: true
          },
          {
            id: `agent_analogymaker_${timestamp}`,
            name: "Analogy Creator",
            role: "custom",
            rolePrompt: "You create simple analogies and metaphors. Connect complex ideas to everyday experiences that anyone can understand.",
            modelId: defaultModelId,
            active: true
          },
          {
            id: `agent_gapfinder_${timestamp}`,
            name: "Knowledge Gap Finder",
            role: "custom",
            rolePrompt: "You identify knowledge gaps in the explanation. Point out where understanding is incomplete or where the explanation relies on jargon or complex concepts that haven't been broken down.",
            modelId: defaultModelId,
            active: true
          },
          {
            id: `agent_teacher_${timestamp}`,
            name: "Teacher",
            role: "custom",
            rolePrompt: "You reconstruct the explanation as if teaching it to someone else. Deliver a clear, concise explanation that demonstrates complete understanding without technical jargon.",
            modelId: defaultModelId,
            active: true
          }
        ];
        break;
      case "grow":
        agents = [
          {
            id: `agent_goal_${timestamp}`,
            name: "Goal Setting Guide",
            role: "custom",
            rolePrompt: "You focus on the Goal aspect. Help define clear, inspiring goals and what the person wants to achieve in this situation.",
            modelId: defaultModelId,
            active: true
          },
          {
            id: `agent_reality_${timestamp}`,
            name: "Reality Assessor",
            role: "custom",
            rolePrompt: "You focus on the Reality aspect. Explore the current situation objectively, examining facts, resources, obstacles, and previous attempts.",
            modelId: defaultModelId,
            active: true
          },
          {
            id: `agent_options_${timestamp}`,
            name: "Options Explorer",
            role: "custom",
            rolePrompt: "You focus on the Options aspect. Generate and explore possible strategies, approaches, and alternatives for achieving the goal.",
            modelId: defaultModelId,
            active: true
          },
          {
            id: `agent_will_${timestamp}`,
            name: "Will Strengthener",
            role: "custom",
            rolePrompt: "You focus on the Will aspect. Help establish concrete action steps, address potential obstacles, and build commitment to moving forward.",
            modelId: defaultModelId,
            active: true
          }
        ];
        break;
    }
    const hostAgent = {
      id: `host_${timestamp}`,
      name: "Host",
      role: "host",
      rolePrompt: prompts.host,
      modelId: defaultModelId,
      active: true
    };
    return {
      id: `debate_${timestamp}`,
      title: `Debate on ${topic}`,
      topic,
      mode,
      agents,
      hostAgent,
      maxRounds: 3,
      maxTokensPerResponse: 1e3,
      createdAt: timestamp,
      active: true,
      language
    };
  }
  // Helper method to get config from debate context
  getConfig() {
    return {
      id: "",
      title: "",
      topic: "",
      mode: "debate",
      agents: [],
      hostAgent: { id: "", name: "", role: "host", rolePrompt: "", modelId: "", active: true },
      maxRounds: this.maxRounds,
      maxTokensPerResponse: 1e3,
      createdAt: Date.now(),
      active: true,
      language: this.language
    };
  }
};

// src/debate/DebatePanel.ts
var DEBATE_VIEW_TYPE = "aipilot-debate-view";
var DebatePanel = class extends import_obsidian3.ItemView {
  constructor(leaf, modelManager) {
    super(leaf);
    this.debateEngine = null;
    this.debateConfig = null;
    this.modelManager = modelManager;
  }
  getViewType() {
    return DEBATE_VIEW_TYPE;
  }
  getDisplayText() {
    return "Debate & Reasoning";
  }
  onOpen() {
    return __async(this, null, function* () {
      this.containerEl = this.contentEl.createDiv({ cls: "debate-view-container" });
      this.createHeader();
      this.createConfigPanel();
      this.createMessagesContainer();
      this.createStatusBar();
      this.initializeDefaultConfig();
    });
  }
  onClose() {
    return __async(this, null, function* () {
    });
  }
  createHeader() {
    const headerEl = this.containerEl.createDiv({ cls: "debate-header" });
    const titleEl = headerEl.createEl("h2", { text: "AI Agent Debate" });
    const descriptionEl = headerEl.createEl("p", {
      text: "Create a multi-agent debate or discussion on any topic. Select a debate mode, configure your settings, and let multiple AI agents discuss the topic from different perspectives."
    });
  }
  createConfigPanel() {
    const configPanelEl = this.containerEl.createDiv({ cls: "debate-config-panel" });
    const headerEl = configPanelEl.createEl("h2", { text: "AI Agent Debate" });
    const topicWrapperEl = configPanelEl.createDiv({ cls: "config-input-wrapper" });
    topicWrapperEl.createEl("label", { text: "Topic", attr: { for: "debate-topic" } });
    this.topicInputEl = topicWrapperEl.createEl("input", {
      cls: "debate-topic-input",
      attr: {
        id: "debate-topic",
        type: "text",
        placeholder: "Enter debate topic"
      }
    });
    const languageWrapperEl = configPanelEl.createDiv({ cls: "config-input-wrapper" });
    languageWrapperEl.createEl("label", { text: "Language", attr: { for: "debate-language" } });
    this.languageSelectEl = languageWrapperEl.createEl("select", {
      cls: "debate-language-select",
      attr: { id: "debate-language" }
    });
    const languages = [
      "English",
      "Spanish",
      "French",
      "German",
      "Chinese",
      "Japanese",
      "Russian",
      "Arabic",
      "Hindi",
      "Portuguese",
      "Italian",
      "Dutch",
      "Korean",
      "Turkish",
      "Swedish",
      "Polish",
      "Vietnamese",
      "Thai",
      "Greek",
      "Hebrew"
    ];
    languages.forEach((lang) => {
      this.languageSelectEl.createEl("option", {
        text: lang,
        attr: { value: lang }
      });
    });
    const modeContainerEl = configPanelEl.createDiv({ cls: "config-item config-row" });
    const modeWrapperEl = modeContainerEl.createDiv({ cls: "config-input-wrapper" });
    modeWrapperEl.createEl("label", { text: "Debate Mode", attr: { for: "debate-mode" } });
    this.modeSelectEl = modeWrapperEl.createEl("select", {
      cls: "debate-mode-select",
      attr: { id: "debate-mode" }
    });
    const basicGroup = this.modeSelectEl.createEl("optgroup", { attr: { label: "Basic Debate Types" } });
    basicGroup.createEl("option", { text: "Debate (Pro vs Con)", attr: { value: "debate" } });
    basicGroup.createEl("option", { text: "Six Thinking Hats", attr: { value: "sixHats" } });
    basicGroup.createEl("option", { text: "Roundtable Discussion", attr: { value: "roundtable" } });
    const strategicGroup = this.modeSelectEl.createEl("optgroup", { attr: { label: "Strategic Thinking Models" } });
    strategicGroup.createEl("option", { text: "SMART Goals", attr: { value: "smart" } });
    strategicGroup.createEl("option", { text: "OKR Framework", attr: { value: "okr" } });
    strategicGroup.createEl("option", { text: "SWOT Analysis", attr: { value: "swot" } });
    strategicGroup.createEl("option", { text: "PEST Analysis", attr: { value: "pest" } });
    const problemGroup = this.modeSelectEl.createEl("optgroup", { attr: { label: "Problem Finding Models" } });
    problemGroup.createEl("option", { text: "Pre-Mortem Analysis", attr: { value: "premortem" } });
    problemGroup.createEl("option", { text: "5 Whys Method", attr: { value: "fivewhys" } });
    problemGroup.createEl("option", { text: "Fishbone Diagram", attr: { value: "fishbone" } });
    problemGroup.createEl("option", { text: "Rubber Duck Debugging", attr: { value: "rubberduck" } });
    const creativeGroup = this.modeSelectEl.createEl("optgroup", { attr: { label: "Creative Thinking Models" } });
    creativeGroup.createEl("option", { text: "SCAMPER Method", attr: { value: "scamper" } });
    creativeGroup.createEl("option", { text: "Lateral Thinking", attr: { value: "lateralthinking" } });
    creativeGroup.createEl("option", { text: "PMI Analysis", attr: { value: "pmi" } });
    creativeGroup.createEl("option", { text: "Double Diamond", attr: { value: "doublediamond" } });
    const learningGroup = this.modeSelectEl.createEl("optgroup", { attr: { label: "Learning Models" } });
    learningGroup.createEl("option", { text: "Feynman Technique", attr: { value: "feynman" } });
    learningGroup.createEl("option", { text: "GROW Model", attr: { value: "grow" } });
    this.modeSelectEl.addEventListener("change", () => this.onModeChange());
    const roundsWrapperEl = modeContainerEl.createDiv({ cls: "config-input-wrapper" });
    roundsWrapperEl.createEl("label", { text: "Rounds", attr: { for: "debate-rounds" } });
    this.roundsInputEl = roundsWrapperEl.createEl("input", {
      cls: "debate-rounds-input",
      attr: {
        id: "debate-rounds",
        type: "number",
        min: "1",
        max: "5",
        value: "3"
      }
    });
    this.controlsEl = configPanelEl.createDiv({ cls: "debate-controls" });
    this.startButtonEl = this.controlsEl.createEl("button", {
      cls: "debate-start-button",
      text: "Start Debate"
    });
    this.startButtonEl.addEventListener("click", () => this.startDebate());
    this.exportButtonEl = this.controlsEl.createEl("button", {
      cls: "debate-export-button",
      text: "Export to Note",
      attr: { disabled: "true" }
    });
    this.exportButtonEl.addEventListener("click", () => this.exportToNote());
  }
  createMessagesContainer() {
    this.messagesContainerEl = this.containerEl.createDiv({ cls: "debate-messages-container" });
    const emptyStateEl = this.messagesContainerEl.createDiv({ cls: "debate-empty-state" });
    const emptyIconEl = emptyStateEl.createDiv({ cls: "debate-empty-icon" });
    emptyStateEl.createEl("h3", { text: "No Active Debate" });
    emptyStateEl.createEl("p", {
      text: 'Configure your debate settings above and click "Start Debate" to begin a new multi-agent discussion.'
    });
  }
  createStatusBar() {
    this.statusEl = this.containerEl.createDiv({ cls: "debate-status-bar" });
    this.statusEl.textContent = "Ready to start";
  }
  initializeDefaultConfig() {
    const models = this.modelManager.getModels();
    const defaultModelId = models.length > 0 ? models[0].id : "default_model_id";
    this.debateConfig = AgentDebateEngine.generateDefaultConfig(
      "",
      "debate",
      defaultModelId,
      this.languageSelectEl.value
    );
  }
  onModeChange() {
    if (!this.debateConfig) return;
    const selectedMode = this.modeSelectEl.value;
    const topic = this.topicInputEl.value.trim();
    const language = this.languageSelectEl.value;
    const models = this.modelManager.getModels();
    const defaultModelId = models.length > 0 ? models[0].id : "default_model_id";
    this.debateConfig = AgentDebateEngine.generateDefaultConfig(
      topic,
      selectedMode,
      defaultModelId,
      language
    );
  }
  startDebate() {
    return __async(this, null, function* () {
      const topic = this.topicInputEl.value.trim();
      if (!topic) {
        new import_obsidian3.Notice("Please enter a topic for the debate");
        return;
      }
      if (!this.debateConfig) {
        new import_obsidian3.Notice("Debate configuration not initialized");
        return;
      }
      const rounds = parseInt(this.roundsInputEl.value);
      if (rounds > 0) {
        this.debateConfig.maxRounds = rounds;
      }
      this.debateConfig.topic = topic;
      this.debateConfig.language = this.languageSelectEl.value;
      this.messagesContainerEl.empty();
      this.statusEl.textContent = "Starting debate...";
      this.startButtonEl.disabled = true;
      this.startButtonEl.textContent = "Debate in Progress...";
      try {
        this.debateEngine = AgentDebateEngine.createFromConfig(
          this.debateConfig,
          this.modelManager
        );
        this.debateEngine.onMessage((message) => {
          this.renderMessage(message);
          this.messagesContainerEl.scrollTo({
            top: this.messagesContainerEl.scrollHeight,
            behavior: "smooth"
          });
        });
        this.debateEngine.onMessageUpdate((message) => {
          this.updateMessage(message);
          this.messagesContainerEl.scrollTo({
            top: this.messagesContainerEl.scrollHeight,
            behavior: "smooth"
          });
        });
        this.debateEngine.onComplete(() => {
          this.statusEl.textContent = "Debate completed";
          this.startButtonEl.disabled = false;
          this.startButtonEl.textContent = "Start New Debate";
          this.exportButtonEl.removeAttribute("disabled");
        });
        yield this.debateEngine.startDebate(topic);
      } catch (error) {
        console.error("Error starting debate:", error);
        new import_obsidian3.Notice(`Error starting debate: ${error.message}`);
        this.statusEl.textContent = "Error starting debate";
        this.startButtonEl.disabled = false;
        this.startButtonEl.textContent = "Start Debate";
      }
    });
  }
  renderMessage(message) {
    if (!this.debateEngine || !this.debateConfig) return;
    const messageEl = this.messagesContainerEl.createDiv({ cls: "debate-message" });
    messageEl.setAttribute("data-message-id", message.id);
    const isHost = message.agentId === this.debateConfig.hostAgent.id;
    const agent = isHost ? this.debateConfig.hostAgent : this.debateConfig.agents.find((a) => a.id === message.agentId);
    if (!agent) return;
    messageEl.addClass(`agent-role-${agent.role}`);
    if (isHost) messageEl.addClass("host-message");
    if (message.streaming) messageEl.addClass("streaming-message");
    const headerEl = messageEl.createDiv({ cls: "message-header" });
    const nameEl = headerEl.createEl("span", {
      cls: "agent-name",
      text: agent.name
    });
    const roundEl = headerEl.createEl("span", {
      cls: "message-round",
      text: message.round === 0 ? "Introduction" : message.round > this.debateConfig.maxRounds ? "Conclusion" : `Round ${message.round}`
    });
    const contentEl = messageEl.createDiv({ cls: "message-content" });
    const formattedContent = this.formatMarkdown(message.content);
    contentEl.appendChild(formattedContent);
    if (message.streaming) {
      const indicatorEl = messageEl.createDiv({ cls: "streaming-indicator" });
      indicatorEl.createSpan({ text: "Typing", cls: "typing-text" });
      const dotsContainer = indicatorEl.createDiv({ cls: "typing-dots-container" });
    }
  }
  updateMessage(message) {
    const messageEl = this.messagesContainerEl.querySelector(`[data-message-id="${message.id}"]`);
    if (!messageEl) return;
    const contentEl = messageEl.querySelector(".message-content");
    if (contentEl) {
      contentEl.empty();
      const formattedContent = this.formatMarkdown(message.content);
      contentEl.appendChild(formattedContent);
    }
    if (message.streaming) {
      messageEl.addClass("streaming-message");
      if (!messageEl.querySelector(".streaming-indicator")) {
        const indicatorEl = messageEl.createDiv({ cls: "streaming-indicator" });
        indicatorEl.createSpan({ text: "Typing", cls: "typing-text" });
        const dotsContainer = indicatorEl.createDiv({ cls: "typing-dots-container" });
      }
    } else {
      messageEl.removeClass("streaming-message");
      const indicatorEl = messageEl.querySelector(".streaming-indicator");
      if (indicatorEl) {
        indicatorEl.remove();
      }
    }
  }
  // Simple markdown formatter - replaced with a safer implementation
  formatMarkdown(text) {
    const container = document.createElement("div");
    container.className = "debate-markdown-container";
    const lines = text.split("\n");
    lines.forEach((line) => {
      const h1Match = line.match(/^# (.*?)$/);
      const h2Match = line.match(/^## (.*?)$/);
      const h3Match = line.match(/^### (.*?)$/);
      const h4Match = line.match(/^#### (.*?)$/);
      if (h1Match) {
        const h1 = document.createElement("h1");
        h1.textContent = h1Match[1];
        h1.className = "debate-markdown-heading debate-markdown-h1";
        container.appendChild(h1);
      } else if (h2Match) {
        const h2 = document.createElement("h2");
        h2.textContent = h2Match[1];
        h2.className = "debate-markdown-heading debate-markdown-h2";
        container.appendChild(h2);
      } else if (h3Match) {
        const h3 = document.createElement("h3");
        h3.textContent = h3Match[1];
        h3.className = "debate-markdown-heading debate-markdown-h3";
        container.appendChild(h3);
      } else if (h4Match) {
        const h4 = document.createElement("h4");
        h4.textContent = h4Match[1];
        h4.className = "debate-markdown-heading debate-markdown-h4";
        container.appendChild(h4);
      } else {
        const paragraph2 = document.createElement("p");
        paragraph2.className = "debate-markdown-paragraph";
        let content = line;
        const processedContent = this.processInlineMarkdown(content);
        paragraph2.appendChild(processedContent);
        container.appendChild(paragraph2);
      }
    });
    return container;
  }
  // Helper method to process inline markdown formatting
  processInlineMarkdown(text) {
    const fragment = document.createDocumentFragment();
    let currentPos = 0;
    let lastProcessedPos = 0;
    const processBold = (text2, fragment2) => {
      let pos = 0;
      while ((pos = text2.indexOf("**", pos)) !== -1) {
        const endPos = text2.indexOf("**", pos + 2);
        if (endPos === -1) break;
        if (pos > lastProcessedPos) {
          fragment2.appendChild(document.createTextNode(text2.substring(lastProcessedPos, pos)));
        }
        const bold = document.createElement("strong");
        bold.textContent = text2.substring(pos + 2, endPos);
        bold.className = "debate-markdown-bold";
        fragment2.appendChild(bold);
        lastProcessedPos = endPos + 2;
        pos = endPos + 2;
      }
    };
    const processItalic = (text2, fragment2) => {
      let pos = 0;
      while ((pos = text2.indexOf("*", pos)) !== -1) {
        if (pos > 0 && text2[pos - 1] === "*") {
          pos++;
          continue;
        }
        if (pos < text2.length - 1 && text2[pos + 1] === "*") {
          pos += 2;
          continue;
        }
        const endPos = text2.indexOf("*", pos + 1);
        if (endPos === -1) break;
        if (pos > lastProcessedPos) {
          fragment2.appendChild(document.createTextNode(text2.substring(lastProcessedPos, pos)));
        }
        const italic = document.createElement("em");
        italic.textContent = text2.substring(pos + 1, endPos);
        italic.className = "debate-markdown-italic";
        fragment2.appendChild(italic);
        lastProcessedPos = endPos + 1;
        pos = endPos + 1;
      }
    };
    const processCode = (text2, fragment2) => {
      let pos = 0;
      while ((pos = text2.indexOf("`", pos)) !== -1) {
        const endPos = text2.indexOf("`", pos + 1);
        if (endPos === -1) break;
        if (pos > lastProcessedPos) {
          fragment2.appendChild(document.createTextNode(text2.substring(lastProcessedPos, pos)));
        }
        const code = document.createElement("code");
        code.textContent = text2.substring(pos + 1, endPos);
        code.className = "debate-markdown-code";
        fragment2.appendChild(code);
        lastProcessedPos = endPos + 1;
        pos = endPos + 1;
      }
    };
    processBold(text, fragment);
    processItalic(text, fragment);
    processCode(text, fragment);
    if (lastProcessedPos < text.length) {
      fragment.appendChild(document.createTextNode(text.substring(lastProcessedPos)));
    }
    return fragment;
  }
  exportToNote() {
    return __async(this, null, function* () {
      if (!this.debateEngine || !this.debateConfig) {
        new import_obsidian3.Notice("No debate to export");
        return;
      }
      const messages = this.debateEngine.getMessages();
      if (messages.length === 0) {
        new import_obsidian3.Notice("No debate messages to export");
        return;
      }
      try {
        let markdown = `# Debate: ${this.debateConfig.topic}

`;
        markdown += `*Mode: ${this.getModeName(this.debateConfig.mode)} | Rounds: ${this.debateConfig.maxRounds} | Date: ${(/* @__PURE__ */ new Date()).toLocaleString()}*

`;
        for (const message of messages) {
          const isHost = message.agentId === this.debateConfig.hostAgent.id;
          const agent = isHost ? this.debateConfig.hostAgent : this.debateConfig.agents.find((a) => a.id === message.agentId);
          if (!agent) continue;
          const roundLabel = message.round === 0 ? "Introduction" : message.round > this.debateConfig.maxRounds ? "Conclusion" : `Round ${message.round}`;
          markdown += `## ${agent.name} (${roundLabel})

`;
          markdown += `${message.content}

`;
        }
        try {
          const noteName = `Debate - ${this.debateConfig.topic.substring(0, 30)}`;
          const file = yield this.app.vault.create(`${noteName}.md`, markdown);
          yield this.app.workspace.openLinkText(file.path, "", true);
          new import_obsidian3.Notice("Debate exported to new note");
        } catch (error) {
          console.error("Error creating note:", error);
          yield navigator.clipboard.writeText(markdown);
          new import_obsidian3.Notice("Could not create note. Debate content copied to clipboard.");
        }
      } catch (error) {
        console.error("Error exporting debate:", error);
        new import_obsidian3.Notice(`Error exporting debate: ${error.message}`);
      }
    });
  }
  getModeName(mode) {
    switch (mode) {
      case "debate":
        return "Debate (Pro vs Con)";
      case "sixHats":
        return "Six Thinking Hats";
      case "roundtable":
        return "Roundtable Discussion";
      case "smart":
        return "SMART Goals Framework";
      case "okr":
        return "OKR (Objectives & Key Results)";
      case "swot":
        return "SWOT Analysis";
      case "pest":
        return "PEST Analysis";
      case "premortem":
        return "Pre-Mortem Analysis";
      case "fivewhys":
        return "5 Whys Root Cause Analysis";
      case "fishbone":
        return "Fishbone Diagram (Cause & Effect)";
      case "rubberduck":
        return "Rubber Duck Debugging";
      case "scamper":
        return "SCAMPER Method";
      case "lateralthinking":
        return "Lateral Thinking";
      case "pmi":
        return "PMI (Plus-Minus-Interesting)";
      case "doublediamond":
        return "Double Diamond Design Process";
      case "feynman":
        return "Feynman Technique";
      case "grow":
        return "GROW Coaching Model";
      default:
        return mode;
    }
  }
};

// src/models/ModelConfigModal.ts
var import_obsidian4 = require("obsidian");
var ModelConfigModal = class extends import_obsidian4.Modal {
  constructor(app, model, onSubmit) {
    super(app);
    this.isNewModel = !model;
    this.model = model || {
      id: `model_${Date.now()}`,
      name: "",
      type: "openai",
      apiKey: "",
      baseUrl: "",
      systemPrompt: "You are a helpful assistant.",
      active: true
    };
    this.onSubmit = onSubmit;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.createEl("h2", {
      text: this.isNewModel ? "Add AI Model" : "Edit AI Model"
    });
    new import_obsidian4.Setting(contentEl).setName("Model Name").setDesc("A friendly name to identify this model").addText(
      (text) => text.setPlaceholder("e.g., GPT-4, Ollama Local, Claude").setValue(this.model.name).onChange((value) => this.model.name = value)
    );
    new import_obsidian4.Setting(contentEl).setName("Provider").setDesc("Select the provider for this model").addDropdown(
      (dropdown) => dropdown.addOption("openai", "OpenAI").addOption("ollama", "Ollama").addOption("claude", "Anthropic Claude").addOption("zhipuai", "Zhipu AI").addOption("baidu", "Baidu").addOption("custom", "Custom API").setValue(this.model.type).onChange((value) => {
        this.model.type = value;
        this.model.baseUrl = "";
        this.model.modelName = "";
        this.contentEl.empty();
        this.onOpen();
      })
    );
    if (this.model.type !== "ollama") {
      new import_obsidian4.Setting(contentEl).setName("API Key").setDesc("Your API key for authenticating with the service").addText(
        (text) => text.setPlaceholder("sk-...").setValue(this.model.apiKey || "").onChange((value) => this.model.apiKey = value).inputEl.setAttribute("type", "password")
      );
    }
    new import_obsidian4.Setting(contentEl).setName("Base URL").setDesc(this.getUrlDescription()).addText(
      (text) => text.setPlaceholder(this.model.type === "ollama" ? "http://localhost:11434/api/generate" : "").setValue(this.model.baseUrl || "").onChange((value) => this.model.baseUrl = value)
    );
    new import_obsidian4.Setting(contentEl).setName("Model Name/ID").setDesc(this.getModelNameDescription()).addText(
      (text) => text.setPlaceholder(this.getModelNamePlaceholder()).setValue(this.model.modelName || "").onChange((value) => this.model.modelName = value)
    );
    new import_obsidian4.Setting(contentEl).setName("System Prompt").setDesc("Default system prompt for this model").addTextArea(
      (text) => text.setPlaceholder("You are a helpful assistant.").setValue(this.model.systemPrompt || "").onChange((value) => this.model.systemPrompt = value)
    );
    new import_obsidian4.Setting(contentEl).setName("Description").setDesc("Optional description for this model").addText(
      (text) => text.setPlaceholder("e.g., Fast and efficient for general tasks").setValue(this.model.description || "").onChange((value) => this.model.description = value)
    );
    contentEl.createEl("h3", { text: "Model Status" });
    new import_obsidian4.Setting(contentEl).setName("Active").setDesc("Enable this model for AI debate").addToggle((toggle) => toggle.setValue(this.model.active || false).onChange((value) => this.model.active = value));
    new import_obsidian4.Setting(contentEl).setName("Set as Default").setDesc("Make this model the default for AI chat and function icons").addToggle((toggle) => toggle.setValue(this.model.isDefault || false).onChange((value) => this.model.isDefault = value));
    new import_obsidian4.Setting(contentEl).setName("Use Proxy").setDesc("Use proxy for API calls to this model").addToggle(
      (toggle) => toggle.setValue(this.model.useProxy || false).onChange((value) => this.model.useProxy = value)
    );
    const submitButtonContainer = contentEl.createDiv({ cls: "modal-button-container" });
    const submitButton = submitButtonContainer.createEl("button", {
      text: this.isNewModel ? "Add Model" : "Save Changes",
      cls: "mod-cta"
    });
    submitButton.addEventListener("click", () => __async(this, null, function* () {
      if (this.validateModel()) {
        this.onSubmit(this.model);
        this.close();
      }
    }));
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
  validateModel() {
    if (!this.model.name) {
      new import_obsidian4.Notice("Please provide a name for the model");
      return false;
    }
    if (this.model.type !== "ollama" && !this.model.apiKey) {
      new import_obsidian4.Notice("API key is required for this model type");
      return false;
    }
    if (this.model.type === "ollama" && !this.model.baseUrl) {
      this.model.baseUrl = "http://localhost:11434/api/generate";
    }
    return true;
  }
  getUrlDescription() {
    switch (this.model.type) {
      case "openai":
        return "OpenAI API endpoint (leave blank for default)";
      case "ollama":
        return "Local URL for Ollama server";
      case "claude":
        return "Anthropic API endpoint (leave blank for default)";
      case "custom":
        return "Full URL to your custom API endpoint";
      default:
        return "API endpoint URL";
    }
  }
  getUrlPlaceholder() {
    switch (this.model.type) {
      case "openai":
        return "https://api.openai.com/v1/chat/completions";
      case "ollama":
        return "http://localhost:11434/api/generate";
      case "claude":
        return "https://api.anthropic.com/v1/messages";
      case "zhipuai":
        return "https://open.bigmodel.cn/api/paas/v4/chat/completions";
      case "baidu":
        return "https://aip.baidubce.com/rpc/2.0/ai_custom/v1/wenxinworkshop/chat/";
      case "custom":
        return "https://your-custom-api-endpoint.com/generate";
      default:
        return "";
    }
  }
  getModelNameDescription() {
    switch (this.model.type) {
      case "openai":
        return "The specific OpenAI model to use (e.g., gpt-3.5-turbo, gpt-4)";
      case "ollama":
        return "The specific Ollama model to use (e.g., llama2, mistral)";
      case "claude":
        return "The specific Claude model to use (e.g., claude-3-opus-20240229)";
      case "zhipuai":
        return "The specific ZhipuAI model to use (e.g., glm-4)";
      case "baidu":
        return "The specific Baidu model to use";
      case "custom":
        return "The model identifier for your custom API";
      default:
        return "Model name as it appears to the provider";
    }
  }
  getModelNamePlaceholder() {
    switch (this.model.type) {
      case "openai":
        return "gpt-4-turbo";
      case "ollama":
        return "llama2";
      case "claude":
        return "claude-3-opus-20240229";
      case "zhipuai":
        return "glm-4";
      case "baidu":
        return "ERNIE-Bot-4";
      case "custom":
        return "model-name";
      default:
        return "";
    }
  }
};

// src/models/EmbeddingModelConfigModal.ts
var import_obsidian5 = require("obsidian");
var EmbeddingModelConfigModal = class extends import_obsidian5.Modal {
  constructor(app, model, onSubmit) {
    super(app);
    this.onSubmit = onSubmit;
    this.model = model ? __spreadValues({}, model) : {
      id: crypto.randomUUID(),
      name: "",
      type: "openai",
      modelName: "",
      active: false,
      description: ""
    };
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("embedding-model-config-modal");
    contentEl.createEl("h2", { text: this.model.id ? "Edit Embedding Model" : "Add Embedding Model" });
    contentEl.createEl("h3", { text: "Basic Information" });
    new import_obsidian5.Setting(contentEl).setName("Model Name").setDesc("Display name for this embedding model").addText((text) => text.setPlaceholder("e.g., OpenAI Ada 2").setValue(this.model.name).onChange((value) => this.model.name = value));
    new import_obsidian5.Setting(contentEl).setName("Provider").setDesc("Select the embedding model provider").addDropdown((dropdown) => dropdown.addOption("openai", "OpenAI").addOption("zhipuai", "ZhipuAI").addOption("custom", "Custom API").setValue(this.model.type).onChange((value) => {
      this.model.type = value;
      this.model.modelName = "";
      this.onOpen();
    }));
    new import_obsidian5.Setting(contentEl).setName("Model Name/Identifier").setDesc("Select the specific embedding model for this provider").addDropdown((dropdown) => {
      if (this.model.type === "openai") {
        dropdown.addOption("text-embedding-3-small", "Embedding 3 Small").addOption("text-embedding-3-large", "Embedding 3 Large").addOption("text-embedding-ada-002", "Ada 2 (Legacy)");
      } else if (this.model.type === "zhipuai") {
        dropdown.addOption("embedding-2", "Embedding 2").addOption("embedding-3", "Embedding 3");
      } else {
        return dropdown.addOption("custom", "Custom Model Name");
      }
      return dropdown;
    }).addText((text) => {
      if (this.model.type === "custom") {
        text.setPlaceholder("Enter model name/identifier").setValue(this.model.modelName).onChange((value) => this.model.modelName = value);
      } else {
        text.setValue(this.model.modelName).setDisabled(true);
      }
    });
    new import_obsidian5.Setting(contentEl).setName("Description").setDesc("Optional description for this model").addText((text) => text.setPlaceholder("e.g., Fast and efficient for most tasks").setValue(this.model.description || "").onChange((value) => this.model.description = value));
    contentEl.createEl("h3", { text: "API Configuration" });
    new import_obsidian5.Setting(contentEl).setName("API Key").setDesc("API key for this model (leave empty to use global key)").addText((text) => text.setPlaceholder("Enter API key").setValue(this.model.apiKey || "").onChange((value) => this.model.apiKey = value));
    if (this.model.type === "custom") {
      new import_obsidian5.Setting(contentEl).setName("Base URL").setDesc("Base URL for custom API endpoint").addText((text) => text.setPlaceholder("e.g., https://api.example.com").setValue(this.model.baseUrl || "").onChange((value) => this.model.baseUrl = value));
    }
    if (this.model.type === "zhipuai" || this.model.type === "custom") {
      new import_obsidian5.Setting(contentEl).setName("Vector Dimensions").setDesc("Number of dimensions for embedding vectors").addText((text) => {
        var _a;
        return text.setPlaceholder("e.g., 1024").setValue(((_a = this.model.dimensions) == null ? void 0 : _a.toString()) || "").onChange((value) => {
          const dimensions = parseInt(value);
          this.model.dimensions = isNaN(dimensions) ? void 0 : dimensions;
        });
      });
    }
    new import_obsidian5.Setting(contentEl).setName("Use Proxy").setDesc("Use proxy for API calls to this model").addToggle((toggle) => toggle.setValue(this.model.useProxy || false).onChange((value) => this.model.useProxy = value));
    new import_obsidian5.Setting(contentEl).setName("Set as Active").setDesc("Make this the active embedding model").addToggle((toggle) => toggle.setValue(this.model.active).onChange((value) => this.model.active = value));
    const buttonContainer = contentEl.createDiv("modal-button-container");
    const saveButton = buttonContainer.createEl("button", {
      text: this.model.id ? "Save Changes" : "Create Model",
      cls: "mod-cta"
    });
    saveButton.addEventListener("click", () => {
      if (this.validateModel()) {
        this.close();
        this.onSubmit(this.model);
      }
    });
    const cancelButton = buttonContainer.createEl("button", {
      text: "Cancel"
    });
    cancelButton.addEventListener("click", () => {
      this.close();
    });
  }
  validateModel() {
    if (!this.model.name) {
      new Notice("Model name is required");
      return false;
    }
    if (!this.model.modelName) {
      new Notice("Model ID is required");
      return false;
    }
    if (this.model.type === "custom" && !this.model.baseUrl) {
      new Notice("Base URL is required for custom API");
      return false;
    }
    return true;
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/icons.ts
var import_obsidian6 = require("obsidian");
var addDebateIcon = () => {
  (0, import_obsidian6.addIcon)("brain-cog", `
    <svg xmlns="http://www.w3.org/2000/svg" width="100" height="100" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z"/>
      <path d="M17 4a2 2 0 0 0 2 2a2 2 0 0 0 -2 2a2 2 0 0 0 -2 -2a2 2 0 0 0 2 -2"/>
      <path d="M19 11h2m-1 -1v2"/>
      <path d="M15 16.5v.5a2 2 0 0 0 2 2"/>
      <path d="M8.5 14l-.386 -.51a1 1 0 0 0 -1.628 .476l-.748 2.238a1 1 0 0 0 .606 1.283l.279 .093a1 1 0 0 0 1.283 -.606l.558 -1.674a1 1 0 0 0 -.606 -1.283l-.121 -.04a1 1 0 0 0 -.221 -.025z"/>
      <path d="M14.5 17c0 .828 -.672 1.5 -1.5 1.5s-1.5 -.672 -1.5 -1.5s.672 -1.5 1.5 -1.5"/>
    </svg>
  `);
};
var addModelIcon = () => {
  (0, import_obsidian6.addIcon)("ai-model", `
    <svg xmlns="http://www.w3.org/2000/svg" width="100" height="100" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <path d="M12 2c1.109 0 2.01 .9 2.01 2s-.901 2 -2.01 2c-1.109 0 -2.01 -.9 -2.01 -2s.901 -2 2.01 -2z"/>
      <path d="M12 8c4.097 0 7.61 2.462 9 6h-18c1.39 -3.538 4.903 -6 9 -6z"/>
      <path d="M5.5 15l-1.5 6l3 -4l3 4l-1.5 -6"/>
      <path d="M14.5 15l-1.5 6l3 -4l3 4l-1.5 -6"/>
    </svg>
  `);
};
var addRoleIcons = () => {
  (0, import_obsidian6.addIcon)("debate-positive", `
    <svg xmlns="http://www.w3.org/2000/svg" width="100" height="100" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <path d="M12 12m-9 0a9 9 0 1 0 18 0a9 9 0 1 0 -18 0"/>
      <path d="M9 12l2 2l4 -4"/>
    </svg>
  `);
  (0, import_obsidian6.addIcon)("debate-negative", `
    <svg xmlns="http://www.w3.org/2000/svg" width="100" height="100" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <path d="M12 12m-9 0a9 9 0 1 0 18 0a9 9 0 1 0 -18 0"/>
      <path d="M9 12l6 0"/>
    </svg>
  `);
  (0, import_obsidian6.addIcon)("debate-host", `
    <svg xmlns="http://www.w3.org/2000/svg" width="100" height="100" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <path d="M8 9l2 3l-2 3"/>
      <path d="M14 9l-2 3l2 3"/>
      <path d="M12 12m-9 0a9 9 0 1 0 18 0a9 9 0 1 0 -18 0"/>
    </svg>
  `);
};
var addAllIcons = () => {
  addDebateIcon();
  addModelIcon();
  addRoleIcons();
};

// src/rag/RAGService.ts
var RAGService = class {
  constructor() {
  }
  /**
   * Perform the complete RAG process
   * @param query User query
   * @param options Options
   * @returns RAG results, including answer, sources, and reflection rounds
   */
  performCompleteRAG(_0) {
    return __async(this, arguments, function* (query, options2 = {}) {
      const {
        limit = 10,
        showProgress = false,
        streaming = false,
        onChunk = () => {
        },
        lambda = 0.6,
        progressContainer,
        progressText,
        progressBar
      } = options2;
      const progress = showProgress ? new ProgressIndicator(
        progressContainer || document.createElement("div"),
        progressText,
        progressBar
      ) : null;
      try {
        if (progress) progress.update("Optimizing query...", 10);
        const optimizedQuery = yield this.queryRewriter.rewriteQuery(query);
        if (progress) progress.update("Generating hypothetical answer...", 20);
        const { hypotheticalDoc, hydeResults } = yield this.hyde.generateAndSearch(optimizedQuery);
        if (progress) progress.update("Searching knowledge base...", 40);
        const retrievalResults = yield this.retriever.retrieve(optimizedQuery, limit);
        let combinedResults = [...hydeResults, ...retrievalResults];
        if (progress) progress.update("Reranking results...", 60);
        const rankedResults = yield this.mmr.rerank(combinedResults, optimizedQuery, lambda, limit);
        if (progress) progress.update("Generating answer...", 75);
        const initialAnswer = yield this.generateAnswer(query, optimizedQuery, rankedResults, hypotheticalDoc);
        if (progress) progress.update("Enhancing with knowledge base...", 90);
        let finalAnswer;
        if (streaming) {
          finalAnswer = yield this.reflector.improveWithReflectionStreaming(
            query,
            initialAnswer,
            rankedResults,
            onChunk
          );
        } else {
          finalAnswer = yield this.reflector.improveWithReflection(
            query,
            initialAnswer,
            rankedResults
          );
        }
        if (progress) progress.update("Completed!", 100);
        return {
          answer: finalAnswer,
          sources: rankedResults,
          reflectionRounds: this.reflector.getReflectionCount()
        };
      } catch (error) {
        console.error("Error in RAG process:", error);
        throw error;
      }
    });
  }
  /**
   * Generate answer based on context
   * @param query Original query
   * @param optimizedQuery Enhanced query
   * @param results Retrieved documents
   * @param hypotheticalDoc Hypothetical document (if generated)
   * @returns Generated answer
   */
  generateAnswer(query, optimizedQuery, results, hypotheticalDoc) {
    return __async(this, null, function* () {
      const contextText = results.map((c) => c.content).join("\n\n");
      const primaryLanguage = this.detectLanguage(contextText);
      const formattedContext = results.map((source, index) => {
        return `Source [${index + 1}]: ${source.file.basename}
${source.content}`;
      }).join("\n\n");
      let prompt = "";
      if (primaryLanguage === "chinese") {
        prompt = `Please answer the following question in Chinese:
      
Question: "${query}"

Below are document sections that may contain relevant information:

${formattedContext}

Instructions:
1. Provide a direct, comprehensive answer based on the provided documents
2. If different documents contain conflicting information, note the differences and explain pros and cons
3. When using information from a specific document, cite it as [Source X] in your answer
4. If the provided documents don't fully answer the question, clearly indicate what information is missing
5. Format code blocks, lists, and any structured content appropriately
6. Highlight key points using markdown formatting for readability
7. DO NOT summarize the documents - instead, directly answer the question
8. Keep your answer focused and concise`;
      } else {
        prompt = `Please answer the following question in English:
      
QUESTION: "${query}"

Below are document sections that may contain relevant information:

${formattedContext}

Instructions:
1. Provide a direct, comprehensive answer to the question based on the provided documents
2. If different documents contain conflicting information, note the differences and explain pros and cons 
3. When using information from a specific document, cite it as [Source X] in your answer
4. If the provided documents don't fully answer the question, clearly indicate what information is missing
5. Format code blocks, lists, and any structured content appropriately
6. Highlight key points using markdown formatting for readability
7. DO NOT summarize the documents - instead, directly answer the question
8. Keep your answer focused and concise`;
      }
      return yield this.aiService.getAIResponse(prompt);
    });
  }
  /**
   * Detect the primary language of text
   * @param text Text to detect
   * @returns Language identifier ('chinese' or 'english')
   */
  detectLanguage(text) {
    const chineseCharCount = (text.match(/[\u4e00-\u9fa5]/g) || []).length;
    const totalChars = text.length;
    return chineseCharCount / totalChars > 0.15 ? "chinese" : "english";
  }
  /**
   * Extract sources from context
   */
  extractSources(context) {
    const uniqueSources = /* @__PURE__ */ new Map();
    for (const source of context) {
      if (!uniqueSources.has(source.file.path)) {
        uniqueSources.set(source.file.path, source);
      }
    }
    return Array.from(uniqueSources.values());
  }
  /**
   * Get the retriever instances used by this service
   */
  getRetrievers() {
    return [this.retriever];
  }
};
var ProgressIndicator = class {
  constructor(container, textElement, barElement) {
    this.container = container;
    this.textElement = textElement;
    this.barElement = barElement;
    if (container) {
      container.style.display = "block";
    }
  }
  /**
   * Update progress status
   * @param status Status text
   * @param percentage Progress percentage
   */
  update(status, percentage) {
    if (this.textElement) {
      this.textElement.textContent = status;
    }
    if (this.barElement) {
      this.barElement.style.width = `${percentage}%`;
    }
  }
  /**
   * Complete progress and hide indicator
   */
  complete() {
    if (this.container) {
      setTimeout(() => {
        this.container.style.display = "none";
      }, 500);
    }
  }
};

// src/rag/AIService.ts
var AIService = class {
  constructor(plugin, modelManager) {
    this.plugin = plugin;
    this.modelManager = modelManager;
  }
  /**
   * 获取AI回复
   * @param prompt 提示词
   * @returns AI生成的响应
   */
  getAIResponse(prompt) {
    return __async(this, null, function* () {
      try {
        const defaultModel = this.modelManager.getDefaultModel();
        if (!defaultModel) {
          throw new Error("No default model configured. Please configure a model in settings.");
        }
        return yield this.modelManager.callModel(defaultModel.id, prompt, {
          maxTokens: 8192
        });
      } catch (error) {
        console.error("Error getting AI response:", error);
        throw error;
      }
    });
  }
  /**
   * 调用AI聊天接口
   * @param messages 消息数组
   * @param onChunk 流式回调
   * @returns AI生成的响应
   */
  callAIChat(messages, onChunk) {
    return __async(this, null, function* () {
      try {
        const defaultModel = this.modelManager.getDefaultModel();
        if (!defaultModel) {
          throw new Error("No default model configured. Please configure a model in settings.");
        }
        return yield this.modelManager.callModel(defaultModel.id, messages, {
          streaming: !!onChunk,
          onChunk,
          isChat: true
        });
      } catch (error) {
        console.error("Error in AI chat:", error);
        throw error;
      }
    });
  }
  /**
   * 简单的AI调用
   * @param content 要处理的内容
   * @returns AI生成的响应
   */
  callAI(content) {
    return __async(this, null, function* () {
      try {
        const defaultModel = this.modelManager.getDefaultModel();
        if (!defaultModel) {
          throw new Error("No default model configured. Please configure a model in settings.");
        }
        return yield this.modelManager.callModel(defaultModel.id, content, {
          maxTokens: 8192
        });
      } catch (error) {
        console.error("Error calling AI:", error);
        throw error;
      }
    });
  }
};

// src/rag/retrieval/Retriever.ts
var BaseRetriever = class {
  constructor(priority) {
    this.priority = priority;
  }
  /**
   * Get retriever priority
   */
  getPriority() {
    return this.priority;
  }
  /**
   * Extract relevant text snippet
   * @param content Full document content
   * @param query Query string
   * @param snippetLength Snippet length
   * @returns Relevant text snippet
   */
  getRelevantSnippet(content, query, snippetLength = 300) {
    const lowerContent = content.toLowerCase();
    const lowerQuery = query.toLowerCase();
    const index = lowerContent.indexOf(lowerQuery);
    if (index !== -1) {
      const start = Math.max(0, index - snippetLength / 2);
      const end = Math.min(content.length, index + query.length + snippetLength / 2);
      return content.slice(start, end);
    }
    return content.slice(0, snippetLength);
  }
};

// src/rag/retrieval/VectorRetriever.ts
var VectorRetriever = class extends BaseRetriever {
  constructor(app, modelManager, settings) {
    super(1 /* Vector */);
    this.app = app;
    this.modelManager = modelManager;
    this.settings = settings;
  }
  getName() {
    return "Vector Retriever";
  }
  /**
   * Perform vector retrieval
   * @param query Query text
   * @param limit Maximum number of results
   * @returns Relevant documents
   */
  retrieve(query, limit = 5) {
    return __async(this, null, function* () {
      try {
        console.log(`Vector retrieval: Finding relevant notes for "${query}"`);
        const files = yield this.getKnowledgeBaseNotes();
        const results = [];
        const queryEmbedding = yield this.modelManager.getEmbedding(query);
        for (const file of files) {
          try {
            const content = yield this.app.vault.read(file);
            const contentEmbedding = yield this.modelManager.getEmbedding(content);
            const similarity = this.calculateCosineSimilarity(queryEmbedding, contentEmbedding);
            if (similarity > 0.5) {
              console.log(`High vector similarity (${similarity.toFixed(2)}) for file: ${file.path}`);
              const snippet = this.getRelevantSnippet(content, query, 1e3);
              results.push({ file, similarity, content: snippet });
            }
          } catch (error) {
            console.error(`Error processing file ${file.path} for vector search:`, error);
          }
        }
        return results.sort((a, b) => b.similarity - a.similarity).slice(0, limit);
      } catch (error) {
        console.error("Vector retrieval failed:", error);
        return [];
      }
    });
  }
  /**
   * Get knowledge base notes
   * @returns Note files in the knowledge base
   */
  getKnowledgeBaseNotes() {
    return __async(this, null, function* () {
      const kbPath = this.settings.knowledgeBasePath;
      if (!kbPath) {
        return this.app.vault.getMarkdownFiles();
      }
      const files = this.app.vault.getMarkdownFiles();
      return files.filter((file) => file.path.startsWith(kbPath));
    });
  }
  /**
   * Calculate cosine similarity between two vectors
   * @param vec1 First vector
   * @param vec2 Second vector
   * @returns Similarity score (0-1)
   */
  calculateCosineSimilarity(vec1, vec2) {
    if (vec1.length !== vec2.length) {
      throw new Error("Vectors must have the same dimensions");
    }
    let dotProduct = 0;
    let mag1 = 0;
    let mag2 = 0;
    for (let i = 0; i < vec1.length; i++) {
      dotProduct += vec1[i] * vec2[i];
      mag1 += vec1[i] * vec1[i];
      mag2 += vec2[i] * vec2[i];
    }
    mag1 = Math.sqrt(mag1);
    mag2 = Math.sqrt(mag2);
    if (mag1 === 0 || mag2 === 0) return 0;
    return dotProduct / (mag1 * mag2);
  }
  /**
   * Enhanced snippet extraction that intelligently extracts relevant context based on query
   * @override
   */
  getRelevantSnippet(content, query, snippetLength = 300) {
    const sentences = content.split(/[.!?]+/);
    let bestScore = 0;
    let bestSnippet = "";
    for (let i = 0; i < sentences.length - 2; i++) {
      const snippet = sentences.slice(i, i + 3).join(". ");
      const score = this.calculateSnippetRelevance(snippet, query);
      if (score > bestScore) {
        bestScore = score;
        bestSnippet = snippet;
      }
    }
    if (!bestSnippet) {
      return super.getRelevantSnippet(content, query, snippetLength);
    }
    return bestSnippet;
  }
  /**
   * Calculate relevance score for a snippet
   */
  calculateSnippetRelevance(snippet, query) {
    const snippetWords = new Set(snippet.toLowerCase().split(/\s+/));
    const queryWords = new Set(query.toLowerCase().split(/\s+/));
    let matchCount = 0;
    for (const word of queryWords) {
      if (snippetWords.has(word)) {
        matchCount++;
      }
    }
    return matchCount / queryWords.size;
  }
};

// src/rag/enhancement/QueryRewriter.ts
var QueryRewriter = class {
  constructor(aiService) {
    this.aiService = aiService;
  }
  /**
   * Rewrite query to make it more suitable for retrieval
   * @param originalQuery Original query
   * @returns Optimized query
   */
  rewriteQuery(originalQuery) {
    return __async(this, null, function* () {
      if (originalQuery.length < 10 || originalQuery.split(" ").length < 3) {
        return originalQuery;
      }
      if (!this.aiService) {
        console.log("AI service not configured, using original query");
        return originalQuery;
      }
      try {
        const messages = [
          { role: "system", content: "You are a search query optimization expert. Your task is to rewrite search queries to make them more effective for semantic search. Return ONLY the rewritten query without explanation or additional text." },
          { role: "user", content: `Original query: "${originalQuery}"

Rewrite this query to be more effective for semantic search in a personal knowledge base. Add relevant keywords and context. Return ONLY the rewritten query, without any explanation.` }
        ];
        const rewrittenQuery = yield this.aiService.callAIChat(messages);
        let cleanedQuery = rewrittenQuery.trim().replace(/^["']|["']$/g, "").replace(/^Rewritten query: /i, "").replace(/\.$/, "");
        if (!cleanedQuery || cleanedQuery.length < 3 || cleanedQuery.length > 200) {
          return originalQuery;
        }
        console.log(`Rewritten query: "${cleanedQuery}" (from: "${originalQuery}")`);
        return cleanedQuery;
      } catch (error) {
        console.error("Error rewriting query:", error);
        return originalQuery;
      }
    });
  }
};

// src/rag/enhancement/HyDE.ts
var HyDE = class {
  constructor(settings, aiService, vectorRetriever) {
    this.settings = settings;
    this.aiService = aiService;
    this.vectorRetriever = vectorRetriever;
  }
  /**
   * Enhance retrieval using HyDE technique
   * @param query Original query
   * @returns Object containing hypothetical document and retrieval results
   */
  generateAndSearch(query) {
    return __async(this, null, function* () {
      const empty = { hypotheticalDoc: "", hydeResults: [] };
      if (!this.aiService || !this.vectorRetriever) {
        console.log("HyDE requires AI service and vector retriever, skipping");
        return empty;
      }
      try {
        const hypotheticalDoc = yield this.generateHypotheticalDoc(query);
        if (!hypotheticalDoc || hypotheticalDoc.length < 50) return empty;
        const hydeResults = yield this.vectorRetriever.retrieve(hypotheticalDoc);
        console.log(`HyDE retrieval returned ${hydeResults.length} results`);
        return { hypotheticalDoc, hydeResults };
      } catch (error) {
        console.error("Error in HyDE retrieval:", error);
        return empty;
      }
    });
  }
  /**
   * Generate a hypothetical document/answer for the query
   * @param query User query
   * @returns Hypothetical document
   */
  generateHypotheticalDoc(query) {
    return __async(this, null, function* () {
      try {
        const messages = [
          {
            role: "system",
            content: `Generate a detailed, factual passage that directly answers the user's question. Write as if you're a knowledgeable expert providing an ideal answer based on verified information. Include specific details, examples, and explanations. DO NOT include phrases like "As an AI" or "According to my knowledge". Write in a natural, informative style.`
          },
          {
            role: "user",
            content: query
          }
        ];
        return yield this.aiService.callAIChat(messages);
      } catch (error) {
        console.error("Error generating hypothetical document:", error);
        return "";
      }
    });
  }
  /**
   * 创建源对象
   * @param file 文件
   * @param similarity 相似度分数
   * @param content 内容片段
   * @returns 源对象
   */
  createSource(file, similarity, content) {
    return { file, similarity, content };
  }
};

// src/rag/ranking/MMR.ts
var MMRReranker = class {
  /**
   * Rerank documents using MMR algorithm
   * @param docs Document list to be reranked
   * @param query Original query
   * @param lambda Relevance vs diversity balance factor (0-1), higher values prioritize relevance
   * @param k Number of results to return
   * @returns Reranked document list
   */
  rerank(docs, query, lambda = 0.7, k = 5) {
    return __async(this, null, function* () {
      if (!docs || docs.length === 0) {
        return [];
      }
      if (docs.length <= k) {
        return docs;
      }
      const sortedDocs = [...docs].sort(
        (a, b) => (b.score || 0) - (a.score || 0)
      );
      const selected = [sortedDocs[0]];
      const remaining = sortedDocs.slice(1);
      while (selected.length < k && remaining.length > 0) {
        let nextBestIdx = -1;
        let nextBestScore = -Infinity;
        for (let i = 0; i < remaining.length; i++) {
          const doc = remaining[i];
          const relevanceScore = doc.score || 0;
          let maxSimilarity = 0;
          for (const selectedDoc of selected) {
            const similarity = this.calculateSimilarity(doc, selectedDoc);
            maxSimilarity = Math.max(maxSimilarity, similarity);
          }
          const mmrScore = lambda * relevanceScore - (1 - lambda) * maxSimilarity;
          if (mmrScore > nextBestScore) {
            nextBestScore = mmrScore;
            nextBestIdx = i;
          }
        }
        if (nextBestIdx >= 0) {
          selected.push(remaining[nextBestIdx]);
          remaining.splice(nextBestIdx, 1);
        } else {
          break;
        }
      }
      return selected;
    });
  }
  /**
   * Calculate similarity between two documents
   * Using existing score by default, can be extended for more complex similarity
   */
  calculateSimilarity(docA, docB) {
    if (docA.embedding && docB.embedding) {
      return this.cosineSimilarity(docA.embedding, docB.embedding);
    }
    if (docA.content && docB.content) {
      const wordsA = new Set(docA.content.toLowerCase().split(/\s+/));
      const wordsB = new Set(docB.content.toLowerCase().split(/\s+/));
      const intersection = new Set([...wordsA].filter((x) => wordsB.has(x)));
      const union = /* @__PURE__ */ new Set([...wordsA, ...wordsB]);
      return intersection.size / union.size;
    }
    return 0;
  }
  /**
   * Calculate cosine similarity between two embedding vectors
   */
  cosineSimilarity(vecA, vecB) {
    if (!vecA || !vecB || vecA.length !== vecB.length) {
      return 0;
    }
    let dotProduct = 0;
    let normA = 0;
    let normB = 0;
    for (let i = 0; i < vecA.length; i++) {
      dotProduct += vecA[i] * vecB[i];
      normA += vecA[i] * vecA[i];
      normB += vecB[i] * vecB[i];
    }
    normA = Math.sqrt(normA);
    normB = Math.sqrt(normB);
    if (normA === 0 || normB === 0) {
      return 0;
    }
    return dotProduct / (normA * normB);
  }
};

// src/rag/ranking/SemanticChunker.ts
var SemanticChunker = class {
  /**
   * Create semantic contexts for retrieval results
   * @param results Original retrieval results
   * @param query User query
   * @returns Enhanced results
   */
  createContexts(results, query) {
    return __async(this, null, function* () {
      const enhancedResults = [];
      for (const result of results) {
        try {
          const semanticChunks = this.createSemanticChunks(result.content, query);
          for (const chunk of semanticChunks.slice(0, 2)) {
            enhancedResults.push({
              file: result.file,
              similarity: result.similarity,
              content: chunk
            });
          }
        } catch (error) {
          console.error(`Error processing file ${result.file.path}:`, error);
          enhancedResults.push(result);
        }
      }
      return enhancedResults;
    });
  }
  /**
   * Create semantic chunks from text
   * @param text Original text
   * @param query User query
   * @param maxChunkSize Maximum chunk size
   * @returns Array of semantic chunks
   */
  createSemanticChunks(text, query, maxChunkSize = 1e3) {
    try {
      const structuralDividers = /\n#{1,6}\s+|\n---+|\n\*\*\*+|\n={3,}/g;
      let sections = text.split(structuralDividers).filter((s) => s.trim().length > 0);
      const result = [];
      for (const section of sections) {
        if (section.length <= maxChunkSize) {
          result.push(section);
          continue;
        }
        const paragraphs = section.split(/\n\s*\n/).filter((p) => p.trim().length > 0);
        let currentChunk = "";
        for (const paragraph2 of paragraphs) {
          if (currentChunk.length + paragraph2.length > maxChunkSize && currentChunk.length > 0) {
            result.push(currentChunk);
            currentChunk = "";
          }
          if (paragraph2.length > maxChunkSize) {
            if (currentChunk.length > 0) {
              result.push(currentChunk);
              currentChunk = "";
            }
            const sentences = paragraph2.match(/[^.!?]+[.!?]+/g) || [paragraph2];
            let sentenceChunk = "";
            for (const sentence of sentences) {
              if (sentenceChunk.length + sentence.length > maxChunkSize && sentenceChunk.length > 0) {
                result.push(sentenceChunk);
                sentenceChunk = "";
              }
              sentenceChunk += sentence;
            }
            if (sentenceChunk.length > 0) {
              result.push(sentenceChunk);
            }
          } else {
            currentChunk += (currentChunk.length > 0 ? "\n\n" : "") + paragraph2;
          }
        }
        if (currentChunk.length > 0) {
          result.push(currentChunk);
        }
      }
      const scoredChunks = this.scoreChunksByRelevance(result, query);
      return scoredChunks;
    } catch (error) {
      console.error("Error creating semantic chunks:", error);
      return [text];
    }
  }
  /**
   * Score and sort chunks by relevance to the query
   * @param chunks Text chunks
   * @param query Query
   * @returns Sorted chunks
   */
  scoreChunksByRelevance(chunks, query) {
    const queryTerms = query.toLowerCase().split(/\s+/).filter((term) => term.length > 2);
    const scoredChunks = chunks.map((chunk) => {
      const lowerChunk = chunk.toLowerCase();
      let score = 0;
      if (lowerChunk.includes(query.toLowerCase())) {
        score += 100;
      }
      for (const term of queryTerms) {
        if (lowerChunk.includes(term)) {
          score += 10;
          const lines = chunk.split("\n");
          for (const line of lines) {
            if (/^#+\s+/.test(line) && line.toLowerCase().includes(term)) {
              score += 5;
            }
          }
        }
      }
      return { chunk, score };
    });
    return scoredChunks.sort((a, b) => b.score - a.score).map((item) => item.chunk);
  }
};

// src/rag/reflection/Reflector.ts
var Reflector = class {
  constructor(settings, aiService, retriever) {
    this.settings = settings;
    this.aiService = aiService;
    this.retriever = retriever;
    this.reflectionCount = 0;
  }
  /**
   * Improve answer through reflection cycles (streaming version)
   * @param query Original query
   * @param initialAnswer Initial answer
   * @param initialContext Initial context
   * @param onChunk Streaming output callback
   * @returns Improved answer
   */
  improveWithReflectionStreaming(query, initialAnswer, initialContext, onChunk) {
    return __async(this, null, function* () {
      this.reflectionCount = 0;
      if (!this.aiService || !this.retriever) {
        console.log("Reflector needs AI service and retriever, skipping reflection");
        return initialAnswer;
      }
      try {
        let currentAnswer = initialAnswer;
        let context = this.formatContext(initialContext);
        const MAX_REFLECTIONS = 2;
        const minReflectionLength = 50;
        onChunk("\n\n_Enhancing with knowledge base..._");
        for (let i = 0; i < MAX_REFLECTIONS; i++) {
          console.log(`Executing reflection round ${i + 1}/${MAX_REFLECTIONS}`);
          const reflection = yield this.generateReflection(query, currentAnswer, context);
          if (!reflection || reflection.length < minReflectionLength) {
            console.log("Reflection result too short or meaningless, ending reflection loop");
            break;
          }
          this.reflectionCount++;
          const searchQueries = yield this.extractSearchQueries(reflection);
          if (!searchQueries || searchQueries.length === 0) {
            console.log("Unable to extract search queries from reflection, ending reflection loop");
            break;
          }
          let additionalContext = "";
          for (const searchQuery of searchQueries) {
            const additionalResults = yield this.retriever.retrieve(searchQuery, 3);
            if (additionalResults.length > 0) {
              additionalContext += `

Regarding: "${searchQuery}"

`;
              additionalResults.forEach((result, index) => {
                const sourceIndex = initialContext.length + index + 1;
                additionalContext += `Source [${sourceIndex}]: ${result.file.basename}
`;
                additionalContext += `${result.content}

`;
              });
            }
          }
          if (additionalContext.length > 0) {
            context += additionalContext;
            onChunk(`

_Found ${this.reflectionCount > 1 ? "more" : ""} relevant information, enhancing answer..._`);
            const messages = [
              {
                role: "system",
                content: `You are a knowledge base Q&A assistant. You need to improve the previous answer, addressing issues identified in the reflection and utilizing newly provided information.`
              },
              {
                role: "user",
                content: `Please improve the answer below, addressing issues identified in the reflection and utilizing newly provided information.

Original question:
${query}

Current answer:
${currentAnswer}

Reflection feedback:
${reflection}

New information:
${additionalContext}

Please generate an improved, more comprehensive answer while maintaining the strengths of the original answer. The answer should be direct, authoritative, and cite sources. Do not add any meta-descriptions or preamble. Start your answer directly without repeating the question.`
              }
            ];
            onChunk("\n\n");
            const improvedAnswer = yield this.aiService.callAIChat(messages, onChunk);
            if (improvedAnswer && improvedAnswer.length > currentAnswer.length / 2) {
              currentAnswer = improvedAnswer;
            } else {
              console.log("Quality of improved answer insufficient, keeping current answer");
              break;
            }
          } else {
            console.log("No additional information found, ending reflection loop");
            break;
          }
        }
        return currentAnswer;
      } catch (error) {
        console.error("Error in reflection loop:", error);
        onChunk("\n\n_Error occurred during reflection, returning initial answer_");
        return initialAnswer;
      }
    });
  }
  /**
   * Improve answer through reflection cycles
   * @param query Original query
   * @param initialAnswer Initial answer
   * @param initialContext Initial context
   * @returns Improved answer
   */
  improveWithReflection(query, initialAnswer, initialContext) {
    return __async(this, null, function* () {
      this.reflectionCount = 0;
      if (!this.aiService || !this.retriever) {
        console.log("Reflector needs AI service and retriever, skipping reflection");
        return initialAnswer;
      }
      try {
        let currentAnswer = initialAnswer;
        let context = this.formatContext(initialContext);
        const MAX_REFLECTIONS = 2;
        const minReflectionLength = 50;
        for (let i = 0; i < MAX_REFLECTIONS; i++) {
          console.log(`Executing reflection round ${i + 1}/${MAX_REFLECTIONS}`);
          const reflection = yield this.generateReflection(query, currentAnswer, context);
          if (!reflection || reflection.length < minReflectionLength) {
            console.log("Reflection result too short or meaningless, ending reflection loop");
            break;
          }
          this.reflectionCount++;
          const searchQueries = yield this.extractSearchQueries(reflection);
          if (!searchQueries || searchQueries.length === 0) {
            console.log("Unable to extract search queries from reflection, ending reflection loop");
            break;
          }
          let additionalContext = "";
          for (const searchQuery of searchQueries) {
            const additionalResults = yield this.retriever.retrieve(searchQuery, 3);
            if (additionalResults.length > 0) {
              additionalContext += `

Regarding: "${searchQuery}"

`;
              additionalResults.forEach((result, index) => {
                const sourceIndex = initialContext.length + index + 1;
                additionalContext += `Source [${sourceIndex}]: ${result.file.basename}
`;
                additionalContext += `${result.content}

`;
              });
            }
          }
          if (additionalContext.length > 0) {
            context += additionalContext;
            const improvedAnswer = yield this.generateImprovedAnswer(
              query,
              currentAnswer,
              reflection,
              additionalContext
            );
            if (improvedAnswer && improvedAnswer.length > currentAnswer.length / 2) {
              currentAnswer = improvedAnswer;
            } else {
              console.log("Quality of improved answer insufficient, keeping current answer");
              break;
            }
          } else {
            console.log("No additional information found, ending reflection loop");
            break;
          }
        }
        return currentAnswer;
      } catch (error) {
        console.error("Error in reflection loop:", error);
        return initialAnswer;
      }
    });
  }
  /**
   * Get the number of reflection rounds executed
   */
  getReflectionCount() {
    return this.reflectionCount;
  }
  /**
   * Format context as text
   * @param sources Array of sources
   * @returns Formatted context text
   */
  formatContext(sources) {
    return sources.map((source, index) => {
      return `Source [${index + 1}]: ${source.file.basename}
${source.content}`;
    }).join("\n\n");
  }
  /**
   * Generate reflection for current answer
   * @param query Original query
   * @param answer Current answer
   * @param context Current context
   * @returns Reflection text
   */
  generateReflection(query, answer, context) {
    return __async(this, null, function* () {
      if (!this.aiService) return "";
      const prompt = `Your task is to evaluate the quality of the following answer and identify any missing information or gaps in the answer.
    
Original question:
${query}

Current answer:
${answer}

Please think:
1. What specific information is missing from the answer?
2. Are there any related but unaddressed aspects?
3. Which assertions in the answer lack sufficient evidence?
4. Are there any areas that need clarification?

Identify 3-5 specific points in the answer that need more information and list specific queries to search for.`;
      return yield this.aiService.getAIResponse(prompt);
    });
  }
  /**
   * Extract search queries from reflection
   * @param reflection Reflection text
   * @returns Array of search queries
   */
  extractSearchQueries(reflection) {
    return __async(this, null, function* () {
      if (!this.aiService) return [];
      const queryMatches = reflection.match(/\d+\.\s*(.*?)(?=\d+\.|$)/g) || [];
      if (queryMatches.length > 0) {
        return queryMatches.map((m) => m.replace(/^\d+\.\s*/, "").trim()).filter((q) => q.length > 5);
      }
      const prompt = `Extract specific queries from the following reflection text. Please list 3-5 queries in short, direct questions or phrases, one per line, without numbering:

${reflection}

Queries:`;
      const extractedQueries = yield this.aiService.getAIResponse(prompt);
      return extractedQueries.split("\n").map((q) => q.trim()).filter((q) => q.length > 5 && !q.startsWith("Queries"));
    });
  }
  /**
   * Generate improved answer
   * @param query Original query
   * @param currentAnswer Current answer
   * @param reflection Reflection text
   * @param additionalContext Additional context
   * @returns Improved answer
   */
  generateImprovedAnswer(query, currentAnswer, reflection, additionalContext) {
    return __async(this, null, function* () {
      if (!this.aiService) return currentAnswer;
      const prompt = `Please improve the answer below, addressing issues identified in the reflection and utilizing newly provided information.

Original question:
${query}

Current answer:
${currentAnswer}

Reflection feedback:
${reflection}

New information:
${additionalContext}

Please generate an improved, more comprehensive answer while maintaining the strengths of the original answer. The answer should be direct, authoritative, and cite sources. Do not add any meta-descriptions or preamble.`;
      return yield this.aiService.getAIResponse(prompt);
    });
  }
};

// src/rag/index.ts
function createRAGService(app, plugin, settings) {
  const aiService = new AIService(plugin, plugin.modelManager);
  const vectorRetriever = new VectorRetriever(app, plugin.modelManager, settings);
  const queryRewriter = new QueryRewriter(aiService);
  const hydeEnhancer = new HyDE(settings, aiService, vectorRetriever);
  const ranker = new MMRReranker();
  const chunker = new SemanticChunker();
  const reflector = new Reflector(settings, aiService, vectorRetriever);
  const ragService = new RAGService();
  initializeRAGService(
    ragService,
    aiService,
    vectorRetriever,
    queryRewriter,
    hydeEnhancer,
    ranker,
    chunker,
    reflector
  );
  return ragService;
}
function initializeRAGService(ragService, aiService, vectorRetriever, queryRewriter, hydeEnhancer, ranker, chunker, reflector) {
  Object.assign(ragService, {
    aiService,
    retriever: vectorRetriever,
    queryRewriter,
    hyde: hydeEnhancer,
    mmr: ranker,
    semanticChunker: chunker,
    reflector
  });
}

// src/KnowledgeBaseView.ts
var import_obsidian8 = require("obsidian");

// src/modals.ts
var import_obsidian7 = require("obsidian");
var LoadingModal = class extends import_obsidian7.Modal {
  // Maintain for backward compatibility
  constructor(app, isProgress = false, modalTitle = "") {
    super(app);
    this.isCancelled = false;
    this.isProgress = isProgress;
    if (modalTitle) {
      this.titleEl.setText(modalTitle);
    } else {
      this.titleEl.setText(isProgress ? "Processing..." : "Loading...");
    }
  }
  onOpen() {
    const { contentEl } = this;
    const container = contentEl.createDiv({ cls: "loading-modal-container" });
    const spinnerContainer = container.createDiv({ cls: "loading-spinner-container" });
    const spinner = spinnerContainer.createDiv({ cls: "loading-spinner" });
    this.messageEl = container.createDiv({ cls: "loading-message" });
    this.statusEl = this.messageEl;
    this.messageEl.setText("Please wait...");
    const progressContainer = container.createDiv({ cls: "loading-progress-container" });
    this.progressEl = progressContainer.createDiv({ cls: "loading-progress" });
    this.progressBarEl = this.progressEl.createDiv({ cls: "loading-progress-bar" });
    this.progressBarEl.style.width = "0%";
    this.percentageEl = progressContainer.createDiv({ cls: "loading-percentage" });
    this.percentageEl.setText("0%");
    const buttonContainer = container.createDiv({ cls: "loading-button-container" });
    const cancelButton = buttonContainer.createEl("button", { text: "Cancel" });
    cancelButton.addEventListener("click", () => {
      this.isCancelled = true;
      this.close();
    });
  }
  // Support both new and old progress methods
  setProgress(progress, current, total) {
    const percentage = Math.round(progress * 100);
    this.progressBarEl.style.width = `${percentage}%`;
    if (current !== void 0 && total !== void 0) {
      this.percentageEl.setText(`${current}/${total} (${percentage}%)`);
    } else {
      this.percentageEl.setText(`${percentage}%`);
    }
  }
  setTitle(title) {
    this.titleEl.setText(title);
    return this;
  }
  // Support both message and status methods
  setMessage(message) {
    if (this.messageEl) {
      this.messageEl.setText(message);
    }
  }
  // Keep original method for backward compatibility
  setStatus(status) {
    this.setMessage(status);
  }
  isCanceled() {
    return this.isCancelled;
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var SearchResultsModal = class extends import_obsidian7.Modal {
  constructor(app, resultsOrData, query) {
    super(app);
    if (Array.isArray(resultsOrData)) {
      this.results = resultsOrData;
      this.answer = void 0;
      this.sources = void 0;
    } else {
      this.answer = resultsOrData.answer;
      this.sources = resultsOrData.sources;
      this.results = resultsOrData.sources || [];
      this.reflectionCount = resultsOrData.reflectionCount;
    }
    this.query = query;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("search-results-modal");
    contentEl.createEl("h2", { text: "Search Results" });
    contentEl.createEl("p", {
      text: `Query: "${this.query}"`,
      cls: "search-query"
    });
    if (this.answer) {
      const answerContainer = contentEl.createDiv({ cls: "search-answer-container" });
      answerContainer.createEl("h3", { text: "AI Answer", cls: "search-answer-header" });
      if (this.reflectionCount !== void 0 && this.reflectionCount > 0) {
        answerContainer.createEl("div", {
          text: `The AI performed ${this.reflectionCount} reflection ${this.reflectionCount === 1 ? "round" : "rounds"} to improve this answer.`,
          cls: "search-reflection-info"
        });
      }
      const answerContent = answerContainer.createDiv({ cls: "search-answer-content markdown-rendered" });
      import_obsidian7.MarkdownRenderer.renderMarkdown(
        this.answer,
        answerContent,
        "",
        null
      );
      contentEl.createEl("h3", { text: "Sources", cls: "search-sources-header" });
    }
    const resultsContainer = contentEl.createDiv({ cls: "search-results-container" });
    this.results.forEach((result, index) => {
      const resultEl = resultsContainer.createDiv({ cls: "search-result" });
      const headerEl = resultEl.createDiv({ cls: "search-result-header" });
      const fileLink = headerEl.createEl("a", {
        cls: "search-result-file-link",
        text: result.file.name
      });
      fileLink.addEventListener("click", () => {
        this.app.workspace.getLeaf("tab").openFile(result.file);
        this.close();
      });
      headerEl.createEl("span", {
        cls: "search-result-similarity",
        text: `Relevance: ${Math.round(result.similarity * 100)}%`
      });
      const contentEl2 = resultEl.createDiv({ cls: "search-result-content" });
      contentEl2.setText(result.content);
    });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/KnowledgeBaseView.ts
var KNOWLEDGE_BASE_VIEW_TYPE = "aipilot-kb-view";
var KnowledgeBaseView = class extends import_obsidian8.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    // Cache for search results to improve performance
    this.knowledgeBaseCache = /* @__PURE__ */ new Map();
    this.plugin = plugin;
  }
  getViewType() {
    return KNOWLEDGE_BASE_VIEW_TYPE;
  }
  getDisplayText() {
    return "Knowledge Base Search";
  }
  onOpen() {
    return __async(this, null, function* () {
      this.contentEl.addClass("kb-view-container");
      this.containerEl = this.contentEl.createDiv({ cls: "kb-container" });
      this.createHeader();
      this.createSearchInterface();
      this.resultsContainer = this.containerEl.createDiv({ cls: "kb-results" });
      this.showWelcomeMessage();
    });
  }
  createHeader() {
    const headerEl = this.containerEl.createDiv({ cls: "kb-header" });
    headerEl.createEl("h2", { text: "Knowledge Base Search" });
    const descriptionEl = headerEl.createEl("p", {
      text: "Search your notes and documents using semantic search and AI analysis."
    });
  }
  createSearchInterface() {
    this.inputContainer = this.containerEl.createDiv({ cls: "kb-input-container" });
    const dirSelectorContainer = this.inputContainer.createDiv({ cls: "kb-dir-selector-container" });
    dirSelectorContainer.createEl("label", {
      text: "Search in:",
      attr: { for: "kb-dir-selector" }
    });
    this.dirSelector = dirSelectorContainer.createEl("select", {
      cls: "kb-dir-selector",
      attr: {
        id: "kb-dir-selector",
        "aria-label": "Select directory to search in"
      }
    });
    this.dirSelector.createEl("option", {
      text: "All Files",
      value: ""
    });
    const rootFolder = this.app.vault.getRoot();
    const folders = rootFolder.children.filter((child) => child instanceof import_obsidian8.TFolder).sort((a, b) => a.name.localeCompare(b.name));
    folders.forEach((folder) => {
      this.dirSelector.createEl("option", {
        text: folder.name,
        value: folder.path
      });
    });
    const searchInputRow = this.inputContainer.createDiv({ cls: "kb-search-input-row" });
    this.searchInput = searchInputRow.createEl("input", {
      cls: "kb-search-input",
      attr: {
        placeholder: "Search your knowledge base...",
        "aria-label": "Search query",
        type: "search"
      }
    });
    const searchButton = searchInputRow.createEl("button", {
      cls: "kb-search-button",
      text: "Search"
    });
    const qaButton = this.inputContainer.createDiv({ cls: "kb-qa-button" });
    qaButton.createEl("button", {
      text: "Ask Question (Q&A)",
      cls: "kb-qa-button-inner"
    });
    this.progressContainer = this.inputContainer.createDiv({ cls: "kb-progress" });
    this.progressBar = this.progressContainer.createDiv({ cls: "kb-progress-bar" });
    this.progressText = this.progressContainer.createDiv({ cls: "kb-progress-text" });
    this.countText = this.progressContainer.createDiv({ cls: "kb-count-text" });
    this.progressContainer.style.display = "none";
    searchButton.addEventListener("click", () => this.handleSearch());
    this.searchInput.addEventListener("keydown", (e) => {
      if (e.key === "Enter") {
        this.handleSearch();
      }
    });
    qaButton.addEventListener("click", () => this.handleQA());
  }
  showWelcomeMessage() {
    this.resultsContainer.empty();
    const welcomeEl = this.resultsContainer.createDiv({ cls: "kb-welcome" });
    const iconEl = welcomeEl.createDiv({ cls: "kb-welcome-icon" });
    (0, import_obsidian8.setIcon)(iconEl, "search");
    welcomeEl.createEl("h3", { text: "Search Your Knowledge Base" });
    welcomeEl.createEl("p", {
      text: "Enter a search query above to find relevant information in your notes."
    });
    const featuresEl = this.resultsContainer.createDiv({ cls: "kb-features" });
    featuresEl.createEl("h4", { text: "Available Features:" });
    const featuresList = featuresEl.createEl("ul", { cls: "kb-features-list" });
    featuresList.createEl("li", {
      text: "Semantic Search: Find information based on meaning, not just keywords."
    });
    featuresList.createEl("li", {
      text: "AI Analysis: Get AI-generated answers based on your documents."
    });
    featuresList.createEl("li", {
      text: "Knowledge Q&A: Ask questions about your knowledge base."
    });
  }
  // Enhanced search handler using RAG service
  handleSearch() {
    return __async(this, null, function* () {
      const query = this.searchInput.value.trim();
      if (!query) {
        this.resultsContainer.empty();
        this.resultsContainer.createDiv({
          cls: "kb-error-message",
          text: "Please enter a search query."
        });
        return;
      }
      this.progressContainer.style.display = "block";
      this.progressText.textContent = "Initializing search...";
      this.progressBar.style.width = "0%";
      this.countText.textContent = "";
      this.resultsContainer.empty();
      try {
        const selectedDir = this.dirSelector.value;
        if (this.plugin.ragService) {
          const updateProgress = (stage, percent) => {
            this.progressText.textContent = stage;
            this.progressBar.style.width = `${percent}%`;
            this.countText.textContent = `Processing ${stage}`;
          };
          let streamedAnswer = "";
          const handleStream = (chunk) => {
            if (!chunk) return;
            streamedAnswer += chunk;
            this.resultsContainer.empty();
            const streamingContainer = this.resultsContainer.createDiv({ cls: "kb-rag-results-container streaming" });
            const answerDiv = streamingContainer.createDiv({ cls: "kb-rag-answer" });
            try {
              MarkdownRenderer.renderMarkdown(
                streamedAnswer,
                answerDiv,
                "",
                this.plugin
              );
            } catch (error) {
              console.warn("Error rendering streaming markdown:", error);
              answerDiv.setText(streamedAnswer);
            }
            if (this.progressContainer.style.display !== "none" && streamedAnswer.length > 50) {
              this.progressContainer.style.opacity = "0.7";
            }
          };
          const result = yield this.plugin.ragService.performCompleteRAG(query, {
            showProgress: true,
            onProgress: updateProgress,
            streaming: true,
            onChunk: handleStream,
            limit: 10,
            directory: selectedDir || void 0
          });
          this.progressContainer.style.display = "none";
          yield this.displayRAGResults(__spreadProps(__spreadValues({}, result), {
            answer: streamedAnswer || result.answer,
            query
          }));
        } else {
          const loadingModal = new LoadingModal(this.app, true, "Searching your knowledge base...");
          loadingModal.open();
          const results = yield this.plugin.advancedSearch(query, 10, loadingModal);
          loadingModal.close();
          this.progressContainer.style.display = "none";
          if (results.length === 0) {
            this.resultsContainer.createDiv({
              cls: "kb-error-message",
              text: "No relevant documents found for your query."
            });
            return;
          }
          new SearchResultsModal(this.app, results, query).open();
        }
      } catch (error) {
        console.error("Error searching knowledge base:", error);
        this.progressContainer.style.display = "none";
        this.resultsContainer.empty();
        this.resultsContainer.createDiv({
          cls: "kb-error-message",
          text: `Error searching knowledge base: ${error.message}`
        });
      }
    });
  }
  displayRAGResults(result) {
    return __async(this, null, function* () {
      this.resultsContainer.empty();
      const answerContainer = this.resultsContainer.createDiv({ cls: "kb-answer-container" });
      const questionDiv = answerContainer.createDiv({ cls: "kb-question" });
      questionDiv.createEl("h3", { text: "Your Query" });
      questionDiv.createEl("p", { text: result.query });
      const answerDiv = answerContainer.createDiv({ cls: "kb-answer" });
      answerDiv.createEl("h3", { text: "Answer" });
      const answerContent = answerDiv.createDiv({ cls: "markdown-rendered" });
      MarkdownRenderer.renderMarkdown(result.answer, answerContent, "", this.plugin);
      if (result.reflectionRounds && result.reflectionRounds > 0) {
        const reflectionBadge = answerDiv.createDiv({ cls: "reflection-badge" });
        reflectionBadge.setText(`AI Reflection: ${result.reflectionRounds} rounds`);
      }
      if (result.sources && result.sources.length > 0) {
        const sourcesContainer = this.resultsContainer.createDiv({ cls: "kb-sources-container" });
        sourcesContainer.createEl("h3", { text: "Sources" });
        result.sources.forEach((source, index) => {
          const sourceItem = sourcesContainer.createDiv({ cls: "kb-source-item" });
          const sourceHeader = sourceItem.createDiv({ cls: "kb-source-header" });
          const sourceTitle = sourceHeader.createDiv({ cls: "kb-source-title" });
          sourceTitle.createEl("span", { text: `[${index + 1}] ` });
          const sourceLink = sourceTitle.createEl("a", {
            text: source.file.basename,
            cls: "kb-source-link"
          });
          sourceLink.addEventListener("click", () => {
            this.app.workspace.getLeaf().openFile(source.file);
          });
          const sourceInfo = sourceHeader.createDiv({ cls: "kb-source-info" });
          sourceInfo.createEl("span", {
            text: `${source.file.path} \u2022 Relevance: ${(source.similarity * 100).toFixed(1)}%`
          });
          if (source.content) {
            const previewContainer = sourceItem.createDiv({ cls: "kb-source-preview" });
            previewContainer.setText(source.content.length > 200 ? source.content.substring(0, 200) + "..." : source.content);
            if (source.content.length > 200) {
              const viewMoreBtn = sourceItem.createDiv({ cls: "kb-view-more-btn" });
              viewMoreBtn.setText("View More");
              let expanded = false;
              viewMoreBtn.addEventListener("click", () => {
                if (expanded) {
                  previewContainer.setText(source.content.substring(0, 200) + "...");
                  viewMoreBtn.setText("View More");
                } else {
                  previewContainer.setText(source.content);
                  viewMoreBtn.setText("View Less");
                }
                expanded = !expanded;
              });
            }
          }
        });
      }
    });
  }
  handleQA() {
    return __async(this, null, function* () {
      const query = this.searchInput.value.trim();
      if (!query) {
        this.resultsContainer.empty();
        this.resultsContainer.createDiv({
          cls: "kb-error-message",
          text: "Please enter a question."
        });
        return;
      }
      this.progressContainer.style.display = "block";
      this.progressText.textContent = "Processing your question...";
      this.progressBar.style.width = "0%";
      this.countText.textContent = "";
      this.resultsContainer.empty();
      try {
        const selectedDir = this.dirSelector.value;
        if (this.plugin.ragService) {
          const updateProgress = (stage, percent) => {
            this.progressText.textContent = stage;
            this.progressBar.style.width = `${percent}%`;
            this.countText.textContent = `Processing ${stage}`;
          };
          let streamedAnswer = "";
          const handleStream = (chunk) => {
            if (!chunk) return;
            streamedAnswer += chunk;
            this.resultsContainer.empty();
            const streamingContainer = this.resultsContainer.createDiv({ cls: "kb-rag-results-container streaming" });
            const answerDiv = streamingContainer.createDiv({ cls: "kb-rag-answer" });
            try {
              MarkdownRenderer.renderMarkdown(
                streamedAnswer,
                answerDiv,
                "",
                this.plugin
              );
            } catch (error) {
              console.warn("Error rendering streaming markdown:", error);
              answerDiv.setText(streamedAnswer);
            }
            if (this.progressContainer.style.display !== "none" && streamedAnswer.length > 50) {
              this.progressContainer.style.opacity = "0.7";
            }
          };
          const result = yield this.plugin.ragService.performCompleteRAG(query, {
            showProgress: true,
            onProgress: updateProgress,
            streaming: true,
            onChunk: handleStream,
            limit: 10,
            directory: selectedDir || void 0
          });
          this.progressContainer.style.display = "none";
          yield this.displayRAGResults(__spreadProps(__spreadValues({}, result), {
            answer: streamedAnswer || result.answer,
            query
          }));
        } else {
          new import_obsidian8.Notice("RAG service not available. Please check your configuration.");
        }
      } catch (error) {
        console.error("Error in Q&A:", error);
        this.progressContainer.style.display = "none";
        this.resultsContainer.empty();
        this.resultsContainer.createDiv({
          cls: "kb-error-message",
          text: `Error processing your question: ${error.message}`
        });
      }
    });
  }
  // Helper method to calculate file hash for caching
  calculateFileHash(content) {
    return __async(this, null, function* () {
      let hash = 0;
      for (let i = 0; i < content.length; i++) {
        const char = content.charCodeAt(i);
        hash = (hash << 5) - hash + char;
        hash = hash & hash;
      }
      return hash.toString();
    });
  }
  onClose() {
    return __async(this, null, function* () {
      this.contentEl.empty();
    });
  }
};

// src/main.ts
var DEFAULT_SETTINGS = {
  apiKey: "",
  model: "gpt-4",
  provider: "openai",
  knowledgeBasePath: "AI_KnowledgeBase",
  promptOrganize: 'Please organize the content of the following article logically, following an introduction-body-conclusion structure. Use Markdown format, ensuring a smooth flow between sections. Output in the same language as the input text:\n1. Use `#` and `##` for main and secondary headings, marking primary sections and sub-sections, respectively.\n2. If appropriate, divide content into list form or use block quotes (`>`) to present specific points.\n3. Avoid repetitive content, highlight key information, and ensure the article structure is clearer and easier to read.\n4. Summarize the core points of the article in the conclusion.\n5. Do not include any lines that start with "=".\nHere is the content that needs to be organized:',
  promptCheckGrammar: "Please check the grammar, typos, and punctuation in the following text. Never delete any content, and provide the corrected text in the same language. For any errors in the original text, please list them at the end of the corrected version:",
  promptGenerateContent: "Generate content based on the following prompt, maintaining the same language as the prompt: ",
  promptDialogue: "Engage in a Socratic dialogue based on the following text, using the same language as the input: ",
  chatModel: "GLM-4",
  promptSummary: `Analyze and summarize the following documents in the same language as the source documents:

1. Concise Summary: Synthesize the main content and key information
2. Document Insights: List key insights and important information from each document
3. Document Connections: Analyze logical relationships and connections between documents
4. References: Use numbers [n] to cite sources, using Obsidian link syntax [[filename]]

Guidelines:
- Maintain professionalism and logical flow
- Highlight important information and key concepts
- Ensure accurate citations and correct link format
- Use clear hierarchical structure for content presentation
- Use proper Markdown formatting for better readability`,
  customFunctions: [],
  functions: [
    {
      name: "Organize",
      icon: "file-text",
      prompt: 'Please organize the content of the following article logically, following an introduction-body-conclusion structure. Use Markdown format, ensuring a smooth flow between sections. Output in the same language as the input text:\n1. Use `#` and `##` for main and secondary headings, marking primary sections and sub-sections, respectively.\n2. If appropriate, divide content into list form or use block quotes (`>`) to present specific points.\n3. Avoid repetitive content, highlight key information, and ensure the article structure is clearer and easier to read.\n4. Summarize the core points of the article in the conclusion.\n5. Do not include any lines that start with "=".\nHere is the content that needs to be organized:',
      tooltip: "Organize text structure",
      isBuiltIn: true
    },
    {
      name: "Grammar",
      icon: "check-square",
      prompt: "Please check the grammar, typos, and punctuation in the following text. Never delete any content, and provide the corrected text in the same language. For any errors in the original text, please list them at the end of the corrected version:",
      tooltip: "Check grammar and spelling",
      isBuiltIn: true
    },
    {
      name: "Generate",
      icon: "sparkles",
      prompt: "Generate content based on the following prompt, maintaining the same language as the prompt: ",
      tooltip: "Generate content",
      isBuiltIn: true
    },
    {
      name: "Dialogue",
      icon: "message-circle",
      prompt: "Engage in a Socratic dialogue based on the following text, using the same language as the input: ",
      tooltip: "Start a dialogue",
      isBuiltIn: true
    },
    {
      name: "Summarize",
      icon: "bookmark",
      prompt: `Analyze and summarize the following documents in the same language as the source documents:

1. Concise Summary: Synthesize the main content and key information
2. Document Insights: List key insights and important information from each document
3. Document Connections: Analyze logical relationships and connections between documents
4. References: Use numbers [n] to cite sources, using Obsidian link syntax [[filename]]

Guidelines:
- Maintain professionalism and logical flow
- Highlight important information and key concepts
- Ensure accurate citations and correct link format
- Use clear hierarchical structure for content presentation
- Use proper Markdown formatting for better readability`,
      tooltip: "Summarize content",
      isBuiltIn: true
    },
    {
      name: "Polish",
      icon: "bird",
      prompt: `Please polish and refine the following text to improve clarity, flow, and style while preserving the original meaning and language. Enhance the expression, eliminate redundancies, and make it more engaging. Return the polished version only, without explanations:`,
      tooltip: "Polish and refine text",
      isBuiltIn: true
    }
  ],
  chatHistoryPath: "AI_ChatHistory",
  editorModeEnabled: true,
  embeddingModels: [
    {
      id: "default-openai-embedding",
      name: "OpenAI Embedding 3",
      type: "openai",
      modelName: "text-embedding-3-small",
      active: true,
      description: "Default OpenAI embedding model"
    }
  ],
  proxyConfig: {
    enabled: false,
    address: "",
    port: "",
    type: "http",
    requiresAuth: false
  },
  debateConfigs: [],
  models: [],
  requestId: "",
  secretKey: "",
  saveMemory: false,
  embeddingsInChunks: true,
  embeddingChunkSize: 1e3,
  embeddingChunkOverlap: 200
};
function encryptString(text, salt) {
  try {
    const textToChars = (text2) => text2.split("").map((c) => c.charCodeAt(0));
    const byteHex = (n) => ("0" + Number(n).toString(16)).substr(-2);
    const applySaltToChar = (code) => textToChars(salt).reduce((a, b) => a ^ b, code);
    return text.split("").map((c) => c.charCodeAt(0)).map(applySaltToChar).map(byteHex).join("");
  } catch (e) {
    console.error("Encryption error:", e);
    return "";
  }
}
function decryptString(encoded, salt) {
  var _a;
  try {
    const textToChars = (text) => text.split("").map((c) => c.charCodeAt(0));
    const applySaltToChar = (code) => textToChars(salt).reduce((a, b) => a ^ b, code);
    return ((_a = encoded.match(/.{1,2}/g)) == null ? void 0 : _a.map((hex) => parseInt(hex, 16)).map(applySaltToChar).map((charCode) => String.fromCharCode(charCode)).join("")) || encoded;
  } catch (e) {
    console.error("Decryption failed:", e);
    return encoded;
  }
}
function getIcon(iconName) {
  try {
    const tempEl = document.createElement("div");
    (0, import_obsidian9.setIcon)(tempEl, iconName);
    return tempEl.innerHTML.trim() || null;
  } catch (e) {
    console.error(`Failed to get icon: ${iconName}`, e);
    return null;
  }
}
var AIPilotPlugin = class extends import_obsidian9.Plugin {
  constructor(app, manifest) {
    super(app, manifest);
    this.requestId = null;
    this.salt = "AIPilot-v1";
    this.lastApiCall = 0;
    this.MIN_API_INTERVAL = 100;
    // 100ms between calls
    this.embeddingCache = /* @__PURE__ */ new Map();
    this.CACHE_DURATION = 1e3 * 60 * 60;
    // 1 hour
    this.currentInput = null;
    this.diffMatchPatchLib = null;
    this.app = app;
  }
  onload() {
    return __async(this, null, function* () {
      console.log("Loading AIPilot plugin");
      this.loadStyles();
      yield this.loadSettings();
      this.migrateLegacyAPIKey();
      this.migrateEmbeddingConfig();
      this.modelManager = new ModelManager(
        this,
        this.settings.models || [],
        this.settings.embeddingModels || [
          {
            id: "default-openai-embedding",
            name: "OpenAI Embedding 3",
            type: "openai",
            modelName: "text-embedding-3-small",
            active: true,
            description: "Default OpenAI embedding model"
          }
        ],
        this.settings.proxyConfig,
        () => __async(this, null, function* () {
          yield this.saveSettings();
        })
      );
      yield this.loadDiffMatchPatchLibrary();
      addAllIcons();
      this.registerView(
        VIEW_TYPE_CHAT,
        (leaf) => new ChatView(leaf, this, this.modelManager)
      );
      this.registerView(
        KNOWLEDGE_BASE_VIEW_TYPE,
        (leaf) => new KnowledgeBaseView(leaf, this)
      );
      this.registerView(
        DEBATE_VIEW_TYPE,
        (leaf) => new DebatePanel(leaf, this.modelManager)
      );
      this.addRibbonIcon("message-square", "AI Chat & Writing Assistant", () => {
        this.activateView();
      });
      this.addRibbonIcon("search", "AI Knowledge Base", () => {
        this.activateKnowledgeBaseView();
      });
      this.addRibbonIcon("users", "AI Agent Debate", () => {
        this.activateDebateView();
      });
      this.addCommand({
        id: "open-chat-view",
        name: "Open AI Chat & Writing Assistant",
        callback: () => this.activateView()
      });
      this.addCommand({
        id: "open-kb-view",
        name: "Open AI Knowledge Base",
        callback: () => this.activateKnowledgeBaseView()
      });
      this.addCommand({
        id: "open-debate-panel",
        name: "Open AI Agent Debate",
        callback: () => this.activateDebateView()
      });
      this.addCommands();
      this.addSettingTab(new AIPilotSettingTab(this.app, this));
      this.initializeRequestId();
      this.ragService = createRAGService(this.app, this, this.settings);
    });
  }
  onunload() {
  }
  saveSettings() {
    return __async(this, null, function* () {
      const dataToSave = __spreadValues({}, this.settings);
      if (dataToSave.apiKey) {
        dataToSave.apiKey = encryptString(dataToSave.apiKey, this.salt);
      }
      if (dataToSave.models && dataToSave.models.length > 0) {
        dataToSave.models = dataToSave.models.map((model) => {
          const modelCopy = __spreadValues({}, model);
          if (modelCopy.apiKey) {
            modelCopy.apiKey = encryptString(modelCopy.apiKey, this.salt);
          }
          return modelCopy;
        });
      }
      yield this.saveData(dataToSave);
    });
  }
  loadSettings() {
    return __async(this, null, function* () {
      this.settings = Object.assign({}, DEFAULT_SETTINGS, yield this.loadData());
      if (!this.settings.models) this.settings.models = [];
      if (!this.settings.functions) this.settings.functions = [];
      if (!this.settings.customFunctions) this.settings.customFunctions = [];
      if (!this.settings.debateConfigs) this.settings.debateConfigs = [];
      if (!this.settings.proxyConfig) {
        this.settings.proxyConfig = {
          enabled: false,
          address: "",
          port: "",
          type: "http",
          requiresAuth: false
        };
      }
      if (this.settings.apiKey) {
        try {
          const decrypted = decryptString(this.settings.apiKey, this.salt);
          const isValidFormat = decrypted.startsWith("sk-") && /^[a-zA-Z0-9_-]+$/.test(decrypted) || // For other providers, just make sure it's alphanumeric
          /^[a-zA-Z0-9_-]+$/.test(decrypted);
          this.settings.apiKey = isValidFormat ? decrypted : "";
          if (!isValidFormat) {
            console.log("Invalid API key format detected, resetting key");
          }
        } catch (e) {
          console.error("Error decrypting API key, resetting it", e);
          this.settings.apiKey = "";
        }
      }
      if (this.settings.models && this.settings.models.length > 0) {
        this.settings.models = this.settings.models.map((model) => {
          const modelCopy = __spreadValues({}, model);
          if (modelCopy.apiKey) {
            try {
              const decrypted = decryptString(modelCopy.apiKey, this.salt);
              if (decrypted && /^[a-zA-Z0-9_\-\.]+$/.test(decrypted)) {
                modelCopy.apiKey = decrypted;
              } else {
                modelCopy.apiKey = "";
                console.log(`Invalid API key format detected for model ${model.name}, resetting key`);
              }
            } catch (e) {
              console.error(`Error decrypting API key for model ${model.name}, resetting it`, e);
              modelCopy.apiKey = "";
            }
          }
          return modelCopy;
        });
      }
      const hasDefaultModel = this.settings.models.some((m) => m.isDefault);
      if (!hasDefaultModel && this.settings.models.length > 0) {
        const firstActive = this.settings.models.find((m) => m.active);
        if (firstActive) {
          firstActive.isDefault = true;
        } else if (this.settings.models.length > 0) {
          this.settings.models[0].isDefault = true;
          this.settings.models[0].active = true;
        }
      }
    });
  }
  initializeRequestId() {
    if (!this.requestId) {
      this.requestId = crypto.randomUUID();
    }
  }
  showFeatureModal() {
    new FeatureSelectionModal(this.app, this).open();
  }
  migrateLegacyAPIKey() {
    if (this.settings.apiKey && this.settings.model && (!this.settings.models || this.settings.models.length === 0)) {
      console.log("Migrating legacy API key to models system");
      this.settings.models.push({
        name: "Default Model",
        modelName: this.settings.model,
        apiKey: this.settings.apiKey,
        active: true,
        id: "default-model",
        isDefault: true,
        type: this.settings.provider || "openai"
      });
    }
  }
  migrateEmbeddingConfig() {
    if (this.settings.embeddingModels && (!this.settings.embeddingModels || !this.settings.embeddingModels.length)) {
      console.log("Migrating legacy embedding configuration");
      this.settings.embeddingModels = [
        {
          id: "default-openai-embedding",
          name: "OpenAI Embedding 3",
          type: "openai",
          modelName: "text-embedding-3-small",
          active: true,
          description: "Default OpenAI embedding model"
        }
      ];
    }
  }
  loadDiffMatchPatchLibrary() {
    return __async(this, null, function* () {
      try {
        if (!window.diff_match_patch) {
          const script = document.createElement("script");
          script.src = "https://cdnjs.cloudflare.com/ajax/libs/diff_match_patch/20121119/diff_match_patch.js";
          script.async = true;
          script.onload = () => {
            if (window.diff_match_patch) {
              this.diffMatchPatchLib = new window.diff_match_patch();
            }
          };
          document.head.appendChild(script);
        } else {
          this.diffMatchPatchLib = new window.diff_match_patch();
        }
      } catch (e) {
        console.error("Error loading diff_match_patch library:", e);
      }
    });
  }
  activateDebateView() {
    return __async(this, null, function* () {
      const workspace = this.app.workspace;
      let leaf = workspace.getLeavesOfType(DEBATE_VIEW_TYPE)[0];
      if (!leaf) {
        const rightLeaf = workspace.getRightLeaf(false);
        if (!rightLeaf) return;
        leaf = rightLeaf;
        yield leaf.setViewState({
          type: DEBATE_VIEW_TYPE,
          active: true
        });
      }
      workspace.revealLeaf(leaf);
    });
  }
  activateView() {
    return __async(this, null, function* () {
      const workspace = this.app.workspace;
      let leaf = workspace.getLeavesOfType(VIEW_TYPE_CHAT)[0];
      if (!leaf) {
        const rightLeaf = workspace.getRightLeaf(false);
        if (!rightLeaf) return;
        leaf = rightLeaf;
        yield leaf.setViewState({
          type: VIEW_TYPE_CHAT,
          active: true
        });
      }
      workspace.revealLeaf(leaf);
    });
  }
  activateKnowledgeBaseView() {
    return __async(this, null, function* () {
      const workspace = this.app.workspace;
      let leaf = workspace.getLeavesOfType(KNOWLEDGE_BASE_VIEW_TYPE)[0];
      if (!leaf) {
        const rightLeaf = workspace.getRightLeaf(false);
        if (!rightLeaf) return;
        leaf = rightLeaf;
        yield leaf.setViewState({
          type: KNOWLEDGE_BASE_VIEW_TYPE,
          active: true
        });
      }
      workspace.revealLeaf(leaf);
    });
  }
  polishText(editor) {
    return __async(this, null, function* () {
      if (!editor) {
        const mdView = this.app.workspace.getActiveViewOfType(import_obsidian9.MarkdownView);
        if (mdView) {
          editor = mdView.editor;
        } else {
          new import_obsidian9.Notice("No active editor found.");
          return;
        }
      }
      const selectedText = editor.getSelection();
      if (!selectedText) {
        new import_obsidian9.Notice("Please select text to polish.");
        return;
      }
      const loadingModal = new import_obsidian9.Notice("Polishing text...", 0);
      try {
        const polishFunc = this.settings.functions.find((f) => f.name === "Polish Text" || f.name === "Polish");
        const polishPrompt = polishFunc ? polishFunc.prompt : "Polish and refine the following text:";
        const polishedText = yield this.callAI(selectedText, polishPrompt);
        editor.replaceSelection(polishedText);
        loadingModal.hide();
        new import_obsidian9.Notice("Text polished successfully.", 2e3);
      } catch (error) {
        console.error("Error polishing text:", error);
        loadingModal.hide();
        new import_obsidian9.Notice("Error polishing text: " + (error.message || "Unknown error"));
      }
    });
  }
  cleanPolishMarkup(editor) {
    return __async(this, null, function* () {
      if (!editor) {
        const mdView = this.app.workspace.getActiveViewOfType(import_obsidian9.MarkdownView);
        if (mdView) {
          editor = mdView.editor;
        } else {
          new import_obsidian9.Notice("No active editor found.");
          return;
        }
      }
      const content = editor.getValue();
      const cleaned = content.replace(/\[\d+% into document\]/g, "").replace(/\[\[ORIGINAL\]\]([\s\S]*?)\[\[\/ORIGINAL\]\]/g, "").replace(/\[\[POLISHED\]\]([\s\S]*?)\[\[\/POLISHED\]\]/g, "$1").replace(/\n\s*\.\.\.\s*\n/g, "\n\n").replace(/^---\s*\n(Polish(ed)? version:?)?/gmi, "");
      editor.setValue(cleaned);
      new import_obsidian9.Notice("Polish markup cleaned.");
    });
  }
  addCommands() {
    this.addCommand({
      id: "organize-text",
      name: "Organize text",
      editorCallback: (editor) => this.organizeText(editor)
    });
    this.addCommand({
      id: "check-grammar",
      name: "Check grammar",
      editorCallback: (editor) => this.checkGrammar(editor)
    });
    this.addCommand({
      id: "generate-content",
      name: "Generate content",
      editorCallback: (editor) => this.generateAIContent(editor)
    });
    this.addCommand({
      id: "engage-in-dialogue",
      name: "Engage in Dialogue",
      editorCallback: (editor) => this.engageInDialogue(editor)
    });
    this.addCommand({
      id: "summarize-content",
      name: "Summarize Content",
      editorCallback: (editor) => this.summarizeContent(editor)
    });
    this.addCommand({
      id: "polish-text",
      name: "Polish Text",
      editorCallback: (editor) => this.polishText(editor)
    });
    this.addCommand({
      id: "clean-polish-markup",
      name: "Clean Polish Markup",
      editorCallback: (editor) => this.cleanPolishMarkup(editor)
    });
    this.addCommand({
      id: "custom-prompt",
      name: "Custom Prompt",
      editorCallback: (editor) => this.handleCustomPrompt(editor)
    });
  }
  // Most important core methods
  callAI(content, promptPrefix = "") {
    return __async(this, null, function* () {
      if (!this.modelManager) {
        throw new Error("Model manager not initialized");
      }
      const defaultModel = this.modelManager.getDefaultModel();
      if (!defaultModel) {
        throw new Error("No default model configured");
      }
      try {
        const prompt = `${promptPrefix}${content}`;
        return yield this.modelManager.callModel(
          defaultModel.id,
          prompt,
          { maxTokens: 8192 }
          // Default max tokens
        );
      } catch (error) {
        console.error("Error calling AI:", error);
        throw error;
      }
    });
  }
  organizeText(editor) {
    return __async(this, null, function* () {
    });
  }
  checkGrammar(editor) {
    return __async(this, null, function* () {
    });
  }
  generateAIContent(editor) {
    return __async(this, null, function* () {
      if (!editor) {
        const mdView = this.app.workspace.getActiveViewOfType(import_obsidian9.MarkdownView);
        if (mdView) {
          editor = mdView.editor;
        } else {
          new import_obsidian9.Notice("No active editor found.");
          return;
        }
      }
      const selectedText = editor.getSelection();
      if (!selectedText) {
        new import_obsidian9.Notice("Please select text or provide a prompt for content generation.");
        return;
      }
      const loadingModal = new import_obsidian9.Notice("Generating content...", 0);
      try {
        const generateFunc = this.settings.functions.find((f) => f.name === "Generate");
        const generatePrompt = generateFunc ? generateFunc.prompt : "Generate content based on the following prompt: ";
        const generatedContent = yield this.callAI(selectedText, generatePrompt);
        editor.replaceSelection(generatedContent);
        loadingModal.hide();
        new import_obsidian9.Notice("Content generated successfully.", 2e3);
      } catch (error) {
        console.error("Error generating content:", error);
        loadingModal.hide();
        new import_obsidian9.Notice("Error generating content: " + (error.message || "Unknown error"));
      }
    });
  }
  engageInDialogue(editor) {
    return __async(this, null, function* () {
      if (!editor) {
        const mdView = this.app.workspace.getActiveViewOfType(import_obsidian9.MarkdownView);
        if (mdView) {
          editor = mdView.editor;
        } else {
          new import_obsidian9.Notice("No active editor found.");
          return;
        }
      }
      const selectedText = editor.getSelection();
      if (!selectedText) {
        new import_obsidian9.Notice("Please select text to start a dialogue.");
        return;
      }
      const loadingModal = new import_obsidian9.Notice("Starting dialogue...", 0);
      try {
        const dialogueFunc = this.settings.functions.find((f) => f.name === "Dialogue");
        const dialoguePrompt = dialogueFunc ? dialogueFunc.prompt : "Engage in a Socratic dialogue based on the following text: ";
        const dialogueContent = yield this.callAI(selectedText, dialoguePrompt);
        const from = editor.getCursor("from");
        const to = editor.getCursor("to");
        editor.replaceRange("\n\n" + dialogueContent, to);
        loadingModal.hide();
        new import_obsidian9.Notice("Dialogue generated successfully.", 2e3);
      } catch (error) {
        console.error("Error generating dialogue:", error);
        loadingModal.hide();
        new import_obsidian9.Notice("Error generating dialogue: " + (error.message || "Unknown error"));
      }
    });
  }
  summarizeContent(editor) {
    return __async(this, null, function* () {
      if (!editor) {
        const mdView = this.app.workspace.getActiveViewOfType(import_obsidian9.MarkdownView);
        if (mdView) {
          editor = mdView.editor;
        } else {
          new import_obsidian9.Notice("No active editor found.");
          return;
        }
      }
      let textToSummarize = editor.getSelection();
      if (!textToSummarize) {
        textToSummarize = editor.getValue();
      }
      if (!textToSummarize) {
        new import_obsidian9.Notice("No content to summarize.");
        return;
      }
      const loadingModal = new import_obsidian9.Notice("Summarizing content...", 0);
      try {
        const summarizeFunc = this.settings.functions.find((f) => f.name === "Summarize");
        const summarizePrompt = summarizeFunc ? summarizeFunc.prompt : `Analyze and summarize the following content:`;
        const summary = yield this.callAI(textToSummarize, summarizePrompt);
        if (editor.somethingSelected()) {
          editor.replaceSelection(summary);
        } else {
          editor.replaceRange("\n\n---\n### Summary\n" + summary, { line: editor.lastLine(), ch: editor.getLine(editor.lastLine()).length });
        }
        loadingModal.hide();
        new import_obsidian9.Notice("Content summarized successfully.", 2e3);
      } catch (error) {
        console.error("Error summarizing content:", error);
        loadingModal.hide();
        new import_obsidian9.Notice("Error summarizing content: " + (error.message || "Unknown error"));
      }
    });
  }
  handleCustomPrompt(editor) {
    return __async(this, null, function* () {
    });
  }
  // Add method to manually load styles
  loadStyles() {
    const cssElement = document.createElement("style");
    cssElement.id = "aipilot-styles";
    cssElement.textContent = `
        /* Critical styles for AIPilot */
        .chat-view-container, .kb-view-container, .debate-view-container {
            height: 100%;
            display: flex;
            flex-direction: column;
            background-color: var(--background-secondary);
            color: var(--text-normal);
        }
        
        .chat-container, .kb-container, .debate-view-container {
            display: flex;
            flex-direction: column;
            height: 100%;
            padding: 0;
            margin: 0;
        }
        
        .messages-container {
            flex-grow: 1;
            overflow-y: auto;
            padding: 16px;
            display: flex;
            flex-direction: column;
            gap: 16px;
        }
        
        .input-container {
            display: flex;
            flex-direction: column;
            padding: 8px 16px 16px;
            border-top: 1px solid var(--background-modifier-border);
            background-color: var(--background-primary);
        }
        
        .input-wrapper {
            display: flex;
            position: relative;
            width: 100%;
            align-items: flex-end;
            gap: 8px;
        }
        
        .chat-input {
            flex: 1;
            resize: none;
            padding: 12px;
            border-radius: 6px;
            min-height: 60px;
            max-height: 200px;
            background: var(--background-primary);
            color: var(--text-normal);
            border: 1px solid var(--background-modifier-border);
            font-family: var(--font-text);
            line-height: 1.5;
        }
        
        .function-icons-container {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-top: 8px;
            position: relative;
        }
        
        .function-icon-button {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 6px 10px;
            border-radius: 4px;
            background-color: var(--background-secondary);
            color: var(--text-normal);
            cursor: pointer;
            transition: background-color 0.2s ease;
            border: 1px solid var(--background-modifier-border);
        }
        
        .function-icon-button:hover {
            background-color: var(--background-modifier-hover);
        }
        
        /* Knowledge Base Search View Styles */
        .kb-view-container {
            display: flex;
            flex-direction: column;
            height: 100%;
            background: var(--background-primary);
            padding: 16px;
        }

        .kb-search-header {
            text-align: center;
            margin-bottom: 24px;
        }

        .kb-search-header h2 {
            font-size: 24px;
            margin-bottom: 8px;
            color: var(--text-normal);
        }

        .kb-search-header p {
            color: var(--text-muted);
            font-size: 14px;
        }

        .kb-search-container {
            background: var(--background-secondary);
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            margin-bottom: 20px;
            animation: fadeIn 0.3s ease-out;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .kb-search-input-wrapper {
            position: relative;
            margin-bottom: 16px;
        }

        .kb-search-input {
            width: 100%;
            padding: 12px 16px;
            font-size: 16px;
            border: 2px solid var(--background-modifier-border);
            border-radius: 8px;
            background: var(--background-primary);
            color: var(--text-normal);
            transition: all 0.3s ease;
        }

        .kb-search-input:focus {
            border-color: var(--interactive-accent);
            box-shadow: 0 0 0 3px rgba(var(--interactive-accent-rgb), 0.2);
            outline: none;
        }

        .kb-search-buttons {
            display: flex;
            gap: 12px;
            margin-bottom: 16px;
        }

        .kb-search-button {
            flex: 1;
            padding: 10px 20px;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        .kb-search-button.primary {
            background: var(--interactive-accent);
            color: var(--text-on-accent);
            border: none;
        }

        .kb-search-button.primary:hover {
            background: var(--interactive-accent-hover);
            transform: translateY(-1px);
        }

        .kb-search-button.secondary {
            background: var(--background-modifier-form-field);
            color: var(--text-normal);
            border: 1px solid var(--background-modifier-border);
        }

        .kb-search-button.secondary:hover {
            background: var(--background-modifier-form-field-highlighted);
        }

        .kb-results-container {
            flex: 1;
            overflow-y: auto;
            padding: 16px;
            background: var(--background-primary);
            border-radius: 8px;
            border: 1px solid var(--background-modifier-border);
        }

        .kb-result-item {
            padding: 16px;
            margin-bottom: 16px;
            background: var(--background-secondary);
            border-radius: 8px;
            border: 1px solid var(--background-modifier-border);
            transition: all 0.2s ease;
        }

        .kb-result-item:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            border-color: var(--interactive-accent);
        }

        .kb-result-title {
            font-size: 16px;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text-normal);
        }

        .kb-result-excerpt {
            font-size: 14px;
            color: var(--text-muted);
            line-height: 1.5;
        }

        .kb-result-meta {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-top: 12px;
            padding-top: 12px;
            border-top: 1px solid var(--background-modifier-border);
            font-size: 12px;
            color: var(--text-muted);
        }

        .kb-loading-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 32px;
            text-align: center;
        }

        .kb-loading-spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--background-modifier-border);
            border-top-color: var(--interactive-accent);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .kb-loading-text {
            margin-top: 16px;
            color: var(--text-muted);
            font-size: 14px;
        }

        .kb-empty-state {
            text-align: center;
            padding: 48px 24px;
            color: var(--text-muted);
        }

        .kb-empty-state-icon {
            font-size: 48px;
            margin-bottom: 16px;
            opacity: 0.5;
        }

        .kb-empty-state-text {
            font-size: 16px;
            margin-bottom: 8px;
        }

        .kb-empty-state-subtext {
            font-size: 14px;
            opacity: 0.8;
        }

        /* Loading indicator */
        .loading-indicator {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 4px;
            margin: 8px 0;
            height: 20px;
        }

        .loading-indicator .dot {
            width: 6px;
            height: 6px;
            background-color: var(--text-muted);
            border-radius: 50%;
            animation: pulse 1.4s infinite;
            opacity: 0.6;
        }

        .loading-indicator .dot:nth-child(2) {
            animation-delay: 0.2s;
        }

        .loading-indicator .dot:nth-child(3) {
            animation-delay: 0.4s;
        }

        @keyframes pulse {
            0% { transform: scale(0.8); opacity: 0.6; }
            50% { transform: scale(1.2); opacity: 0.8; }
            100% { transform: scale(0.8); opacity: 0.6; }
        }

        /* Message actions */
        .message-action-button {
            opacity: 0.8;
            transition: all 0.2s ease;
            position: relative;
            border-radius: 4px;
            padding: 4px;
            margin: 0 2px;
            background-color: rgba(var(--text-normal-rgb), 0.05);
        }

        .message-action-button:hover {
            opacity: 1;
            transform: scale(1.05);
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }

        .message-action-button:active {
            transform: scale(0.95);
        }

        .message-action-button svg {
            width: 18px;
            height: 18px;
        }

        /* Copy button */
        .message-action-button.copy-button:hover {
            background-color: rgba(var(--text-accent-rgb), 0.1);
        }

        .message-action-button.copy-button svg {
            color: var(--text-accent);
        }

        /* Insert button */
        .message-action-button.insert-button:hover {
            background-color: rgba(var(--text-success-rgb), 0.1);
        }

        .message-action-button.insert-button svg {
            color: var(--text-success);
        }

        /* Apply button */
        .message-action-button.apply-button:hover {
            background-color: rgba(var(--interactive-accent-rgb), 0.2);
        }
        `;
    document.head.appendChild(cssElement);
    console.log("AIPilot styles loaded successfully");
  }
  /**
   * Advanced search using embeddings
   * @param query Search query
   * @param limit Maximum number of results
   * @param loadingModal Loading modal for progress updates
   * @returns Array of search results
   */
  advancedSearch(query, limit = 10, loadingModal) {
    return __async(this, null, function* () {
      try {
        if (!this.ragService) {
          throw new Error("RAG service not initialized");
        }
        const retriever = this.ragService.getRetrievers()[0];
        if (!retriever) {
          throw new Error("No retriever available");
        }
        if (loadingModal) {
          loadingModal.setMessage("Searching knowledge base...");
        }
        const results = yield retriever.retrieve(query, limit);
        results.sort((a, b) => b.similarity - a.similarity);
        return results;
      } catch (error) {
        console.error("Error in advanced search:", error);
        throw error;
      }
    });
  }
};
var AIPilotSettingTab = class extends import_obsidian9.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    var _a;
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "AI Pilot Settings" });
    containerEl.createEl("h3", { text: "AI Model Configuration" });
    const modelsContainer = containerEl.createDiv();
    const models = this.plugin.modelManager.getModels();
    if (models.length === 0) {
      modelsContainer.createEl("p", { text: "No AI models configured yet. Add a model to get started." });
    } else {
      for (const model of models) {
        this.createModelCard(modelsContainer, model);
      }
    }
    const addModelContainer = containerEl.createDiv({ cls: "add-model-container" });
    const addModelBtn = addModelContainer.createEl("button", {
      cls: "add-model-button",
      text: "Add New AI Model"
    });
    addModelBtn.addEventListener("click", () => {
      const configModal = new ModelConfigModal(
        this.app,
        null,
        (newModel) => {
          this.plugin.modelManager.addModel(newModel);
          this.display();
          new import_obsidian9.Notice(`Added new model: ${newModel.name}`);
        }
      );
      configModal.open();
    });
    containerEl.createEl("h3", { text: "Embedding Models" });
    const embeddingModelsContainer = containerEl.createDiv({ cls: "model-list-container" });
    const embeddingModels = this.plugin.modelManager.getEmbeddingModels();
    if (embeddingModels.length === 0) {
      embeddingModelsContainer.createEl("p", { text: "No embedding models configured yet. Add a model to get started." });
    } else {
      for (const model of embeddingModels) {
        this.createEmbeddingModelCard(embeddingModelsContainer, model);
      }
    }
    const addEmbeddingModelContainer = containerEl.createDiv({ cls: "add-model-container" });
    const addEmbeddingModelBtn = addEmbeddingModelContainer.createEl("button", {
      cls: "add-model-button",
      text: "Add New Embedding Model"
    });
    addEmbeddingModelBtn.addEventListener("click", () => {
      const configModal = new EmbeddingModelConfigModal(
        this.app,
        null,
        (newModel) => {
          this.plugin.modelManager.addEmbeddingModel(newModel);
          this.display();
          new import_obsidian9.Notice(`Added new embedding model: ${newModel.name}`);
        }
      );
      configModal.open();
    });
    containerEl.createEl("h3", { text: "Knowledge Base Configuration" });
    new import_obsidian9.Setting(containerEl).setName("Knowledge Base Path").setDesc("Path to your knowledge base folder").addText((text) => text.setPlaceholder("e.g., Knowledge Base").setValue(this.plugin.settings.knowledgeBasePath).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.knowledgeBasePath = value;
      yield this.plugin.saveSettings();
    })));
    new import_obsidian9.Setting(containerEl).setName("Use Chunking for Embeddings").setDesc("Split documents into chunks for more precise retrieval").addToggle((toggle) => toggle.setValue(this.plugin.settings.embeddingsInChunks || false).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.embeddingsInChunks = value;
      yield this.plugin.saveSettings();
      this.display();
    })));
    if (this.plugin.settings.embeddingsInChunks) {
      new import_obsidian9.Setting(containerEl).setName("Chunk Size").setDesc("Number of characters per chunk").addText((text) => text.setPlaceholder("1000").setValue(String(this.plugin.settings.embeddingChunkSize || 1e3)).onChange((value) => __async(this, null, function* () {
        const numValue = parseInt(value);
        if (!isNaN(numValue) && numValue > 0) {
          this.plugin.settings.embeddingChunkSize = numValue;
          yield this.plugin.saveSettings();
        }
      })));
      new import_obsidian9.Setting(containerEl).setName("Chunk Overlap").setDesc("Number of characters to overlap between chunks").addText((text) => text.setPlaceholder("200").setValue(String(this.plugin.settings.embeddingChunkOverlap || 200)).onChange((value) => __async(this, null, function* () {
        const numValue = parseInt(value);
        if (!isNaN(numValue) && numValue >= 0) {
          this.plugin.settings.embeddingChunkOverlap = numValue;
          yield this.plugin.saveSettings();
        }
      })));
    }
    containerEl.createEl("h3", { text: "Chat History Configuration" });
    new import_obsidian9.Setting(containerEl).setName("Chat History Path").setDesc("Path to store chat history files").addText((text) => text.setPlaceholder("e.g., Chat History").setValue(this.plugin.settings.chatHistoryPath).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.chatHistoryPath = value;
      yield this.plugin.saveSettings();
    })));
    new import_obsidian9.Setting(containerEl).setName("Save Chat History").setDesc("Save chat history to files").addToggle((toggle) => toggle.setValue(this.plugin.settings.saveMemory || false).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.saveMemory = value;
      yield this.plugin.saveSettings();
    })));
    containerEl.createEl("h3", { text: "Function Configuration" });
    new import_obsidian9.Setting(containerEl).setName("Editor Mode").setDesc("Toggle between Editor and Chat modes for functions").addToggle((toggle) => toggle.setValue(this.plugin.settings.editorModeEnabled).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.editorModeEnabled = value;
      yield this.plugin.saveSettings();
    })));
    const functions = this.plugin.settings.functions.filter((f) => f.isBuiltIn);
    for (const func of functions) {
      const funcSetting = new import_obsidian9.Setting(containerEl).setName(func.name).setDesc(`Built-in function: ${func.tooltip}`).addButton((button) => button.setButtonText("Edit Prompt").onClick(() => {
        const modal = new PromptEditModal(this.app, this.plugin, func);
        modal.open();
      }));
      if (func.icon) {
        funcSetting.nameEl.createSpan({ cls: "setting-function-icon" }, (span) => {
          (0, import_obsidian9.setIcon)(span, func.icon);
        });
      }
    }
    containerEl.createEl("h3", { text: "Custom Functions" });
    const customFunctions = this.plugin.settings.functions.filter((f) => !f.isBuiltIn);
    if (customFunctions.length === 0) {
      containerEl.createEl("p", { text: "No custom functions defined." });
    } else {
      for (const func of customFunctions) {
        const funcSetting = new import_obsidian9.Setting(containerEl).setName(func.name).setDesc(func.tooltip || "Custom function").addButton((button) => button.setButtonText("Edit").onClick(() => {
          const modal = new CustomFunctionModal(this.app, this.plugin, func);
          modal.open();
        })).addButton((button) => button.setButtonText("Delete").setWarning().onClick(() => __async(this, null, function* () {
          this.plugin.settings.functions = this.plugin.settings.functions.filter((f) => f !== func);
          yield this.plugin.saveSettings();
          this.display();
        })));
        if (func.icon) {
          funcSetting.nameEl.createSpan({ cls: "setting-function-icon" }, (span) => {
            (0, import_obsidian9.setIcon)(span, func.icon);
          });
        }
      }
    }
    new import_obsidian9.Setting(containerEl).addButton((button) => button.setButtonText("+ Add Custom Function").setCta().onClick(() => {
      const modal = new CustomFunctionModal(this.app, this.plugin);
      modal.open();
    }));
    containerEl.createEl("h3", { text: "Proxy Configuration" });
    new import_obsidian9.Setting(containerEl).setName("Enable Proxy").setDesc("Use a proxy for API calls").addToggle((toggle) => {
      var _a2;
      return toggle.setValue(((_a2 = this.plugin.settings.proxyConfig) == null ? void 0 : _a2.enabled) || false).onChange((value) => __async(this, null, function* () {
        if (!this.plugin.settings.proxyConfig) {
          this.plugin.settings.proxyConfig = {
            enabled: value,
            address: "",
            port: "",
            type: "http",
            requiresAuth: false
          };
        } else {
          this.plugin.settings.proxyConfig.enabled = value;
        }
        yield this.plugin.saveSettings();
        this.display();
      }));
    });
    if ((_a = this.plugin.settings.proxyConfig) == null ? void 0 : _a.enabled) {
      new import_obsidian9.Setting(containerEl).setName("Proxy Type").setDesc("Type of proxy to use").addDropdown((dropdown) => dropdown.addOption("http", "HTTP").addOption("https", "HTTPS").addOption("socks5", "SOCKS").setValue(this.plugin.settings.proxyConfig.type || "http").onChange((value) => __async(this, null, function* () {
        this.plugin.settings.proxyConfig.type = value;
        yield this.plugin.saveSettings();
      })));
      new import_obsidian9.Setting(containerEl).setName("Proxy Address").setDesc("Hostname or IP of the proxy server").addText((text) => text.setPlaceholder("e.g., proxy.example.com").setValue(this.plugin.settings.proxyConfig.address || "").onChange((value) => __async(this, null, function* () {
        this.plugin.settings.proxyConfig.address = value;
        yield this.plugin.saveSettings();
      })));
      new import_obsidian9.Setting(containerEl).setName("Proxy Port").setDesc("Port number for the proxy server").addText((text) => text.setPlaceholder("e.g., 8080").setValue(this.plugin.settings.proxyConfig.port || "").onChange((value) => __async(this, null, function* () {
        this.plugin.settings.proxyConfig.port = value;
        yield this.plugin.saveSettings();
      })));
    }
  }
  // Helper to get a friendly name for model providers
  getProviderDisplayName(type) {
    const providers = {
      "openai": "OpenAI",
      "zhipuai": "ZhipuAI",
      "claude": "Anthropic Claude",
      "ollama": "Ollama",
      "custom": "Custom API",
      "zhipu": "Zhipu AI",
      "baidu": "Baidu"
    };
    return providers[type] || type;
  }
  // Add helper method to create embedding model cards
  createEmbeddingModelCard(container, model) {
    const modelItem = container.createDiv({ cls: "model-list-item" });
    const statusIndicator = modelItem.createDiv({
      cls: `model-status-indicator ${model.active ? "active" : "inactive"}`
    });
    const modelInfo = modelItem.createDiv({ cls: "model-info" });
    const titleRow = modelInfo.createDiv({ cls: "model-title-row" });
    titleRow.createEl("h4", {
      text: model.name,
      cls: "model-name"
    });
    titleRow.createSpan({
      text: model.active ? "Active" : "Inactive",
      cls: `model-status-text ${model.active ? "active" : "inactive"}`
    });
    modelInfo.createDiv({
      text: `${this.getProviderDisplayName(model.type)} - ${model.modelName}`,
      cls: "model-provider"
    });
    if (model.description) {
      modelInfo.createDiv({
        text: model.description,
        cls: "model-details"
      });
    }
    const modelActions = modelItem.createDiv({ cls: "model-actions" });
    const editBtn = modelActions.createEl("button", {
      cls: "model-action-button edit-button",
      text: "Edit"
    });
    editBtn.addEventListener("click", () => {
      const configModal = new EmbeddingModelConfigModal(
        this.app,
        model,
        (updatedModel) => {
          this.plugin.modelManager.updateEmbeddingModel(model.id, updatedModel);
          this.display();
        }
      );
      configModal.open();
    });
    const deleteBtn = modelActions.createEl("button", {
      cls: "model-action-button delete-button",
      text: "Delete"
    });
    deleteBtn.addEventListener("click", () => {
      new ConfirmModal(
        this.app,
        `Are you sure you want to delete the embedding model "${model.name}"?`,
        () => __async(this, null, function* () {
          this.plugin.modelManager.removeEmbeddingModel(model.id);
          this.display();
          new import_obsidian9.Notice(`Deleted embedding model: ${model.name}`);
        })
      ).open();
    });
  }
  // Add the missing createModelCard method
  createModelCard(container, model) {
    const card = container.createDiv({ cls: "model-card" });
    const header = card.createDiv({ cls: "header" });
    const titleSection = header.createDiv({ cls: "title-section" });
    const statusDot = titleSection.createDiv({
      cls: `status-dot ${model.active ? "active" : ""}`
    });
    const modelInfo = titleSection.createDiv({ cls: "model-info" });
    const nameRow = modelInfo.createDiv({ cls: "model-name" });
    nameRow.createSpan({ text: model.name });
    if (model.active) {
      nameRow.createSpan({ cls: "active-badge", text: "ACTIVE" });
    }
    if (model.isDefault) {
      nameRow.createSpan({ cls: "default-badge", text: "DEFAULT" });
    }
    modelInfo.createDiv({
      cls: "model-type",
      text: model.type.charAt(0).toUpperCase() + model.type.slice(1)
    });
    const actions = header.createDiv({ cls: "actions" });
    const editBtn = actions.createEl("button", { text: "Edit" });
    editBtn.addEventListener("click", () => {
      const configModal = new ModelConfigModal(
        this.app,
        model,
        (updatedModel) => {
          this.plugin.modelManager.updateModel(model.id, updatedModel);
          this.display();
          new import_obsidian9.Notice(`Updated model: ${updatedModel.name}`);
        }
      );
      configModal.open();
    });
    const deleteBtn = actions.createEl("button", {
      text: "Delete",
      cls: "delete-button"
    });
    deleteBtn.addEventListener("click", () => {
      const confirm = new import_obsidian9.Notice(
        `Delete model ${model.name}?`,
        0
      );
      confirm.noticeEl.createEl("button", {
        text: "Delete",
        cls: "mod-warning"
      }).addEventListener("click", () => {
        this.plugin.modelManager.removeModel(model.id);
        this.display();
        confirm.hide();
        new import_obsidian9.Notice(`Deleted model: ${model.name}`);
      });
    });
    if (model.description) {
      card.createDiv({
        cls: "description",
        text: model.description
      });
    }
  }
};
var FeatureSelectionModal = class extends import_obsidian9.Modal {
  constructor(app, plugin) {
    super(app);
    this.plugin = plugin;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", { text: "Select AI Feature" });
    const functions = this.plugin.settings.functions;
    if (!functions || functions.length === 0) {
      contentEl.createEl("p", { text: "No features configured. Please add features in settings." });
      return;
    }
    const buttonsContainer = contentEl.createDiv({ cls: "feature-buttons" });
    functions.forEach((func) => {
      const button = buttonsContainer.createEl("button", {
        text: func.name,
        cls: "feature-button"
      });
      if (func.icon) {
        (0, import_obsidian9.setIcon)(button, func.icon);
      }
      button.addEventListener("click", () => {
        this.close();
        const activeView = this.app.workspace.getActiveViewOfType(import_obsidian9.MarkdownView);
        if (!activeView) {
          new import_obsidian9.Notice("No active editor found.");
          return;
        }
        const editor = activeView.editor;
        const selectedText = editor.getSelection();
        if (!selectedText) {
          new import_obsidian9.Notice("Please select text to process.");
          return;
        }
        this.processFeature(func, editor, selectedText);
      });
    });
  }
  processFeature(func, editor, selectedText) {
    return __async(this, null, function* () {
      const loadingNotice = new import_obsidian9.Notice(`Processing with ${func.name}...`, 0);
      try {
        const result = yield this.plugin.callAI(selectedText, func.prompt);
        editor.replaceSelection(result);
        loadingNotice.hide();
        new import_obsidian9.Notice(`${func.name} completed successfully.`, 2e3);
      } catch (error) {
        console.error(`Error in ${func.name}:`, error);
        loadingNotice.hide();
        new import_obsidian9.Notice(`Error in ${func.name}: ${error.message || "Unknown error"}`);
      }
    });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var LoadingModal2 = class extends import_obsidian9.Modal {
  constructor(app, message) {
    super(app);
    this.message = message;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("loading-modal");
    this.loadingEl = contentEl.createDiv({ cls: "loading-spinner" });
    this.loadingEl.createSpan({ text: this.message });
    const spinner = this.loadingEl.createDiv({ cls: "spinner" });
    for (let i = 0; i < 4; i++) {
      spinner.createDiv({ cls: "spin-segment" });
    }
  }
  setMessage(message) {
    this.message = message;
    if (this.loadingEl) {
      const spanElement = this.loadingEl.querySelector("span");
      if (spanElement) {
        spanElement.textContent = message;
      }
    }
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var PolishResultModal = class extends import_obsidian9.Modal {
  constructor(app, original, polished) {
    super(app);
    this.original = original;
    this.polished = polished;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("polish-result-modal");
    contentEl.createEl("h2", { text: "Polish Result" });
    const container = contentEl.createDiv({ cls: "polish-compare-container" });
    const originalDiv = container.createDiv({ cls: "polish-section original" });
    originalDiv.createEl("h3", { text: "Original" });
    const originalContent = originalDiv.createDiv({ cls: "content" });
    originalContent.createEl("p", { text: this.original });
    const polishedDiv = container.createDiv({ cls: "polish-section polished" });
    polishedDiv.createEl("h3", { text: "Polished" });
    const polishedContent = polishedDiv.createDiv({ cls: "content" });
    polishedContent.createEl("div", {
      cls: "markdown-rendered",
      text: this.polished
    });
    const buttonDiv = contentEl.createDiv({ cls: "polish-buttons" });
    const usePolishedBtn = buttonDiv.createEl("button", { text: "Use Polished Version" });
    usePolishedBtn.addEventListener("click", () => {
      const mdView = this.app.workspace.getActiveViewOfType(import_obsidian9.MarkdownView);
      if (mdView) {
        mdView.editor.replaceSelection(this.polished);
        this.close();
        new import_obsidian9.Notice("Applied polished text to editor");
      } else {
        new import_obsidian9.Notice("No active editor to apply text to");
      }
    });
    const closeBtn = buttonDiv.createEl("button", { text: "Close" });
    closeBtn.addEventListener("click", () => {
      this.close();
    });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var PromptEditModal = class extends import_obsidian9.Modal {
  constructor(app, plugin, func) {
    super(app);
    this.plugin = plugin;
    this.function = func;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", { text: `Edit ${this.function.name} Prompt` });
    const promptContainer = contentEl.createDiv({ cls: "prompt-edit-container" });
    const promptArea = promptContainer.createEl("textarea", {
      cls: "prompt-edit-textarea",
      attr: {
        rows: "10"
      }
    });
    promptArea.value = this.function.prompt;
    const buttonContainer = contentEl.createDiv({ cls: "prompt-edit-buttons" });
    const saveButton = buttonContainer.createEl("button", {
      text: "Save Changes",
      cls: "prompt-edit-save"
    });
    const cancelButton = buttonContainer.createEl("button", {
      text: "Cancel",
      cls: "prompt-edit-cancel"
    });
    saveButton.addEventListener("click", () => __async(this, null, function* () {
      const funcIndex = this.plugin.settings.functions.findIndex((f) => f.name === this.function.name && f.isBuiltIn === this.function.isBuiltIn);
      if (funcIndex !== -1) {
        this.plugin.settings.functions[funcIndex].prompt = promptArea.value;
        yield this.plugin.saveSettings();
        new import_obsidian9.Notice(`Updated ${this.function.name} prompt`);
      }
      this.close();
    }));
    cancelButton.addEventListener("click", () => {
      this.close();
    });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var CustomFunctionModal = class extends import_obsidian9.Modal {
  constructor(app, plugin, func) {
    super(app);
    this.iconPreviewEl = null;
    this.plugin = plugin;
    this.function = func || null;
  }
  onOpen() {
    var _a, _b, _c, _d;
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("custom-function-modal");
    contentEl.createEl("h2", { text: this.function ? "Edit Custom Function" : "Create Custom Function" });
    const formContainer = contentEl.createDiv({ cls: "custom-function-form" });
    const nameContainer = formContainer.createDiv({ cls: "form-group" });
    nameContainer.createEl("label", { text: "Function Name" });
    const nameInput = nameContainer.createEl("input", {
      type: "text",
      cls: "function-name-input",
      attr: {
        placeholder: "Enter function name"
      }
    });
    nameInput.value = ((_a = this.function) == null ? void 0 : _a.name) || "";
    const iconContainer = formContainer.createDiv({ cls: "form-group" });
    const iconHeader = iconContainer.createDiv({ cls: "icon-header" });
    const iconLabelContainer = iconHeader.createDiv({ cls: "label-with-help" });
    iconLabelContainer.createEl("label", { text: "Icon Name" });
    const iconHelpLink = iconLabelContainer.createEl("a", {
      cls: "icon-help-link",
      href: "https://lucide.dev/icons/",
      text: "View available icons"
    });
    iconHelpLink.setAttribute("target", "_blank");
    iconHelpLink.setAttribute("rel", "noopener noreferrer");
    const iconPreviewContainer = iconHeader.createDiv({ cls: "icon-preview-container" });
    const iconPreviewLabel = iconPreviewContainer.createSpan({ cls: "icon-preview-label", text: "Preview: " });
    this.iconPreviewEl = iconPreviewContainer.createDiv({ cls: "icon-preview" });
    const iconInputContainer = iconContainer.createDiv({ cls: "icon-input-container" });
    const iconInput = iconInputContainer.createEl("input", {
      type: "text",
      cls: "function-icon-input",
      attr: {
        placeholder: "e.g., sparkles, check, star, file-text"
      }
    });
    iconInput.value = ((_b = this.function) == null ? void 0 : _b.icon) || "";
    this.updateIconPreview(iconInput.value);
    iconInput.addEventListener("input", () => {
      this.updateIconPreview(iconInput.value);
    });
    const iconExamples = iconContainer.createDiv({ cls: "icon-examples" });
    iconExamples.createSpan({ text: "Examples: " });
    const commonIcons = [
      { name: "file-text", display: "Text" },
      { name: "check-square", display: "Check" },
      { name: "sparkles", display: "Sparkles" },
      { name: "message-circle", display: "Chat" },
      { name: "bookmark", display: "Bookmark" },
      { name: "bird", display: "Polish" },
      { name: "star", display: "Star" },
      { name: "zap", display: "Zap" }
    ];
    for (const icon of commonIcons) {
      const iconBtn = iconExamples.createEl("button", {
        cls: "icon-example-button",
        attr: { "data-icon": icon.name, "title": icon.name }
      });
      const svgIcon = getIcon(icon.name);
      if (svgIcon) {
        iconBtn.innerHTML = svgIcon;
      } else {
        iconBtn.textContent = icon.name.charAt(0).toUpperCase();
      }
      iconBtn.addEventListener("click", () => {
        iconInput.value = icon.name;
        this.updateIconPreview(icon.name);
      });
    }
    const tooltipContainer = formContainer.createDiv({ cls: "form-group" });
    tooltipContainer.createEl("label", { text: "Tooltip" });
    const tooltipInput = tooltipContainer.createEl("input", {
      type: "text",
      cls: "function-tooltip-input",
      attr: {
        placeholder: "Brief description shown on hover"
      }
    });
    tooltipInput.value = ((_c = this.function) == null ? void 0 : _c.tooltip) || "";
    const promptContainer = formContainer.createDiv({ cls: "form-group" });
    promptContainer.createEl("label", { text: "Prompt Template" });
    const promptArea = promptContainer.createEl("textarea", {
      cls: "function-prompt-textarea",
      attr: {
        rows: "8",
        placeholder: "Enter the prompt template for this function"
      }
    });
    promptArea.value = ((_d = this.function) == null ? void 0 : _d.prompt) || "";
    const buttonContainer = contentEl.createDiv({ cls: "custom-function-buttons" });
    const saveButton = buttonContainer.createEl("button", {
      text: this.function ? "Save Changes" : "Create Function",
      cls: "custom-function-save"
    });
    const cancelButton = buttonContainer.createEl("button", {
      text: "Cancel",
      cls: "custom-function-cancel"
    });
    saveButton.addEventListener("click", () => __async(this, null, function* () {
      if (!nameInput.value.trim()) {
        new import_obsidian9.Notice("Function name cannot be empty");
        return;
      }
      if (!promptArea.value.trim()) {
        new import_obsidian9.Notice("Prompt template cannot be empty");
        return;
      }
      const functionData = {
        name: nameInput.value.trim(),
        icon: iconInput.value.trim() || "message-square",
        tooltip: tooltipInput.value.trim() || nameInput.value.trim(),
        prompt: promptArea.value.trim(),
        isBuiltIn: false
      };
      if (this.function) {
        const funcIndex = this.plugin.settings.functions.findIndex((f) => {
          var _a2;
          return f.name === ((_a2 = this.function) == null ? void 0 : _a2.name) && !f.isBuiltIn;
        });
        if (funcIndex !== -1) {
          this.plugin.settings.functions[funcIndex] = functionData;
        }
      } else {
        this.plugin.settings.functions.push(functionData);
      }
      yield this.plugin.saveSettings();
      new import_obsidian9.Notice(`${this.function ? "Updated" : "Created"} custom function ${functionData.name}`);
      this.close();
    }));
    cancelButton.addEventListener("click", () => {
      this.close();
    });
  }
  // Helper method to update icon preview
  updateIconPreview(iconName) {
    if (!this.iconPreviewEl) return;
    this.iconPreviewEl.empty();
    if (!iconName) {
      this.iconPreviewEl.setText("No icon selected");
      return;
    }
    const svgIcon = getIcon(iconName);
    if (svgIcon) {
      this.iconPreviewEl.innerHTML = svgIcon;
    } else {
      this.iconPreviewEl.setText(`Icon not found: ${iconName}`);
    }
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var ConfirmModal = class extends import_obsidian9.Modal {
  constructor(app, message, onConfirm) {
    super(app);
    this.message = message;
    this.onConfirm = onConfirm;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("confirm-modal");
    contentEl.createEl("p", { text: this.message, cls: "confirm-message" });
    const buttonContainer = contentEl.createDiv({ cls: "confirm-button-container" });
    const confirmBtn = buttonContainer.createEl("button", { text: "Confirm", cls: "confirm-button" });
    const cancelBtn = buttonContainer.createEl("button", { text: "Cancel", cls: "cancel-button" });
    confirmBtn.onclick = () => {
      this.close();
      this.onConfirm();
    };
    cancelBtn.onclick = () => {
      this.close();
    };
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
