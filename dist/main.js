/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// src/main.ts
var main_exports = {};
__export(main_exports, {
  DEFAULT_SETTINGS: () => DEFAULT_SETTINGS,
  LoadingModal: () => LoadingModal2,
  PolishResultModal: () => PolishResultModal,
  default: () => AIPilot
});
module.exports = __toCommonJS(main_exports);
var import_obsidian3 = require("obsidian");

// src/styles.css
var styles_default = `/* styles.css */
/* AI Pilot Plugin Styles - Scoped to prevent conflicts with Obsidian global styles */

/* Custom Prompt Input (Modal specific styles) */
.aipilot-modal .custom-prompt-input {
    width: 100%;
    min-height: 150px;
    background: var(--background-secondary);
    border: 1px solid var(--background-modifier-border);
    color: var(--text-normal);
    padding: 16px;
    border-radius: 8px;
    font-size: 15px;
    margin-bottom: 24px;
    resize: vertical;
    transition: border-color 0.2s ease;
}

.aipilot-modal .custom-prompt-input:focus {
    border-color: var(--interactive-accent);
    outline: none;
}

/* Button Container */
.aipilot-button-container {
    display: grid;
    grid-template-columns: repeat(2, 1fr);
    gap: 16px;
    padding: 0 16px 24px;
    width: 100%;
    margin: 0 auto;
}

/* Chat Tabs - Reduced Size */
.chat-view-container .chat-tabs {
    display: flex;
    border-bottom: 1px solid var(--background-modifier-border);
    background-color: var(--background-primary);
    padding: 4px;
}

.chat-view-container .chat-tab {
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    padding: 4px;
    border-radius: 4px;
    margin-right: 4px;
    transition: all 0.2s ease;
}

.chat-view-container .chat-tab:hover {
    background-color: var(--background-modifier-hover);
}

.chat-view-container .chat-tab.active {
    background-color: var(--background-modifier-active);
}

.chat-view-container .chat-tab svg {
    width: 18px;  /* Reduced from default size */
    height: 18px; /* Reduced from default size */
    color: var(--text-muted);
    transition: color 0.2s ease;
}

.chat-view-container .chat-tab:hover svg {
    color: var(--text-normal);
}

/* View Container Transitions */
.chat-view-container .view-container {
    transition: opacity 0.2s ease;
    display: flex;
    flex-direction: column;
    height: 100%;
}

/* Add more space between the tabs for better visual separation */
.chat-view-container .chat-tab + .chat-tab {
    margin-left: 6px;
}

/* Subtle shadow for active tab */
.chat-view-container .chat-tab.active {
    box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
}

/* Chat Container Elements */
.chat-view-container .chat-container {
    display: flex;
    flex-direction: column;
    height: 100%;
    background-color: var(--background-secondary);
    color: var(--text-normal);
}

.chat-view-container .messages-container {
    flex-grow: 1;
    overflow-y: auto;
    padding: 16px 16px 0;
    display: flex;
    flex-direction: column;
    gap: 16px;
    scroll-behavior: smooth; /* Add smooth scrolling */
    margin-bottom: 4px; /* Add space between messages and input */
}

/* Input Area - Fixed at bottom */
.chat-view-container .input-container {
    display: flex;
    flex-direction: column;
    padding: 8px 16px 16px;
    border-top: 1px solid var(--background-modifier-border);
    background-color: var(--background-primary);
    position: relative;
}

.input-wrapper {
    display: flex;
    position: relative;
    width: 100%;
}

.chat-input {
    flex: 1;
    resize: none;
    padding: 12px;
    border-radius: 6px;
    min-height: 80px;
    max-height: 200px;
    background: var(--background-primary);
    color: var(--text-normal);
    border: 1px solid var(--background-modifier-border);
    font-family: var(--font-text);
    line-height: 1.5;
}

/* Remove styles for mode-toggle-button and chat-send-button */

/* Function icons styling */
.function-icons-container {
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
    margin-top: 8px;
}

/* Messages */
.chat-view-container .user-message, 
.chat-view-container .ai-message {
    padding: 12px 16px;
    border-radius: 8px;
    max-width: 85%;
    line-height: 1.5;
    animation: fade-in 0.2s ease-out;
}

@keyframes fade-in {
    from { opacity: 0; transform: translateY(5px); }
    to { opacity: 1; transform: translateY(0); }
}

.chat-view-container .user-message {
    margin: 10px 0;
    background-color: var(--background-modifier-hover);
    color: var(--text-normal);
}

.chat-view-container .ai-message {
    position: relative;
    display: flex;
    flex-direction: column;
    background-color: var(--background-secondary);
    color: var(--text-normal);
    margin-bottom: 16px;
    margin-right: auto;
    margin-left: 0;
}

.chat-view-container .ai-message .message-content {
    flex: 1;
    display: flex;
    flex-direction: column;
    gap: 8px;
}

.chat-view-container .ai-message .message-text {
    flex: 1;
}

.chat-view-container .ai-message .message-metadata {
    font-size: 12px;
    color: var(--text-muted);
}

/* Function Buttons & Controls */
.chat-view-container .controls-row {
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 8px;
    width: 100%;
    padding: 8px;
    flex-wrap: nowrap;
}

/* Buttons */
.chat-view-container .reference-button,
.chat-view-container .function-icon-button {
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 4px 8px;
    border-radius: 4px;
    background-color: var(--background-modifier-hover);
    cursor: pointer;
    transition: background-color 0.2s ease;
}

.chat-view-container .reference-button:hover,
.chat-view-container .function-icon-button:hover {
    background-color: var(--background-modifier-active);
}

.chat-view-container .reference-button:focus,
.chat-view-container .function-icon-button:focus {
    box-shadow: 0 0 0 2px var(--background-modifier-border);
    outline: none;
}

.chat-view-container .function-icon-button {
    background: none;
    border: none;
    border-radius: 4px;
    color: var(--text-muted);
    cursor: pointer;
    padding: 4px;
    position: relative;
    transition: background-color 0.2s, color 0.2s;
    display: flex;
    align-items: center;
    justify-content: center;
}

.chat-view-container .function-icon-button:hover {
    background-color: var(--background-modifier-hover);
    color: var(--text-normal);
}

.chat-view-container .function-icon-button.built-in {
    color: var(--text-normal);
}

.chat-view-container .function-icon-button.custom-function {
    color: var(--text-accent);
}

.chat-view-container .function-icon-button svg {
    width: 20px;
    height: 20px;
}

.chat-view-container .ai-message .function-icon-button {
    width: 28px;
    height: 28px;
    padding: 4px;
}

/* Tooltips */
.chat-view-container .function-icon-tooltip {
    position: absolute;
    bottom: 100%;
    left: 50%;
    transform: translateX(-50%);
    background-color: var(--background-secondary);
    color: var(--text-normal);
    padding: 4px 8px;
    border-radius: 4px;
    font-size: 12px;
    white-space: nowrap;
    opacity: 0;
    visibility: hidden;
    transition: opacity 0.2s, visibility 0.2s;
    z-index: 100;
    pointer-events: none;
    margin-bottom: 4px;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
}

.chat-view-container .function-icon-button:hover .function-icon-tooltip {
    opacity: 1;
    visibility: visible;
}

/* States */
.chat-view-container .loading {
    opacity: 0.7;
}

/* Hover-only elements */
.chat-view-container .hover-only {
    opacity: 0;
    transition: opacity 0.2s ease;
}

.chat-view-container *:hover > .hover-only,
.chat-view-container *:focus-within > .hover-only {
    opacity: 1;
}

/* Keyboard accessibility - show hover elements when using keyboard navigation */
.chat-view-container .function-icon-button:focus-visible .function-icon-tooltip {
    opacity: 1;
    visibility: visible;
}

/* Search View Styles */
.chat-view-container .search-container {
    display: flex;
    flex-direction: column;
    height: 100%;
    padding: 16px;
    gap: 16px;
    background-color: var(--background-secondary);
}

.chat-view-container .search-input-container {
    display: flex;
    flex-direction: column;
    gap: 8px;
    padding: 12px;
    background: var(--background-primary);
    border-radius: 8px;
    border: 1px solid var(--background-modifier-border);
}

.chat-view-container .search-input-row {
    display: flex;
    gap: 8px;
}

.chat-view-container .search-input {
    flex: 1;
    height: 36px;
    padding: 8px;
    border-radius: 4px;
    border: 1px solid var(--background-modifier-border);
    background: var(--background-primary);
    transition: border-color 0.2s ease, box-shadow 0.2s ease;
}

.chat-view-container .search-input:focus {
    border-color: var(--interactive-accent);
    box-shadow: 0 0 0 2px rgba(var(--interactive-accent-rgb), 0.2);
    outline: none;
}

.chat-view-container .search-button {
    min-width: 80px;
    height: 36px;
    padding: 8px 16px;
    background-color: var(--interactive-accent);
    color: var(--text-on-accent);
    border-radius: 4px;
    border: none;
    cursor: pointer;
    transition: background-color 0.2s ease;
}

.chat-view-container .search-button:hover {
    background-color: var(--interactive-accent-hover);
}

.chat-view-container .search-results {
    flex: 1;
    overflow-y: auto;
        padding: 16px;
    background: var(--background-primary);
    border-radius: 8px;
    border: 1px solid var(--background-modifier-border);
}

/* Custom Function Styles */
.custom-function-item {
    display: flex;
    padding: 8px 12px;
    margin: 8px 0;
    background-color: var(--background-secondary);
    border-radius: 4px;
    align-items: center;
    justify-content: space-between;
    transition: background-color 0.2s;
}

.custom-function-item:hover {
    background-color: var(--background-primary-alt);
}

.custom-function-preview {
    display: flex;
    align-items: center;
    gap: 10px;
}

.custom-function-icon {
    display: flex;
    align-items: center;
    justify-content: center;
    color: var(--text-accent);
}

.custom-function-name {
    font-weight: 500;
}

.custom-function-actions {
    display: flex;
    gap: 8px;
}

.custom-function-edit, .custom-function-delete {
    background: none;
    border: none;
    cursor: pointer;
    padding: 4px;
    border-radius: 4px;
    color: var(--text-muted);
    display: flex;
    align-items: center;
    justify-content: center;
    transition: color 0.2s, background-color 0.2s;
}

.custom-function-edit:hover {
    color: var(--text-normal);
    background-color: var(--background-modifier-hover);
}

.custom-function-delete:hover {
    color: var(--text-error);
    background-color: var(--background-modifier-hover);
}

/* Add tooltip hint for custom function buttons */
.custom-function-edit:hover::after,
.custom-function-delete:hover::after {
    position: absolute;
    padding: 4px 8px;
    border-radius: 4px;
    background-color: var(--background-secondary);
    color: var(--text-normal);
    font-size: 12px;
    z-index: 100;
    white-space: nowrap;
}

.custom-function-edit:hover::after {
    content: "Edit function";
    transform: translateY(-24px);
}

.custom-function-delete:hover::after {
    content: "Delete function";
    transform: translateY(-24px);
}

/* Prompt settings customization */
.prompt-setting textarea {
    min-height: 120px;
    font-family: var(--font-monospace);
    font-size: 0.9em;
    line-height: 1.5;
    resize: vertical;
}

.prompt-setting .setting-item-info {
    flex: 1;
}

.prompt-setting .setting-item-control {
    flex: 2;
}

.prompt-setting {
    padding-bottom: 24px;
    border-bottom: 1px solid var(--background-modifier-border);
    margin-bottom: 12px;
}

/* Custom function modal */
.custom-function-modal .setting-item {
    margin-bottom: 16px;
}

.custom-function-modal .setting-item-name {
    font-weight: 600;
    margin-bottom: 8px;
    display: block;
}

.custom-function-modal .setting-item-description {
    margin-bottom: 8px;
    color: var(--text-muted);
    font-size: 0.9em;
}

.custom-function-modal .setting-item-input {
    width: 100%;
    padding: 8px;
    border-radius: 4px;
    border: 1px solid var(--background-modifier-border);
    background-color: var(--background-primary);
}

.custom-function-modal .prompt-input {
    min-height: 120px;
    font-family: var(--font-monospace);
    resize: vertical;
}

.custom-function-modal .icon-row {
    display: flex;
    align-items: center;
    gap: 12px;
}

.custom-function-modal .icon-preview {
    display: flex;
    align-items: center;
    justify-content: center;
    width: 32px;
    height: 32px;
    background-color: var(--background-secondary);
    border-radius: 4px;
    border: 1px solid var(--background-modifier-border);
    color: var(--text-normal);
}

.custom-function-modal .custom-function-button-container {
    display: flex;
    justify-content: flex-end;
    gap: 8px;
    margin-top: 24px;
}

.functions-container {
    margin: 16px 0;
}

.no-functions {
    font-style: italic;
    color: var(--text-muted);
}

/* Keyboard accessibility - show hover elements when using keyboard navigation */
.chat-view-container .function-icon-button:focus-visible .function-icon-tooltip {
    opacity: 1;
    visibility: visible;
}

/* Settings page function items */
.function-section {
    margin-bottom: 20px;
}

.function-section h3 {
    margin-bottom: 10px;
    font-weight: 600;
    font-size: 1.1em;
    color: var(--text-normal);
}

.function-item {
    display: flex;
    padding: 8px 12px;
    margin: 8px 0;
    background-color: var(--background-secondary);
    border-radius: 4px;
    align-items: center;
    justify-content: space-between;
    transition: background-color 0.2s;
}

.function-item:hover {
    background-color: var(--background-primary-alt);
}

.function-item.built-in {
    border-left: 3px solid var(--text-normal);
}

.function-item.custom {
    border-left: 3px solid var(--text-accent);
}

.function-preview {
    display: flex;
    align-items: center;
    gap: 12px;
}

.function-icon {
    display: flex;
    align-items: center;
    justify-content: center;
    width: 24px;
    height: 24px;
}

.function-item.built-in .function-icon {
    color: var(--text-normal);
}

.function-item.custom .function-icon {
    color: var(--text-accent);
}

.function-name {
    font-weight: 500;
}

.function-tooltip {
    font-size: 0.9em;
    color: var(--text-muted);
    margin-left: 4px;
}

.function-actions {
    display: flex;
    gap: 8px;
}

.function-edit, .function-delete {
    background: none;
    border: none;
    cursor: pointer;
    padding: 4px;
    border-radius: 4px;
    color: var(--text-muted);
    display: flex;
    align-items: center;
    justify-content: center;
    transition: color 0.2s, background-color 0.2s;
}

.function-edit:hover {
    color: var(--text-normal);
    background-color: var(--background-modifier-hover);
}

.function-delete:hover {
    color: var(--text-error);
    background-color: var(--background-modifier-hover);
}

/* Tooltip hints for function buttons */
.function-edit:hover::after,
.function-delete:hover::after {
    position: absolute;
    padding: 4px 8px;
    border-radius: 4px;
    background-color: var(--background-secondary);
    color: var(--text-normal);
    font-size: 12px;
    z-index: 100;
    white-space: nowrap;
}

.function-edit:hover::after {
    content: "Edit function";
    transform: translateY(-24px);
}

.function-delete:hover::after {
    content: "Delete function";
    transform: translateY(-24px);
}

/* Chat History Button */
.chat-history-button {
    position: absolute;
    top: 15px;
    right: 50px;
    width: 28px;
        height: 28px;
    display: flex;
    align-items: center;
    justify-content: center;
    background-color: var(--background-secondary);
    border-radius: 4px;
    cursor: pointer;
    z-index: 10;
    transition: background-color 0.2s ease;
}

.chat-history-button:hover {
    background-color: var(--background-modifier-hover);
}

.chat-history-button svg {
    width: 18px;
    height: 18px;
    color: var(--text-normal);
}

/* New Chat Button */
.new-chat-button {
    position: absolute;
    top: 15px;
    right: 15px;
    width: 28px;
    height: 28px;
    display: flex;
    align-items: center;
    justify-content: center;
    background-color: var(--background-secondary);
    border-radius: 4px;
    cursor: pointer;
    z-index: 10;
    transition: background-color 0.2s ease;
}

.new-chat-button:hover {
    background-color: var(--background-modifier-hover);
}

.new-chat-button svg {
    width: 18px;
    height: 18px;
    color: var(--text-normal);
}

/* Chat History Modal */
.chat-history-modal {
    padding: 20px;
    max-width: 600px;
    max-height: 80vh;
}

.history-header-container {
    display: flex;
    align-items: center;
    justify-content: space-between;
    margin-bottom: 15px;
}

.chat-history-modal h2 {
    margin: 0;
}

.export-button-container {
    display: flex;
    justify-content: flex-end;
}

.export-button {
    background-color: var(--interactive-accent);
    color: var(--text-on-accent);
    border: none;
    padding: 6px 12px;
    border-radius: 4px;
    cursor: pointer;
    font-size: 12px;
    font-weight: 500;
    transition: background-color 0.2s ease;
}

.export-button:hover {
    background-color: var(--interactive-accent-hover);
}

.history-list {
    display: flex;
    flex-direction: column;
    gap: 10px;
    max-height: 60vh;
    overflow-y: auto;
    padding-right: 5px;
}

.history-date-header {
    font-weight: bold;
    margin-top: 10px;
    padding: 5px 0;
    border-bottom: 1px solid var(--background-modifier-border);
    color: var(--text-muted);
    position: sticky;
    top: 0;
    background-color: var(--background-primary);
    z-index: 1;
}

.history-item {
    border-radius: 6px;
    overflow: hidden;
    background-color: var(--background-secondary);
    margin-bottom: 8px;
    display: flex;
    transition: transform 0.15s ease;
}

.history-item:hover {
    transform: translateY(-2px);
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
}

.history-item-content {
    flex: 1;
    padding: 12px 15px;
    cursor: pointer;
    border-left: 3px solid var(--interactive-accent);
}

.history-item-actions {
    display: flex;
    align-items: center;
    padding: 0 10px;
}

.history-delete-button {
    background: transparent;
    border: none;
    color: var(--text-muted);
    padding: 4px;
    border-radius: 4px;
    cursor: pointer;
    opacity: 0.7;
    transition: opacity 0.2s, color 0.2s, background-color 0.2s;
}

.history-delete-button:hover {
    opacity: 1;
    color: var(--text-error);
    background-color: rgba(var(--red-rgb), 0.1);
}

.history-title {
    font-weight: bold;
    margin-bottom: 5px;
    color: var(--text-normal);
}

.history-meta {
    font-size: 12px;
    color: var(--text-muted);
    margin-bottom: 8px;
}

.history-preview {
    font-size: 13px;
    opacity: 0.8;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    color: var(--text-normal);
}

.history-preview-role {
    font-weight: bold;
    color: var(--text-accent);
}

.history-preview-content {
    color: var(--text-muted);
}

/* AI Polish Effect */
.ai-polish-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.5);
    z-index: 1000;
    display: flex;
    align-items: center;
    justify-content: center;
}

.ai-polish-effect {
    background-color: white;
    padding: 15px 25px;
    border-radius: 8px;
    font-size: 1.2em;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
    animation: pulsate 1.5s infinite alternate;
}

.polish-highlight {
    background: linear-gradient(120deg, #84fab0 0%, #8fd3f4 100%);
    padding: 2px 6px;
    border-radius: 4px;
    color: #333;
    font-weight: bold;
}

@keyframes pulsate {
    0% {
        opacity: 0.7;
        transform: scale(1);
    }
    100% {
        opacity: 1;
        transform: scale(1.05);
    }
}

/* Chat History Search */
.history-search-container {
    position: relative;
    margin-bottom: 15px;
}

.history-search-input {
    width: 100%;
    padding: 8px 32px 8px 10px;
    border-radius: 4px;
    border: 1px solid var(--background-modifier-border);
    background-color: var(--background-primary);
    color: var(--text-normal);
    font-size: 14px;
    transition: border-color 0.2s ease, box-shadow 0.2s ease;
}

.history-search-input:focus {
    border-color: var(--interactive-accent);
    box-shadow: 0 0 0 2px rgba(var(--interactive-accent-rgb), 0.2);
    outline: none;
}

.history-search-clear {
    position: absolute;
    right: 8px;
    top: 50%;
    transform: translateY(-50%);
    background: none;
    border: none;
    color: var(--text-muted);
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 4px;
    border-radius: 50%;
    transition: background-color 0.2s, color 0.2s;
}

.history-search-clear:hover {
    background-color: var(--background-modifier-hover);
    color: var(--text-error);
}

.history-search-clear svg {
    width: 16px;
    height: 16px;
}

/* History Rename Feature */
.history-rename-button {
    background: transparent;
    border: none;
    color: var(--text-muted);
    padding: 4px;
    border-radius: 4px;
    cursor: pointer;
    opacity: 0.7;
    transition: opacity 0.2s, color 0.2s, background-color 0.2s;
    margin-right: 4px;
}

.history-rename-button:hover {
    opacity: 1;
    color: var(--text-accent);
    background-color: rgba(var(--interactive-accent-rgb), 0.1);
}

.history-rename-input {
    width: 100%;
    padding: 4px 8px;
    border-radius: 4px;
    border: 1px solid var(--interactive-accent);
    background-color: var(--background-primary);
    color: var(--text-normal);
    font-size: 14px;
    font-weight: bold;
    outline: none;
    box-shadow: 0 0 0 2px rgba(var(--interactive-accent-rgb), 0.2);
}

.history-rename-input:focus {
    border-color: var(--interactive-accent);
}

/* Pinned Conversations */
.pinned-section {
    margin-bottom: 20px;
}

.pinned-header {
    color: var(--text-accent);
    font-size: 14px;
    font-weight: 600;
    margin-bottom: 10px;
    display: flex;
    align-items: center;
    gap: 6px;
}

.pinned-header::before {
    content: '';
    display: inline-block;
    width: 14px;
    height: 14px;
    background-color: var(--text-accent);
    mask-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="12" y1="17" x2="12" y2="22"></line><path d="M5 17h14v-1.76a2 2 0 0 0-1.11-1.79l-1.78-.9A2 2 0 0 1 15 10.76V6h1a2 2 0 0 0 0-4H8a2 2 0 0 0 0 4h1v4.76a2 2 0 0 1-1.11 1.79l-1.78-.9A2 2 0 0 0 5 15.24Z"></path></svg>');
    mask-repeat: no-repeat;
    mask-position: center;
    mask-size: contain;
    -webkit-mask-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="12" y1="17" x2="12" y2="22"></line><path d="M5 17h14v-1.76a2 2 0 0 0-1.11-1.79l-1.78-.9A2 2 0 0 1 15 10.76V6h1a2 2 0 0 0 0-4H8a2 2 0 0 0 0 4h1v4.76a2 2 0 0 1-1.11 1.79l-1.78-.9A2 2 0 0 0 5 15.24Z"></path></svg>');
    -webkit-mask-repeat: no-repeat;
    -webkit-mask-position: center;
    -webkit-mask-size: contain;
}

.pinned-conversation .history-item-content {
    border-left-color: var(--text-accent);
    background-color: rgba(var(--interactive-accent-rgb), 0.05);
}

.history-pin-button {
    background: transparent;
    border: none;
    color: var(--text-muted);
    padding: 4px;
    border-radius: 4px;
    cursor: pointer;
    opacity: 0.7;
    transition: opacity 0.2s, color 0.2s, background-color 0.2s;
    margin-right: 4px;
}

.history-pin-button:hover {
    opacity: 1;
    color: var(--text-accent);
    background-color: rgba(var(--interactive-accent-rgb), 0.1);
}

.history-pin-button.pinned {
    color: var(--text-accent);
    opacity: 1;
}

/* Add loading spinner styles */
.spinner {
    width: 70px;
    text-align: center;
    margin: 20px auto;
}

.spinner > div {
    width: 18px;
    height: 18px;
    background-color: var(--text-accent);
    border-radius: 100%;
    display: inline-block;
    animation: sk-bouncedelay 1.4s infinite ease-in-out both;
    margin: 0 3px;
}

.spinner .bounce1 {
    animation-delay: -0.32s;
}

.spinner .bounce2 {
    animation-delay: -0.16s;
}

@keyframes sk-bouncedelay {
    0%, 80%, 100% { 
        transform: scale(0);
    } 
    40% { 
        transform: scale(1.0);
    }
}

.loading-text {
    text-align: center;
    margin: 10px 0;
    color: var(--text-muted);
}

/* Polish Modal styles */
.polish-result-modal {
    max-width: 800px;
    max-height: 80vh;
    overflow-y: auto;
}

.polish-result-container {
    padding: 12px;
    border-radius: 6px;
    background-color: var(--background-primary);
    margin: 12px 0;
    font-family: var(--font-text);
    line-height: 1.5;
    white-space: pre-wrap;
    overflow-wrap: break-word;
    border: 1px solid var(--background-modifier-border);
    max-height: 50vh;
    overflow-y: auto;
}

.polish-description {
    color: var(--text-muted);
    margin-bottom: 12px;
}

.polish-button-container {
    display: flex;
    justify-content: flex-end;
    gap: 8px;
    margin-top: 12px;
}

.polish-deleted {
    text-decoration: line-through;
    color: var(--text-error);
    background-color: rgba(255, 0, 0, 0.1);
}

.polish-highlight {
    color: var(--text-accent);
    background-color: rgba(128, 0, 255, 0.1);
    font-weight: 500;
}

/* For direct editing in the editor */
.cm-strikethrough {
    text-decoration: line-through;
    color: var(--text-error);
}

/* Tooltip hints for function buttons */
.function-icon-button:hover::after {
    content: attr(aria-label);
    position: absolute;
    top: 100%;
    left: 50%;
    transform: translateX(-50%);
    background: var(--background-secondary);
    color: var(--text-normal);
    padding: 4px 8px;
    border-radius: 4px;
    font-size: 12px;
    white-space: nowrap;
    z-index: 100;
    pointer-events: none;
    opacity: 0.9;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
}

/* Progress modal styles */
.loading-modal h2 {
    margin-bottom: 15px;
}

.count-text, .progress-text {
    text-align: center;
    margin: 5px 0;
    color: var(--text-muted);
}

.progress-text {
    font-weight: bold;
    color: var(--text-accent);
}

.message-actions {
    display: flex;
    gap: 8px;
    margin-top: 4px;
}

.message-action-button {
    background: transparent;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    padding: 4px;
    color: var(--text-muted);
    transition: all 0.2s ease;
}

.message-action-button:hover {
    color: var(--text-normal);
    background-color: var(--background-modifier-hover);
}

.message-action-button.apply-button {
    color: var(--text-accent);
}

.message-action-button.apply-button:hover {
    background-color: var(--background-modifier-success-hover);
}

.hover-only {
    opacity: 0.3;
    transition: opacity 0.2s ease;
}

.message-content:hover .hover-only {
    opacity: 1;
}

/* Compact error display for chat view */
.chat-view-container .error-container {
    display: flex;
    align-items: center;
    padding: 8px 12px;
    gap: 8px;
    background-color: var(--background-primary);
    border-radius: 4px;
    border-left: 2px solid var(--text-error);
}

.chat-view-container .error-icon {
    color: var(--text-error);
    flex-shrink: 0;
    width: 18px;
    height: 18px;
}

.chat-view-container .error-text {
    flex-grow: 1;
    font-size: 14px;
    color: var(--text-error-hover);
}

.chat-view-container .compact-retry-button {
    background-color: var(--interactive-accent);
    color: var(--text-on-accent);
    border: none;
    border-radius: 4px;
    padding: 4px 8px;
    font-size: 12px;
    cursor: pointer;
    white-space: nowrap;
    transition: background-color 0.2s ease;
    flex-shrink: 0;
}

.chat-view-container .compact-retry-button:hover {
    background-color: var(--interactive-accent-hover);
}
`;

// src/ChatView.ts
var import_obsidian2 = require("obsidian");

// node_modules/marked/lib/marked.esm.js
function _getDefaults() {
  return {
    async: false,
    breaks: false,
    extensions: null,
    gfm: true,
    hooks: null,
    pedantic: false,
    renderer: null,
    silent: false,
    tokenizer: null,
    walkTokens: null
  };
}
var _defaults = _getDefaults();
function changeDefaults(newDefaults) {
  _defaults = newDefaults;
}
var noopTest = { exec: () => null };
function edit(regex, opt = "") {
  let source = typeof regex === "string" ? regex : regex.source;
  const obj = {
    replace: (name, val) => {
      let valSource = typeof val === "string" ? val : val.source;
      valSource = valSource.replace(other.caret, "$1");
      source = source.replace(name, valSource);
      return obj;
    },
    getRegex: () => {
      return new RegExp(source, opt);
    }
  };
  return obj;
}
var other = {
  codeRemoveIndent: /^(?: {1,4}| {0,3}\t)/gm,
  outputLinkReplace: /\\([\[\]])/g,
  indentCodeCompensation: /^(\s+)(?:```)/,
  beginningSpace: /^\s+/,
  endingHash: /#$/,
  startingSpaceChar: /^ /,
  endingSpaceChar: / $/,
  nonSpaceChar: /[^ ]/,
  newLineCharGlobal: /\n/g,
  tabCharGlobal: /\t/g,
  multipleSpaceGlobal: /\s+/g,
  blankLine: /^[ \t]*$/,
  doubleBlankLine: /\n[ \t]*\n[ \t]*$/,
  blockquoteStart: /^ {0,3}>/,
  blockquoteSetextReplace: /\n {0,3}((?:=+|-+) *)(?=\n|$)/g,
  blockquoteSetextReplace2: /^ {0,3}>[ \t]?/gm,
  listReplaceTabs: /^\t+/,
  listReplaceNesting: /^ {1,4}(?=( {4})*[^ ])/g,
  listIsTask: /^\[[ xX]\] /,
  listReplaceTask: /^\[[ xX]\] +/,
  anyLine: /\n.*\n/,
  hrefBrackets: /^<(.*)>$/,
  tableDelimiter: /[:|]/,
  tableAlignChars: /^\||\| *$/g,
  tableRowBlankLine: /\n[ \t]*$/,
  tableAlignRight: /^ *-+: *$/,
  tableAlignCenter: /^ *:-+: *$/,
  tableAlignLeft: /^ *:-+ *$/,
  startATag: /^<a /i,
  endATag: /^<\/a>/i,
  startPreScriptTag: /^<(pre|code|kbd|script)(\s|>)/i,
  endPreScriptTag: /^<\/(pre|code|kbd|script)(\s|>)/i,
  startAngleBracket: /^</,
  endAngleBracket: />$/,
  pedanticHrefTitle: /^([^'"]*[^\s])\s+(['"])(.*)\2/,
  unicodeAlphaNumeric: /[\p{L}\p{N}]/u,
  escapeTest: /[&<>"']/,
  escapeReplace: /[&<>"']/g,
  escapeTestNoEncode: /[<>"']|&(?!(#\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\w+);)/,
  escapeReplaceNoEncode: /[<>"']|&(?!(#\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\w+);)/g,
  unescapeTest: /&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/ig,
  caret: /(^|[^\[])\^/g,
  percentDecode: /%25/g,
  findPipe: /\|/g,
  splitPipe: / \|/,
  slashPipe: /\\\|/g,
  carriageReturn: /\r\n|\r/g,
  spaceLine: /^ +$/gm,
  notSpaceStart: /^\S*/,
  endingNewline: /\n$/,
  listItemRegex: (bull) => new RegExp(`^( {0,3}${bull})((?:[	 ][^\\n]*)?(?:\\n|$))`),
  nextBulletRegex: (indent) => new RegExp(`^ {0,${Math.min(3, indent - 1)}}(?:[*+-]|\\d{1,9}[.)])((?:[ 	][^\\n]*)?(?:\\n|$))`),
  hrRegex: (indent) => new RegExp(`^ {0,${Math.min(3, indent - 1)}}((?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$)`),
  fencesBeginRegex: (indent) => new RegExp(`^ {0,${Math.min(3, indent - 1)}}(?:\`\`\`|~~~)`),
  headingBeginRegex: (indent) => new RegExp(`^ {0,${Math.min(3, indent - 1)}}#`),
  htmlBeginRegex: (indent) => new RegExp(`^ {0,${Math.min(3, indent - 1)}}<(?:[a-z].*>|!--)`, "i")
};
var newline = /^(?:[ \t]*(?:\n|$))+/;
var blockCode = /^((?: {4}| {0,3}\t)[^\n]+(?:\n(?:[ \t]*(?:\n|$))*)?)+/;
var fences = /^ {0,3}(`{3,}(?=[^`\n]*(?:\n|$))|~{3,})([^\n]*)(?:\n|$)(?:|([\s\S]*?)(?:\n|$))(?: {0,3}\1[~`]* *(?=\n|$)|$)/;
var hr = /^ {0,3}((?:-[\t ]*){3,}|(?:_[ \t]*){3,}|(?:\*[ \t]*){3,})(?:\n+|$)/;
var heading = /^ {0,3}(#{1,6})(?=\s|$)(.*)(?:\n+|$)/;
var bullet = /(?:[*+-]|\d{1,9}[.)])/;
var lheadingCore = /^(?!bull |blockCode|fences|blockquote|heading|html|table)((?:.|\n(?!\s*?\n|bull |blockCode|fences|blockquote|heading|html|table))+?)\n {0,3}(=+|-+) *(?:\n+|$)/;
var lheading = edit(lheadingCore).replace(/bull/g, bullet).replace(/blockCode/g, /(?: {4}| {0,3}\t)/).replace(/fences/g, / {0,3}(?:`{3,}|~{3,})/).replace(/blockquote/g, / {0,3}>/).replace(/heading/g, / {0,3}#{1,6}/).replace(/html/g, / {0,3}<[^\n>]+>\n/).replace(/\|table/g, "").getRegex();
var lheadingGfm = edit(lheadingCore).replace(/bull/g, bullet).replace(/blockCode/g, /(?: {4}| {0,3}\t)/).replace(/fences/g, / {0,3}(?:`{3,}|~{3,})/).replace(/blockquote/g, / {0,3}>/).replace(/heading/g, / {0,3}#{1,6}/).replace(/html/g, / {0,3}<[^\n>]+>\n/).replace(/table/g, / {0,3}\|?(?:[:\- ]*\|)+[\:\- ]*\n/).getRegex();
var _paragraph = /^([^\n]+(?:\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\n)[^\n]+)*)/;
var blockText = /^[^\n]+/;
var _blockLabel = /(?!\s*\])(?:\\.|[^\[\]\\])+/;
var def = edit(/^ {0,3}\[(label)\]: *(?:\n[ \t]*)?([^<\s][^\s]*|<.*?>)(?:(?: +(?:\n[ \t]*)?| *\n[ \t]*)(title))? *(?:\n+|$)/).replace("label", _blockLabel).replace("title", /(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/).getRegex();
var list = edit(/^( {0,3}bull)([ \t][^\n]+?)?(?:\n|$)/).replace(/bull/g, bullet).getRegex();
var _tag = "address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option|p|param|search|section|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul";
var _comment = /<!--(?:-?>|[\s\S]*?(?:-->|$))/;
var html = edit("^ {0,3}(?:<(script|pre|style|textarea)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)|comment[^\\n]*(\\n+|$)|<\\?[\\s\\S]*?(?:\\?>\\n*|$)|<![A-Z][\\s\\S]*?(?:>\\n*|$)|<!\\[CDATA\\[[\\s\\S]*?(?:\\]\\]>\\n*|$)|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:(?:\\n[ 	]*)+\\n|$)|<(?!script|pre|style|textarea)([a-z][\\w-]*)(?:attribute)*? */?>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n[ 	]*)+\\n|$)|</(?!script|pre|style|textarea)[a-z][\\w-]*\\s*>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n[ 	]*)+\\n|$))", "i").replace("comment", _comment).replace("tag", _tag).replace("attribute", / +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/).getRegex();
var paragraph = edit(_paragraph).replace("hr", hr).replace("heading", " {0,3}#{1,6}(?:\\s|$)").replace("|lheading", "").replace("|table", "").replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", _tag).getRegex();
var blockquote = edit(/^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/).replace("paragraph", paragraph).getRegex();
var blockNormal = {
  blockquote,
  code: blockCode,
  def,
  fences,
  heading,
  hr,
  html,
  lheading,
  list,
  newline,
  paragraph,
  table: noopTest,
  text: blockText
};
var gfmTable = edit("^ *([^\\n ].*)\\n {0,3}((?:\\| *)?:?-+:? *(?:\\| *:?-+:? *)*(?:\\| *)?)(?:\\n((?:(?! *\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)").replace("hr", hr).replace("heading", " {0,3}#{1,6}(?:\\s|$)").replace("blockquote", " {0,3}>").replace("code", "(?: {4}| {0,3}	)[^\\n]").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", _tag).getRegex();
var blockGfm = __spreadProps(__spreadValues({}, blockNormal), {
  lheading: lheadingGfm,
  table: gfmTable,
  paragraph: edit(_paragraph).replace("hr", hr).replace("heading", " {0,3}#{1,6}(?:\\s|$)").replace("|lheading", "").replace("table", gfmTable).replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", _tag).getRegex()
});
var blockPedantic = __spreadProps(__spreadValues({}, blockNormal), {
  html: edit(`^ *(?:comment *(?:\\n|\\s*$)|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)|<tag(?:"[^"]*"|'[^']*'|\\s[^'"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))`).replace("comment", _comment).replace(/tag/g, "(?!(?:a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)\\b)\\w+(?!:|[^\\w\\s@]*@)\\b").getRegex(),
  def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/,
  heading: /^(#{1,6})(.*)(?:\n+|$)/,
  fences: noopTest,
  // fences not supported
  lheading: /^(.+?)\n {0,3}(=+|-+) *(?:\n+|$)/,
  paragraph: edit(_paragraph).replace("hr", hr).replace("heading", " *#{1,6} *[^\n]").replace("lheading", lheading).replace("|table", "").replace("blockquote", " {0,3}>").replace("|fences", "").replace("|list", "").replace("|html", "").replace("|tag", "").getRegex()
});
var escape$1 = /^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/;
var inlineCode = /^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/;
var br = /^( {2,}|\\)\n(?!\s*$)/;
var inlineText = /^(`+|[^`])(?:(?= {2,}\n)|[\s\S]*?(?:(?=[\\<!\[`*_]|\b_|$)|[^ ](?= {2,}\n)))/;
var _punctuation = /[\p{P}\p{S}]/u;
var _punctuationOrSpace = /[\s\p{P}\p{S}]/u;
var _notPunctuationOrSpace = /[^\s\p{P}\p{S}]/u;
var punctuation = edit(/^((?![*_])punctSpace)/, "u").replace(/punctSpace/g, _punctuationOrSpace).getRegex();
var _punctuationGfmStrongEm = /(?!~)[\p{P}\p{S}]/u;
var _punctuationOrSpaceGfmStrongEm = /(?!~)[\s\p{P}\p{S}]/u;
var _notPunctuationOrSpaceGfmStrongEm = /(?:[^\s\p{P}\p{S}]|~)/u;
var blockSkip = /\[[^[\]]*?\]\((?:\\.|[^\\\(\)]|\((?:\\.|[^\\\(\)])*\))*\)|`[^`]*?`|<[^<>]*?>/g;
var emStrongLDelimCore = /^(?:\*+(?:((?!\*)punct)|[^\s*]))|^_+(?:((?!_)punct)|([^\s_]))/;
var emStrongLDelim = edit(emStrongLDelimCore, "u").replace(/punct/g, _punctuation).getRegex();
var emStrongLDelimGfm = edit(emStrongLDelimCore, "u").replace(/punct/g, _punctuationGfmStrongEm).getRegex();
var emStrongRDelimAstCore = "^[^_*]*?__[^_*]*?\\*[^_*]*?(?=__)|[^*]+(?=[^*])|(?!\\*)punct(\\*+)(?=[\\s]|$)|notPunctSpace(\\*+)(?!\\*)(?=punctSpace|$)|(?!\\*)punctSpace(\\*+)(?=notPunctSpace)|[\\s](\\*+)(?!\\*)(?=punct)|(?!\\*)punct(\\*+)(?!\\*)(?=punct)|notPunctSpace(\\*+)(?=notPunctSpace)";
var emStrongRDelimAst = edit(emStrongRDelimAstCore, "gu").replace(/notPunctSpace/g, _notPunctuationOrSpace).replace(/punctSpace/g, _punctuationOrSpace).replace(/punct/g, _punctuation).getRegex();
var emStrongRDelimAstGfm = edit(emStrongRDelimAstCore, "gu").replace(/notPunctSpace/g, _notPunctuationOrSpaceGfmStrongEm).replace(/punctSpace/g, _punctuationOrSpaceGfmStrongEm).replace(/punct/g, _punctuationGfmStrongEm).getRegex();
var emStrongRDelimUnd = edit("^[^_*]*?\\*\\*[^_*]*?_[^_*]*?(?=\\*\\*)|[^_]+(?=[^_])|(?!_)punct(_+)(?=[\\s]|$)|notPunctSpace(_+)(?!_)(?=punctSpace|$)|(?!_)punctSpace(_+)(?=notPunctSpace)|[\\s](_+)(?!_)(?=punct)|(?!_)punct(_+)(?!_)(?=punct)", "gu").replace(/notPunctSpace/g, _notPunctuationOrSpace).replace(/punctSpace/g, _punctuationOrSpace).replace(/punct/g, _punctuation).getRegex();
var anyPunctuation = edit(/\\(punct)/, "gu").replace(/punct/g, _punctuation).getRegex();
var autolink = edit(/^<(scheme:[^\s\x00-\x1f<>]*|email)>/).replace("scheme", /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/).replace("email", /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/).getRegex();
var _inlineComment = edit(_comment).replace("(?:-->|$)", "-->").getRegex();
var tag = edit("^comment|^</[a-zA-Z][\\w:-]*\\s*>|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>|^<\\?[\\s\\S]*?\\?>|^<![a-zA-Z]+\\s[\\s\\S]*?>|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>").replace("comment", _inlineComment).replace("attribute", /\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/).getRegex();
var _inlineLabel = /(?:\[(?:\\.|[^\[\]\\])*\]|\\.|`[^`]*`|[^\[\]\\`])*?/;
var link = edit(/^!?\[(label)\]\(\s*(href)(?:\s+(title))?\s*\)/).replace("label", _inlineLabel).replace("href", /<(?:\\.|[^\n<>\\])+>|[^\s\x00-\x1f]*/).replace("title", /"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/).getRegex();
var reflink = edit(/^!?\[(label)\]\[(ref)\]/).replace("label", _inlineLabel).replace("ref", _blockLabel).getRegex();
var nolink = edit(/^!?\[(ref)\](?:\[\])?/).replace("ref", _blockLabel).getRegex();
var reflinkSearch = edit("reflink|nolink(?!\\()", "g").replace("reflink", reflink).replace("nolink", nolink).getRegex();
var inlineNormal = {
  _backpedal: noopTest,
  // only used for GFM url
  anyPunctuation,
  autolink,
  blockSkip,
  br,
  code: inlineCode,
  del: noopTest,
  emStrongLDelim,
  emStrongRDelimAst,
  emStrongRDelimUnd,
  escape: escape$1,
  link,
  nolink,
  punctuation,
  reflink,
  reflinkSearch,
  tag,
  text: inlineText,
  url: noopTest
};
var inlinePedantic = __spreadProps(__spreadValues({}, inlineNormal), {
  link: edit(/^!?\[(label)\]\((.*?)\)/).replace("label", _inlineLabel).getRegex(),
  reflink: edit(/^!?\[(label)\]\s*\[([^\]]*)\]/).replace("label", _inlineLabel).getRegex()
});
var inlineGfm = __spreadProps(__spreadValues({}, inlineNormal), {
  emStrongRDelimAst: emStrongRDelimAstGfm,
  emStrongLDelim: emStrongLDelimGfm,
  url: edit(/^((?:ftp|https?):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/, "i").replace("email", /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/).getRegex(),
  _backpedal: /(?:[^?!.,:;*_'"~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_'"~)]+(?!$))+/,
  del: /^(~~?)(?=[^\s~])((?:\\.|[^\\])*?(?:\\.|[^\s~\\]))\1(?=[^~]|$)/,
  text: /^([`~]+|[^`~])(?:(?= {2,}\n)|(?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)|[\s\S]*?(?:(?=[\\<!\[`*~_]|\b_|https?:\/\/|ftp:\/\/|www\.|$)|[^ ](?= {2,}\n)|[^a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-](?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)))/
});
var inlineBreaks = __spreadProps(__spreadValues({}, inlineGfm), {
  br: edit(br).replace("{2,}", "*").getRegex(),
  text: edit(inlineGfm.text).replace("\\b_", "\\b_| {2,}\\n").replace(/\{2,\}/g, "*").getRegex()
});
var block = {
  normal: blockNormal,
  gfm: blockGfm,
  pedantic: blockPedantic
};
var inline = {
  normal: inlineNormal,
  gfm: inlineGfm,
  breaks: inlineBreaks,
  pedantic: inlinePedantic
};
var escapeReplacements = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;"
};
var getEscapeReplacement = (ch) => escapeReplacements[ch];
function escape(html2, encode) {
  if (encode) {
    if (other.escapeTest.test(html2)) {
      return html2.replace(other.escapeReplace, getEscapeReplacement);
    }
  } else {
    if (other.escapeTestNoEncode.test(html2)) {
      return html2.replace(other.escapeReplaceNoEncode, getEscapeReplacement);
    }
  }
  return html2;
}
function cleanUrl(href) {
  try {
    href = encodeURI(href).replace(other.percentDecode, "%");
  } catch (e) {
    return null;
  }
  return href;
}
function splitCells(tableRow, count) {
  var _a;
  const row = tableRow.replace(other.findPipe, (match, offset, str) => {
    let escaped = false;
    let curr = offset;
    while (--curr >= 0 && str[curr] === "\\")
      escaped = !escaped;
    if (escaped) {
      return "|";
    } else {
      return " |";
    }
  }), cells = row.split(other.splitPipe);
  let i = 0;
  if (!cells[0].trim()) {
    cells.shift();
  }
  if (cells.length > 0 && !((_a = cells.at(-1)) == null ? void 0 : _a.trim())) {
    cells.pop();
  }
  if (count) {
    if (cells.length > count) {
      cells.splice(count);
    } else {
      while (cells.length < count)
        cells.push("");
    }
  }
  for (; i < cells.length; i++) {
    cells[i] = cells[i].trim().replace(other.slashPipe, "|");
  }
  return cells;
}
function rtrim(str, c, invert) {
  const l = str.length;
  if (l === 0) {
    return "";
  }
  let suffLen = 0;
  while (suffLen < l) {
    const currChar = str.charAt(l - suffLen - 1);
    if (currChar === c && true) {
      suffLen++;
    } else {
      break;
    }
  }
  return str.slice(0, l - suffLen);
}
function findClosingBracket(str, b) {
  if (str.indexOf(b[1]) === -1) {
    return -1;
  }
  let level = 0;
  for (let i = 0; i < str.length; i++) {
    if (str[i] === "\\") {
      i++;
    } else if (str[i] === b[0]) {
      level++;
    } else if (str[i] === b[1]) {
      level--;
      if (level < 0) {
        return i;
      }
    }
  }
  return -1;
}
function outputLink(cap, link2, raw, lexer2, rules) {
  const href = link2.href;
  const title = link2.title || null;
  const text = cap[1].replace(rules.other.outputLinkReplace, "$1");
  if (cap[0].charAt(0) !== "!") {
    lexer2.state.inLink = true;
    const token = {
      type: "link",
      raw,
      href,
      title,
      text,
      tokens: lexer2.inlineTokens(text)
    };
    lexer2.state.inLink = false;
    return token;
  }
  return {
    type: "image",
    raw,
    href,
    title,
    text
  };
}
function indentCodeCompensation(raw, text, rules) {
  const matchIndentToCode = raw.match(rules.other.indentCodeCompensation);
  if (matchIndentToCode === null) {
    return text;
  }
  const indentToCode = matchIndentToCode[1];
  return text.split("\n").map((node) => {
    const matchIndentInNode = node.match(rules.other.beginningSpace);
    if (matchIndentInNode === null) {
      return node;
    }
    const [indentInNode] = matchIndentInNode;
    if (indentInNode.length >= indentToCode.length) {
      return node.slice(indentToCode.length);
    }
    return node;
  }).join("\n");
}
var _Tokenizer = class {
  // set by the lexer
  constructor(options2) {
    __publicField(this, "options");
    __publicField(this, "rules");
    // set by the lexer
    __publicField(this, "lexer");
    this.options = options2 || _defaults;
  }
  space(src) {
    const cap = this.rules.block.newline.exec(src);
    if (cap && cap[0].length > 0) {
      return {
        type: "space",
        raw: cap[0]
      };
    }
  }
  code(src) {
    const cap = this.rules.block.code.exec(src);
    if (cap) {
      const text = cap[0].replace(this.rules.other.codeRemoveIndent, "");
      return {
        type: "code",
        raw: cap[0],
        codeBlockStyle: "indented",
        text: !this.options.pedantic ? rtrim(text, "\n") : text
      };
    }
  }
  fences(src) {
    const cap = this.rules.block.fences.exec(src);
    if (cap) {
      const raw = cap[0];
      const text = indentCodeCompensation(raw, cap[3] || "", this.rules);
      return {
        type: "code",
        raw,
        lang: cap[2] ? cap[2].trim().replace(this.rules.inline.anyPunctuation, "$1") : cap[2],
        text
      };
    }
  }
  heading(src) {
    const cap = this.rules.block.heading.exec(src);
    if (cap) {
      let text = cap[2].trim();
      if (this.rules.other.endingHash.test(text)) {
        const trimmed = rtrim(text, "#");
        if (this.options.pedantic) {
          text = trimmed.trim();
        } else if (!trimmed || this.rules.other.endingSpaceChar.test(trimmed)) {
          text = trimmed.trim();
        }
      }
      return {
        type: "heading",
        raw: cap[0],
        depth: cap[1].length,
        text,
        tokens: this.lexer.inline(text)
      };
    }
  }
  hr(src) {
    const cap = this.rules.block.hr.exec(src);
    if (cap) {
      return {
        type: "hr",
        raw: rtrim(cap[0], "\n")
      };
    }
  }
  blockquote(src) {
    const cap = this.rules.block.blockquote.exec(src);
    if (cap) {
      let lines = rtrim(cap[0], "\n").split("\n");
      let raw = "";
      let text = "";
      const tokens = [];
      while (lines.length > 0) {
        let inBlockquote = false;
        const currentLines = [];
        let i;
        for (i = 0; i < lines.length; i++) {
          if (this.rules.other.blockquoteStart.test(lines[i])) {
            currentLines.push(lines[i]);
            inBlockquote = true;
          } else if (!inBlockquote) {
            currentLines.push(lines[i]);
          } else {
            break;
          }
        }
        lines = lines.slice(i);
        const currentRaw = currentLines.join("\n");
        const currentText = currentRaw.replace(this.rules.other.blockquoteSetextReplace, "\n    $1").replace(this.rules.other.blockquoteSetextReplace2, "");
        raw = raw ? `${raw}
${currentRaw}` : currentRaw;
        text = text ? `${text}
${currentText}` : currentText;
        const top = this.lexer.state.top;
        this.lexer.state.top = true;
        this.lexer.blockTokens(currentText, tokens, true);
        this.lexer.state.top = top;
        if (lines.length === 0) {
          break;
        }
        const lastToken = tokens.at(-1);
        if ((lastToken == null ? void 0 : lastToken.type) === "code") {
          break;
        } else if ((lastToken == null ? void 0 : lastToken.type) === "blockquote") {
          const oldToken = lastToken;
          const newText = oldToken.raw + "\n" + lines.join("\n");
          const newToken = this.blockquote(newText);
          tokens[tokens.length - 1] = newToken;
          raw = raw.substring(0, raw.length - oldToken.raw.length) + newToken.raw;
          text = text.substring(0, text.length - oldToken.text.length) + newToken.text;
          break;
        } else if ((lastToken == null ? void 0 : lastToken.type) === "list") {
          const oldToken = lastToken;
          const newText = oldToken.raw + "\n" + lines.join("\n");
          const newToken = this.list(newText);
          tokens[tokens.length - 1] = newToken;
          raw = raw.substring(0, raw.length - lastToken.raw.length) + newToken.raw;
          text = text.substring(0, text.length - oldToken.raw.length) + newToken.raw;
          lines = newText.substring(tokens.at(-1).raw.length).split("\n");
          continue;
        }
      }
      return {
        type: "blockquote",
        raw,
        tokens,
        text
      };
    }
  }
  list(src) {
    let cap = this.rules.block.list.exec(src);
    if (cap) {
      let bull = cap[1].trim();
      const isordered = bull.length > 1;
      const list2 = {
        type: "list",
        raw: "",
        ordered: isordered,
        start: isordered ? +bull.slice(0, -1) : "",
        loose: false,
        items: []
      };
      bull = isordered ? `\\d{1,9}\\${bull.slice(-1)}` : `\\${bull}`;
      if (this.options.pedantic) {
        bull = isordered ? bull : "[*+-]";
      }
      const itemRegex = this.rules.other.listItemRegex(bull);
      let endsWithBlankLine = false;
      while (src) {
        let endEarly = false;
        let raw = "";
        let itemContents = "";
        if (!(cap = itemRegex.exec(src))) {
          break;
        }
        if (this.rules.block.hr.test(src)) {
          break;
        }
        raw = cap[0];
        src = src.substring(raw.length);
        let line = cap[2].split("\n", 1)[0].replace(this.rules.other.listReplaceTabs, (t) => " ".repeat(3 * t.length));
        let nextLine = src.split("\n", 1)[0];
        let blankLine = !line.trim();
        let indent = 0;
        if (this.options.pedantic) {
          indent = 2;
          itemContents = line.trimStart();
        } else if (blankLine) {
          indent = cap[1].length + 1;
        } else {
          indent = cap[2].search(this.rules.other.nonSpaceChar);
          indent = indent > 4 ? 1 : indent;
          itemContents = line.slice(indent);
          indent += cap[1].length;
        }
        if (blankLine && this.rules.other.blankLine.test(nextLine)) {
          raw += nextLine + "\n";
          src = src.substring(nextLine.length + 1);
          endEarly = true;
        }
        if (!endEarly) {
          const nextBulletRegex = this.rules.other.nextBulletRegex(indent);
          const hrRegex = this.rules.other.hrRegex(indent);
          const fencesBeginRegex = this.rules.other.fencesBeginRegex(indent);
          const headingBeginRegex = this.rules.other.headingBeginRegex(indent);
          const htmlBeginRegex = this.rules.other.htmlBeginRegex(indent);
          while (src) {
            const rawLine = src.split("\n", 1)[0];
            let nextLineWithoutTabs;
            nextLine = rawLine;
            if (this.options.pedantic) {
              nextLine = nextLine.replace(this.rules.other.listReplaceNesting, "  ");
              nextLineWithoutTabs = nextLine;
            } else {
              nextLineWithoutTabs = nextLine.replace(this.rules.other.tabCharGlobal, "    ");
            }
            if (fencesBeginRegex.test(nextLine)) {
              break;
            }
            if (headingBeginRegex.test(nextLine)) {
              break;
            }
            if (htmlBeginRegex.test(nextLine)) {
              break;
            }
            if (nextBulletRegex.test(nextLine)) {
              break;
            }
            if (hrRegex.test(nextLine)) {
              break;
            }
            if (nextLineWithoutTabs.search(this.rules.other.nonSpaceChar) >= indent || !nextLine.trim()) {
              itemContents += "\n" + nextLineWithoutTabs.slice(indent);
            } else {
              if (blankLine) {
                break;
              }
              if (line.replace(this.rules.other.tabCharGlobal, "    ").search(this.rules.other.nonSpaceChar) >= 4) {
                break;
              }
              if (fencesBeginRegex.test(line)) {
                break;
              }
              if (headingBeginRegex.test(line)) {
                break;
              }
              if (hrRegex.test(line)) {
                break;
              }
              itemContents += "\n" + nextLine;
            }
            if (!blankLine && !nextLine.trim()) {
              blankLine = true;
            }
            raw += rawLine + "\n";
            src = src.substring(rawLine.length + 1);
            line = nextLineWithoutTabs.slice(indent);
          }
        }
        if (!list2.loose) {
          if (endsWithBlankLine) {
            list2.loose = true;
          } else if (this.rules.other.doubleBlankLine.test(raw)) {
            endsWithBlankLine = true;
          }
        }
        let istask = null;
        let ischecked;
        if (this.options.gfm) {
          istask = this.rules.other.listIsTask.exec(itemContents);
          if (istask) {
            ischecked = istask[0] !== "[ ] ";
            itemContents = itemContents.replace(this.rules.other.listReplaceTask, "");
          }
        }
        list2.items.push({
          type: "list_item",
          raw,
          task: !!istask,
          checked: ischecked,
          loose: false,
          text: itemContents,
          tokens: []
        });
        list2.raw += raw;
      }
      const lastItem = list2.items.at(-1);
      if (lastItem) {
        lastItem.raw = lastItem.raw.trimEnd();
        lastItem.text = lastItem.text.trimEnd();
      } else {
        return;
      }
      list2.raw = list2.raw.trimEnd();
      for (let i = 0; i < list2.items.length; i++) {
        this.lexer.state.top = false;
        list2.items[i].tokens = this.lexer.blockTokens(list2.items[i].text, []);
        if (!list2.loose) {
          const spacers = list2.items[i].tokens.filter((t) => t.type === "space");
          const hasMultipleLineBreaks = spacers.length > 0 && spacers.some((t) => this.rules.other.anyLine.test(t.raw));
          list2.loose = hasMultipleLineBreaks;
        }
      }
      if (list2.loose) {
        for (let i = 0; i < list2.items.length; i++) {
          list2.items[i].loose = true;
        }
      }
      return list2;
    }
  }
  html(src) {
    const cap = this.rules.block.html.exec(src);
    if (cap) {
      const token = {
        type: "html",
        block: true,
        raw: cap[0],
        pre: cap[1] === "pre" || cap[1] === "script" || cap[1] === "style",
        text: cap[0]
      };
      return token;
    }
  }
  def(src) {
    const cap = this.rules.block.def.exec(src);
    if (cap) {
      const tag2 = cap[1].toLowerCase().replace(this.rules.other.multipleSpaceGlobal, " ");
      const href = cap[2] ? cap[2].replace(this.rules.other.hrefBrackets, "$1").replace(this.rules.inline.anyPunctuation, "$1") : "";
      const title = cap[3] ? cap[3].substring(1, cap[3].length - 1).replace(this.rules.inline.anyPunctuation, "$1") : cap[3];
      return {
        type: "def",
        tag: tag2,
        raw: cap[0],
        href,
        title
      };
    }
  }
  table(src) {
    var _a;
    const cap = this.rules.block.table.exec(src);
    if (!cap) {
      return;
    }
    if (!this.rules.other.tableDelimiter.test(cap[2])) {
      return;
    }
    const headers = splitCells(cap[1]);
    const aligns = cap[2].replace(this.rules.other.tableAlignChars, "").split("|");
    const rows = ((_a = cap[3]) == null ? void 0 : _a.trim()) ? cap[3].replace(this.rules.other.tableRowBlankLine, "").split("\n") : [];
    const item = {
      type: "table",
      raw: cap[0],
      header: [],
      align: [],
      rows: []
    };
    if (headers.length !== aligns.length) {
      return;
    }
    for (const align of aligns) {
      if (this.rules.other.tableAlignRight.test(align)) {
        item.align.push("right");
      } else if (this.rules.other.tableAlignCenter.test(align)) {
        item.align.push("center");
      } else if (this.rules.other.tableAlignLeft.test(align)) {
        item.align.push("left");
      } else {
        item.align.push(null);
      }
    }
    for (let i = 0; i < headers.length; i++) {
      item.header.push({
        text: headers[i],
        tokens: this.lexer.inline(headers[i]),
        header: true,
        align: item.align[i]
      });
    }
    for (const row of rows) {
      item.rows.push(splitCells(row, item.header.length).map((cell, i) => {
        return {
          text: cell,
          tokens: this.lexer.inline(cell),
          header: false,
          align: item.align[i]
        };
      }));
    }
    return item;
  }
  lheading(src) {
    const cap = this.rules.block.lheading.exec(src);
    if (cap) {
      return {
        type: "heading",
        raw: cap[0],
        depth: cap[2].charAt(0) === "=" ? 1 : 2,
        text: cap[1],
        tokens: this.lexer.inline(cap[1])
      };
    }
  }
  paragraph(src) {
    const cap = this.rules.block.paragraph.exec(src);
    if (cap) {
      const text = cap[1].charAt(cap[1].length - 1) === "\n" ? cap[1].slice(0, -1) : cap[1];
      return {
        type: "paragraph",
        raw: cap[0],
        text,
        tokens: this.lexer.inline(text)
      };
    }
  }
  text(src) {
    const cap = this.rules.block.text.exec(src);
    if (cap) {
      return {
        type: "text",
        raw: cap[0],
        text: cap[0],
        tokens: this.lexer.inline(cap[0])
      };
    }
  }
  escape(src) {
    const cap = this.rules.inline.escape.exec(src);
    if (cap) {
      return {
        type: "escape",
        raw: cap[0],
        text: cap[1]
      };
    }
  }
  tag(src) {
    const cap = this.rules.inline.tag.exec(src);
    if (cap) {
      if (!this.lexer.state.inLink && this.rules.other.startATag.test(cap[0])) {
        this.lexer.state.inLink = true;
      } else if (this.lexer.state.inLink && this.rules.other.endATag.test(cap[0])) {
        this.lexer.state.inLink = false;
      }
      if (!this.lexer.state.inRawBlock && this.rules.other.startPreScriptTag.test(cap[0])) {
        this.lexer.state.inRawBlock = true;
      } else if (this.lexer.state.inRawBlock && this.rules.other.endPreScriptTag.test(cap[0])) {
        this.lexer.state.inRawBlock = false;
      }
      return {
        type: "html",
        raw: cap[0],
        inLink: this.lexer.state.inLink,
        inRawBlock: this.lexer.state.inRawBlock,
        block: false,
        text: cap[0]
      };
    }
  }
  link(src) {
    const cap = this.rules.inline.link.exec(src);
    if (cap) {
      const trimmedUrl = cap[2].trim();
      if (!this.options.pedantic && this.rules.other.startAngleBracket.test(trimmedUrl)) {
        if (!this.rules.other.endAngleBracket.test(trimmedUrl)) {
          return;
        }
        const rtrimSlash = rtrim(trimmedUrl.slice(0, -1), "\\");
        if ((trimmedUrl.length - rtrimSlash.length) % 2 === 0) {
          return;
        }
      } else {
        const lastParenIndex = findClosingBracket(cap[2], "()");
        if (lastParenIndex > -1) {
          const start = cap[0].indexOf("!") === 0 ? 5 : 4;
          const linkLen = start + cap[1].length + lastParenIndex;
          cap[2] = cap[2].substring(0, lastParenIndex);
          cap[0] = cap[0].substring(0, linkLen).trim();
          cap[3] = "";
        }
      }
      let href = cap[2];
      let title = "";
      if (this.options.pedantic) {
        const link2 = this.rules.other.pedanticHrefTitle.exec(href);
        if (link2) {
          href = link2[1];
          title = link2[3];
        }
      } else {
        title = cap[3] ? cap[3].slice(1, -1) : "";
      }
      href = href.trim();
      if (this.rules.other.startAngleBracket.test(href)) {
        if (this.options.pedantic && !this.rules.other.endAngleBracket.test(trimmedUrl)) {
          href = href.slice(1);
        } else {
          href = href.slice(1, -1);
        }
      }
      return outputLink(cap, {
        href: href ? href.replace(this.rules.inline.anyPunctuation, "$1") : href,
        title: title ? title.replace(this.rules.inline.anyPunctuation, "$1") : title
      }, cap[0], this.lexer, this.rules);
    }
  }
  reflink(src, links) {
    let cap;
    if ((cap = this.rules.inline.reflink.exec(src)) || (cap = this.rules.inline.nolink.exec(src))) {
      const linkString = (cap[2] || cap[1]).replace(this.rules.other.multipleSpaceGlobal, " ");
      const link2 = links[linkString.toLowerCase()];
      if (!link2) {
        const text = cap[0].charAt(0);
        return {
          type: "text",
          raw: text,
          text
        };
      }
      return outputLink(cap, link2, cap[0], this.lexer, this.rules);
    }
  }
  emStrong(src, maskedSrc, prevChar = "") {
    let match = this.rules.inline.emStrongLDelim.exec(src);
    if (!match)
      return;
    if (match[3] && prevChar.match(this.rules.other.unicodeAlphaNumeric))
      return;
    const nextChar = match[1] || match[2] || "";
    if (!nextChar || !prevChar || this.rules.inline.punctuation.exec(prevChar)) {
      const lLength = [...match[0]].length - 1;
      let rDelim, rLength, delimTotal = lLength, midDelimTotal = 0;
      const endReg = match[0][0] === "*" ? this.rules.inline.emStrongRDelimAst : this.rules.inline.emStrongRDelimUnd;
      endReg.lastIndex = 0;
      maskedSrc = maskedSrc.slice(-1 * src.length + lLength);
      while ((match = endReg.exec(maskedSrc)) != null) {
        rDelim = match[1] || match[2] || match[3] || match[4] || match[5] || match[6];
        if (!rDelim)
          continue;
        rLength = [...rDelim].length;
        if (match[3] || match[4]) {
          delimTotal += rLength;
          continue;
        } else if (match[5] || match[6]) {
          if (lLength % 3 && !((lLength + rLength) % 3)) {
            midDelimTotal += rLength;
            continue;
          }
        }
        delimTotal -= rLength;
        if (delimTotal > 0)
          continue;
        rLength = Math.min(rLength, rLength + delimTotal + midDelimTotal);
        const lastCharLength = [...match[0]][0].length;
        const raw = src.slice(0, lLength + match.index + lastCharLength + rLength);
        if (Math.min(lLength, rLength) % 2) {
          const text2 = raw.slice(1, -1);
          return {
            type: "em",
            raw,
            text: text2,
            tokens: this.lexer.inlineTokens(text2)
          };
        }
        const text = raw.slice(2, -2);
        return {
          type: "strong",
          raw,
          text,
          tokens: this.lexer.inlineTokens(text)
        };
      }
    }
  }
  codespan(src) {
    const cap = this.rules.inline.code.exec(src);
    if (cap) {
      let text = cap[2].replace(this.rules.other.newLineCharGlobal, " ");
      const hasNonSpaceChars = this.rules.other.nonSpaceChar.test(text);
      const hasSpaceCharsOnBothEnds = this.rules.other.startingSpaceChar.test(text) && this.rules.other.endingSpaceChar.test(text);
      if (hasNonSpaceChars && hasSpaceCharsOnBothEnds) {
        text = text.substring(1, text.length - 1);
      }
      return {
        type: "codespan",
        raw: cap[0],
        text
      };
    }
  }
  br(src) {
    const cap = this.rules.inline.br.exec(src);
    if (cap) {
      return {
        type: "br",
        raw: cap[0]
      };
    }
  }
  del(src) {
    const cap = this.rules.inline.del.exec(src);
    if (cap) {
      return {
        type: "del",
        raw: cap[0],
        text: cap[2],
        tokens: this.lexer.inlineTokens(cap[2])
      };
    }
  }
  autolink(src) {
    const cap = this.rules.inline.autolink.exec(src);
    if (cap) {
      let text, href;
      if (cap[2] === "@") {
        text = cap[1];
        href = "mailto:" + text;
      } else {
        text = cap[1];
        href = text;
      }
      return {
        type: "link",
        raw: cap[0],
        text,
        href,
        tokens: [
          {
            type: "text",
            raw: text,
            text
          }
        ]
      };
    }
  }
  url(src) {
    var _a, _b;
    let cap;
    if (cap = this.rules.inline.url.exec(src)) {
      let text, href;
      if (cap[2] === "@") {
        text = cap[0];
        href = "mailto:" + text;
      } else {
        let prevCapZero;
        do {
          prevCapZero = cap[0];
          cap[0] = (_b = (_a = this.rules.inline._backpedal.exec(cap[0])) == null ? void 0 : _a[0]) != null ? _b : "";
        } while (prevCapZero !== cap[0]);
        text = cap[0];
        if (cap[1] === "www.") {
          href = "http://" + cap[0];
        } else {
          href = cap[0];
        }
      }
      return {
        type: "link",
        raw: cap[0],
        text,
        href,
        tokens: [
          {
            type: "text",
            raw: text,
            text
          }
        ]
      };
    }
  }
  inlineText(src) {
    const cap = this.rules.inline.text.exec(src);
    if (cap) {
      const escaped = this.lexer.state.inRawBlock;
      return {
        type: "text",
        raw: cap[0],
        text: cap[0],
        escaped
      };
    }
  }
};
var _Lexer = class __Lexer {
  constructor(options2) {
    __publicField(this, "tokens");
    __publicField(this, "options");
    __publicField(this, "state");
    __publicField(this, "tokenizer");
    __publicField(this, "inlineQueue");
    this.tokens = [];
    this.tokens.links = /* @__PURE__ */ Object.create(null);
    this.options = options2 || _defaults;
    this.options.tokenizer = this.options.tokenizer || new _Tokenizer();
    this.tokenizer = this.options.tokenizer;
    this.tokenizer.options = this.options;
    this.tokenizer.lexer = this;
    this.inlineQueue = [];
    this.state = {
      inLink: false,
      inRawBlock: false,
      top: true
    };
    const rules = {
      other,
      block: block.normal,
      inline: inline.normal
    };
    if (this.options.pedantic) {
      rules.block = block.pedantic;
      rules.inline = inline.pedantic;
    } else if (this.options.gfm) {
      rules.block = block.gfm;
      if (this.options.breaks) {
        rules.inline = inline.breaks;
      } else {
        rules.inline = inline.gfm;
      }
    }
    this.tokenizer.rules = rules;
  }
  /**
   * Expose Rules
   */
  static get rules() {
    return {
      block,
      inline
    };
  }
  /**
   * Static Lex Method
   */
  static lex(src, options2) {
    const lexer2 = new __Lexer(options2);
    return lexer2.lex(src);
  }
  /**
   * Static Lex Inline Method
   */
  static lexInline(src, options2) {
    const lexer2 = new __Lexer(options2);
    return lexer2.inlineTokens(src);
  }
  /**
   * Preprocessing
   */
  lex(src) {
    src = src.replace(other.carriageReturn, "\n");
    this.blockTokens(src, this.tokens);
    for (let i = 0; i < this.inlineQueue.length; i++) {
      const next = this.inlineQueue[i];
      this.inlineTokens(next.src, next.tokens);
    }
    this.inlineQueue = [];
    return this.tokens;
  }
  blockTokens(src, tokens = [], lastParagraphClipped = false) {
    var _a, _b, _c;
    if (this.options.pedantic) {
      src = src.replace(other.tabCharGlobal, "    ").replace(other.spaceLine, "");
    }
    while (src) {
      let token;
      if ((_b = (_a = this.options.extensions) == null ? void 0 : _a.block) == null ? void 0 : _b.some((extTokenizer) => {
        if (token = extTokenizer.call({ lexer: this }, src, tokens)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          return true;
        }
        return false;
      })) {
        continue;
      }
      if (token = this.tokenizer.space(src)) {
        src = src.substring(token.raw.length);
        const lastToken = tokens.at(-1);
        if (token.raw.length === 1 && lastToken !== void 0) {
          lastToken.raw += "\n";
        } else {
          tokens.push(token);
        }
        continue;
      }
      if (token = this.tokenizer.code(src)) {
        src = src.substring(token.raw.length);
        const lastToken = tokens.at(-1);
        if ((lastToken == null ? void 0 : lastToken.type) === "paragraph" || (lastToken == null ? void 0 : lastToken.type) === "text") {
          lastToken.raw += "\n" + token.raw;
          lastToken.text += "\n" + token.text;
          this.inlineQueue.at(-1).src = lastToken.text;
        } else {
          tokens.push(token);
        }
        continue;
      }
      if (token = this.tokenizer.fences(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.heading(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.hr(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.blockquote(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.list(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.html(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.def(src)) {
        src = src.substring(token.raw.length);
        const lastToken = tokens.at(-1);
        if ((lastToken == null ? void 0 : lastToken.type) === "paragraph" || (lastToken == null ? void 0 : lastToken.type) === "text") {
          lastToken.raw += "\n" + token.raw;
          lastToken.text += "\n" + token.raw;
          this.inlineQueue.at(-1).src = lastToken.text;
        } else if (!this.tokens.links[token.tag]) {
          this.tokens.links[token.tag] = {
            href: token.href,
            title: token.title
          };
        }
        continue;
      }
      if (token = this.tokenizer.table(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.lheading(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      let cutSrc = src;
      if ((_c = this.options.extensions) == null ? void 0 : _c.startBlock) {
        let startIndex = Infinity;
        const tempSrc = src.slice(1);
        let tempStart;
        this.options.extensions.startBlock.forEach((getStartIndex) => {
          tempStart = getStartIndex.call({ lexer: this }, tempSrc);
          if (typeof tempStart === "number" && tempStart >= 0) {
            startIndex = Math.min(startIndex, tempStart);
          }
        });
        if (startIndex < Infinity && startIndex >= 0) {
          cutSrc = src.substring(0, startIndex + 1);
        }
      }
      if (this.state.top && (token = this.tokenizer.paragraph(cutSrc))) {
        const lastToken = tokens.at(-1);
        if (lastParagraphClipped && (lastToken == null ? void 0 : lastToken.type) === "paragraph") {
          lastToken.raw += "\n" + token.raw;
          lastToken.text += "\n" + token.text;
          this.inlineQueue.pop();
          this.inlineQueue.at(-1).src = lastToken.text;
        } else {
          tokens.push(token);
        }
        lastParagraphClipped = cutSrc.length !== src.length;
        src = src.substring(token.raw.length);
        continue;
      }
      if (token = this.tokenizer.text(src)) {
        src = src.substring(token.raw.length);
        const lastToken = tokens.at(-1);
        if ((lastToken == null ? void 0 : lastToken.type) === "text") {
          lastToken.raw += "\n" + token.raw;
          lastToken.text += "\n" + token.text;
          this.inlineQueue.pop();
          this.inlineQueue.at(-1).src = lastToken.text;
        } else {
          tokens.push(token);
        }
        continue;
      }
      if (src) {
        const errMsg = "Infinite loop on byte: " + src.charCodeAt(0);
        if (this.options.silent) {
          console.error(errMsg);
          break;
        } else {
          throw new Error(errMsg);
        }
      }
    }
    this.state.top = true;
    return tokens;
  }
  inline(src, tokens = []) {
    this.inlineQueue.push({ src, tokens });
    return tokens;
  }
  /**
   * Lexing/Compiling
   */
  inlineTokens(src, tokens = []) {
    var _a, _b, _c;
    let maskedSrc = src;
    let match = null;
    if (this.tokens.links) {
      const links = Object.keys(this.tokens.links);
      if (links.length > 0) {
        while ((match = this.tokenizer.rules.inline.reflinkSearch.exec(maskedSrc)) != null) {
          if (links.includes(match[0].slice(match[0].lastIndexOf("[") + 1, -1))) {
            maskedSrc = maskedSrc.slice(0, match.index) + "[" + "a".repeat(match[0].length - 2) + "]" + maskedSrc.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex);
          }
        }
      }
    }
    while ((match = this.tokenizer.rules.inline.blockSkip.exec(maskedSrc)) != null) {
      maskedSrc = maskedSrc.slice(0, match.index) + "[" + "a".repeat(match[0].length - 2) + "]" + maskedSrc.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);
    }
    while ((match = this.tokenizer.rules.inline.anyPunctuation.exec(maskedSrc)) != null) {
      maskedSrc = maskedSrc.slice(0, match.index) + "++" + maskedSrc.slice(this.tokenizer.rules.inline.anyPunctuation.lastIndex);
    }
    let keepPrevChar = false;
    let prevChar = "";
    while (src) {
      if (!keepPrevChar) {
        prevChar = "";
      }
      keepPrevChar = false;
      let token;
      if ((_b = (_a = this.options.extensions) == null ? void 0 : _a.inline) == null ? void 0 : _b.some((extTokenizer) => {
        if (token = extTokenizer.call({ lexer: this }, src, tokens)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          return true;
        }
        return false;
      })) {
        continue;
      }
      if (token = this.tokenizer.escape(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.tag(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.link(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.reflink(src, this.tokens.links)) {
        src = src.substring(token.raw.length);
        const lastToken = tokens.at(-1);
        if (token.type === "text" && (lastToken == null ? void 0 : lastToken.type) === "text") {
          lastToken.raw += token.raw;
          lastToken.text += token.text;
        } else {
          tokens.push(token);
        }
        continue;
      }
      if (token = this.tokenizer.emStrong(src, maskedSrc, prevChar)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.codespan(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.br(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.del(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.autolink(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (!this.state.inLink && (token = this.tokenizer.url(src))) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      let cutSrc = src;
      if ((_c = this.options.extensions) == null ? void 0 : _c.startInline) {
        let startIndex = Infinity;
        const tempSrc = src.slice(1);
        let tempStart;
        this.options.extensions.startInline.forEach((getStartIndex) => {
          tempStart = getStartIndex.call({ lexer: this }, tempSrc);
          if (typeof tempStart === "number" && tempStart >= 0) {
            startIndex = Math.min(startIndex, tempStart);
          }
        });
        if (startIndex < Infinity && startIndex >= 0) {
          cutSrc = src.substring(0, startIndex + 1);
        }
      }
      if (token = this.tokenizer.inlineText(cutSrc)) {
        src = src.substring(token.raw.length);
        if (token.raw.slice(-1) !== "_") {
          prevChar = token.raw.slice(-1);
        }
        keepPrevChar = true;
        const lastToken = tokens.at(-1);
        if ((lastToken == null ? void 0 : lastToken.type) === "text") {
          lastToken.raw += token.raw;
          lastToken.text += token.text;
        } else {
          tokens.push(token);
        }
        continue;
      }
      if (src) {
        const errMsg = "Infinite loop on byte: " + src.charCodeAt(0);
        if (this.options.silent) {
          console.error(errMsg);
          break;
        } else {
          throw new Error(errMsg);
        }
      }
    }
    return tokens;
  }
};
var _Renderer = class {
  // set by the parser
  constructor(options2) {
    __publicField(this, "options");
    __publicField(this, "parser");
    this.options = options2 || _defaults;
  }
  space(token) {
    return "";
  }
  code({ text, lang, escaped }) {
    var _a;
    const langString = (_a = (lang || "").match(other.notSpaceStart)) == null ? void 0 : _a[0];
    const code = text.replace(other.endingNewline, "") + "\n";
    if (!langString) {
      return "<pre><code>" + (escaped ? code : escape(code, true)) + "</code></pre>\n";
    }
    return '<pre><code class="language-' + escape(langString) + '">' + (escaped ? code : escape(code, true)) + "</code></pre>\n";
  }
  blockquote({ tokens }) {
    const body = this.parser.parse(tokens);
    return `<blockquote>
${body}</blockquote>
`;
  }
  html({ text }) {
    return text;
  }
  heading({ tokens, depth }) {
    return `<h${depth}>${this.parser.parseInline(tokens)}</h${depth}>
`;
  }
  hr(token) {
    return "<hr>\n";
  }
  list(token) {
    const ordered = token.ordered;
    const start = token.start;
    let body = "";
    for (let j = 0; j < token.items.length; j++) {
      const item = token.items[j];
      body += this.listitem(item);
    }
    const type = ordered ? "ol" : "ul";
    const startAttr = ordered && start !== 1 ? ' start="' + start + '"' : "";
    return "<" + type + startAttr + ">\n" + body + "</" + type + ">\n";
  }
  listitem(item) {
    var _a;
    let itemBody = "";
    if (item.task) {
      const checkbox = this.checkbox({ checked: !!item.checked });
      if (item.loose) {
        if (((_a = item.tokens[0]) == null ? void 0 : _a.type) === "paragraph") {
          item.tokens[0].text = checkbox + " " + item.tokens[0].text;
          if (item.tokens[0].tokens && item.tokens[0].tokens.length > 0 && item.tokens[0].tokens[0].type === "text") {
            item.tokens[0].tokens[0].text = checkbox + " " + escape(item.tokens[0].tokens[0].text);
            item.tokens[0].tokens[0].escaped = true;
          }
        } else {
          item.tokens.unshift({
            type: "text",
            raw: checkbox + " ",
            text: checkbox + " ",
            escaped: true
          });
        }
      } else {
        itemBody += checkbox + " ";
      }
    }
    itemBody += this.parser.parse(item.tokens, !!item.loose);
    return `<li>${itemBody}</li>
`;
  }
  checkbox({ checked }) {
    return "<input " + (checked ? 'checked="" ' : "") + 'disabled="" type="checkbox">';
  }
  paragraph({ tokens }) {
    return `<p>${this.parser.parseInline(tokens)}</p>
`;
  }
  table(token) {
    let header = "";
    let cell = "";
    for (let j = 0; j < token.header.length; j++) {
      cell += this.tablecell(token.header[j]);
    }
    header += this.tablerow({ text: cell });
    let body = "";
    for (let j = 0; j < token.rows.length; j++) {
      const row = token.rows[j];
      cell = "";
      for (let k = 0; k < row.length; k++) {
        cell += this.tablecell(row[k]);
      }
      body += this.tablerow({ text: cell });
    }
    if (body)
      body = `<tbody>${body}</tbody>`;
    return "<table>\n<thead>\n" + header + "</thead>\n" + body + "</table>\n";
  }
  tablerow({ text }) {
    return `<tr>
${text}</tr>
`;
  }
  tablecell(token) {
    const content = this.parser.parseInline(token.tokens);
    const type = token.header ? "th" : "td";
    const tag2 = token.align ? `<${type} align="${token.align}">` : `<${type}>`;
    return tag2 + content + `</${type}>
`;
  }
  /**
   * span level renderer
   */
  strong({ tokens }) {
    return `<strong>${this.parser.parseInline(tokens)}</strong>`;
  }
  em({ tokens }) {
    return `<em>${this.parser.parseInline(tokens)}</em>`;
  }
  codespan({ text }) {
    return `<code>${escape(text, true)}</code>`;
  }
  br(token) {
    return "<br>";
  }
  del({ tokens }) {
    return `<del>${this.parser.parseInline(tokens)}</del>`;
  }
  link({ href, title, tokens }) {
    const text = this.parser.parseInline(tokens);
    const cleanHref = cleanUrl(href);
    if (cleanHref === null) {
      return text;
    }
    href = cleanHref;
    let out = '<a href="' + href + '"';
    if (title) {
      out += ' title="' + escape(title) + '"';
    }
    out += ">" + text + "</a>";
    return out;
  }
  image({ href, title, text }) {
    const cleanHref = cleanUrl(href);
    if (cleanHref === null) {
      return escape(text);
    }
    href = cleanHref;
    let out = `<img src="${href}" alt="${text}"`;
    if (title) {
      out += ` title="${escape(title)}"`;
    }
    out += ">";
    return out;
  }
  text(token) {
    return "tokens" in token && token.tokens ? this.parser.parseInline(token.tokens) : "escaped" in token && token.escaped ? token.text : escape(token.text);
  }
};
var _TextRenderer = class {
  // no need for block level renderers
  strong({ text }) {
    return text;
  }
  em({ text }) {
    return text;
  }
  codespan({ text }) {
    return text;
  }
  del({ text }) {
    return text;
  }
  html({ text }) {
    return text;
  }
  text({ text }) {
    return text;
  }
  link({ text }) {
    return "" + text;
  }
  image({ text }) {
    return "" + text;
  }
  br() {
    return "";
  }
};
var _Parser = class __Parser {
  constructor(options2) {
    __publicField(this, "options");
    __publicField(this, "renderer");
    __publicField(this, "textRenderer");
    this.options = options2 || _defaults;
    this.options.renderer = this.options.renderer || new _Renderer();
    this.renderer = this.options.renderer;
    this.renderer.options = this.options;
    this.renderer.parser = this;
    this.textRenderer = new _TextRenderer();
  }
  /**
   * Static Parse Method
   */
  static parse(tokens, options2) {
    const parser2 = new __Parser(options2);
    return parser2.parse(tokens);
  }
  /**
   * Static Parse Inline Method
   */
  static parseInline(tokens, options2) {
    const parser2 = new __Parser(options2);
    return parser2.parseInline(tokens);
  }
  /**
   * Parse Loop
   */
  parse(tokens, top = true) {
    var _a, _b;
    let out = "";
    for (let i = 0; i < tokens.length; i++) {
      const anyToken = tokens[i];
      if ((_b = (_a = this.options.extensions) == null ? void 0 : _a.renderers) == null ? void 0 : _b[anyToken.type]) {
        const genericToken = anyToken;
        const ret = this.options.extensions.renderers[genericToken.type].call({ parser: this }, genericToken);
        if (ret !== false || !["space", "hr", "heading", "code", "table", "blockquote", "list", "html", "paragraph", "text"].includes(genericToken.type)) {
          out += ret || "";
          continue;
        }
      }
      const token = anyToken;
      switch (token.type) {
        case "space": {
          out += this.renderer.space(token);
          continue;
        }
        case "hr": {
          out += this.renderer.hr(token);
          continue;
        }
        case "heading": {
          out += this.renderer.heading(token);
          continue;
        }
        case "code": {
          out += this.renderer.code(token);
          continue;
        }
        case "table": {
          out += this.renderer.table(token);
          continue;
        }
        case "blockquote": {
          out += this.renderer.blockquote(token);
          continue;
        }
        case "list": {
          out += this.renderer.list(token);
          continue;
        }
        case "html": {
          out += this.renderer.html(token);
          continue;
        }
        case "paragraph": {
          out += this.renderer.paragraph(token);
          continue;
        }
        case "text": {
          let textToken = token;
          let body = this.renderer.text(textToken);
          while (i + 1 < tokens.length && tokens[i + 1].type === "text") {
            textToken = tokens[++i];
            body += "\n" + this.renderer.text(textToken);
          }
          if (top) {
            out += this.renderer.paragraph({
              type: "paragraph",
              raw: body,
              text: body,
              tokens: [{ type: "text", raw: body, text: body, escaped: true }]
            });
          } else {
            out += body;
          }
          continue;
        }
        default: {
          const errMsg = 'Token with "' + token.type + '" type was not found.';
          if (this.options.silent) {
            console.error(errMsg);
            return "";
          } else {
            throw new Error(errMsg);
          }
        }
      }
    }
    return out;
  }
  /**
   * Parse Inline Tokens
   */
  parseInline(tokens, renderer = this.renderer) {
    var _a, _b;
    let out = "";
    for (let i = 0; i < tokens.length; i++) {
      const anyToken = tokens[i];
      if ((_b = (_a = this.options.extensions) == null ? void 0 : _a.renderers) == null ? void 0 : _b[anyToken.type]) {
        const ret = this.options.extensions.renderers[anyToken.type].call({ parser: this }, anyToken);
        if (ret !== false || !["escape", "html", "link", "image", "strong", "em", "codespan", "br", "del", "text"].includes(anyToken.type)) {
          out += ret || "";
          continue;
        }
      }
      const token = anyToken;
      switch (token.type) {
        case "escape": {
          out += renderer.text(token);
          break;
        }
        case "html": {
          out += renderer.html(token);
          break;
        }
        case "link": {
          out += renderer.link(token);
          break;
        }
        case "image": {
          out += renderer.image(token);
          break;
        }
        case "strong": {
          out += renderer.strong(token);
          break;
        }
        case "em": {
          out += renderer.em(token);
          break;
        }
        case "codespan": {
          out += renderer.codespan(token);
          break;
        }
        case "br": {
          out += renderer.br(token);
          break;
        }
        case "del": {
          out += renderer.del(token);
          break;
        }
        case "text": {
          out += renderer.text(token);
          break;
        }
        default: {
          const errMsg = 'Token with "' + token.type + '" type was not found.';
          if (this.options.silent) {
            console.error(errMsg);
            return "";
          } else {
            throw new Error(errMsg);
          }
        }
      }
    }
    return out;
  }
};
var _Hooks = class {
  constructor(options2) {
    __publicField(this, "options");
    __publicField(this, "block");
    this.options = options2 || _defaults;
  }
  /**
   * Process markdown before marked
   */
  preprocess(markdown) {
    return markdown;
  }
  /**
   * Process HTML after marked is finished
   */
  postprocess(html2) {
    return html2;
  }
  /**
   * Process all tokens before walk tokens
   */
  processAllTokens(tokens) {
    return tokens;
  }
  /**
   * Provide function to tokenize markdown
   */
  provideLexer() {
    return this.block ? _Lexer.lex : _Lexer.lexInline;
  }
  /**
   * Provide function to parse tokens
   */
  provideParser() {
    return this.block ? _Parser.parse : _Parser.parseInline;
  }
};
__publicField(_Hooks, "passThroughHooks", /* @__PURE__ */ new Set([
  "preprocess",
  "postprocess",
  "processAllTokens"
]));
var Marked = class {
  constructor(...args) {
    __publicField(this, "defaults", _getDefaults());
    __publicField(this, "options", this.setOptions);
    __publicField(this, "parse", this.parseMarkdown(true));
    __publicField(this, "parseInline", this.parseMarkdown(false));
    __publicField(this, "Parser", _Parser);
    __publicField(this, "Renderer", _Renderer);
    __publicField(this, "TextRenderer", _TextRenderer);
    __publicField(this, "Lexer", _Lexer);
    __publicField(this, "Tokenizer", _Tokenizer);
    __publicField(this, "Hooks", _Hooks);
    this.use(...args);
  }
  /**
   * Run callback for every token
   */
  walkTokens(tokens, callback) {
    var _a, _b;
    let values = [];
    for (const token of tokens) {
      values = values.concat(callback.call(this, token));
      switch (token.type) {
        case "table": {
          const tableToken = token;
          for (const cell of tableToken.header) {
            values = values.concat(this.walkTokens(cell.tokens, callback));
          }
          for (const row of tableToken.rows) {
            for (const cell of row) {
              values = values.concat(this.walkTokens(cell.tokens, callback));
            }
          }
          break;
        }
        case "list": {
          const listToken = token;
          values = values.concat(this.walkTokens(listToken.items, callback));
          break;
        }
        default: {
          const genericToken = token;
          if ((_b = (_a = this.defaults.extensions) == null ? void 0 : _a.childTokens) == null ? void 0 : _b[genericToken.type]) {
            this.defaults.extensions.childTokens[genericToken.type].forEach((childTokens) => {
              const tokens2 = genericToken[childTokens].flat(Infinity);
              values = values.concat(this.walkTokens(tokens2, callback));
            });
          } else if (genericToken.tokens) {
            values = values.concat(this.walkTokens(genericToken.tokens, callback));
          }
        }
      }
    }
    return values;
  }
  use(...args) {
    const extensions = this.defaults.extensions || { renderers: {}, childTokens: {} };
    args.forEach((pack) => {
      const opts = __spreadValues({}, pack);
      opts.async = this.defaults.async || opts.async || false;
      if (pack.extensions) {
        pack.extensions.forEach((ext) => {
          if (!ext.name) {
            throw new Error("extension name required");
          }
          if ("renderer" in ext) {
            const prevRenderer = extensions.renderers[ext.name];
            if (prevRenderer) {
              extensions.renderers[ext.name] = function(...args2) {
                let ret = ext.renderer.apply(this, args2);
                if (ret === false) {
                  ret = prevRenderer.apply(this, args2);
                }
                return ret;
              };
            } else {
              extensions.renderers[ext.name] = ext.renderer;
            }
          }
          if ("tokenizer" in ext) {
            if (!ext.level || ext.level !== "block" && ext.level !== "inline") {
              throw new Error("extension level must be 'block' or 'inline'");
            }
            const extLevel = extensions[ext.level];
            if (extLevel) {
              extLevel.unshift(ext.tokenizer);
            } else {
              extensions[ext.level] = [ext.tokenizer];
            }
            if (ext.start) {
              if (ext.level === "block") {
                if (extensions.startBlock) {
                  extensions.startBlock.push(ext.start);
                } else {
                  extensions.startBlock = [ext.start];
                }
              } else if (ext.level === "inline") {
                if (extensions.startInline) {
                  extensions.startInline.push(ext.start);
                } else {
                  extensions.startInline = [ext.start];
                }
              }
            }
          }
          if ("childTokens" in ext && ext.childTokens) {
            extensions.childTokens[ext.name] = ext.childTokens;
          }
        });
        opts.extensions = extensions;
      }
      if (pack.renderer) {
        const renderer = this.defaults.renderer || new _Renderer(this.defaults);
        for (const prop in pack.renderer) {
          if (!(prop in renderer)) {
            throw new Error(`renderer '${prop}' does not exist`);
          }
          if (["options", "parser"].includes(prop)) {
            continue;
          }
          const rendererProp = prop;
          const rendererFunc = pack.renderer[rendererProp];
          const prevRenderer = renderer[rendererProp];
          renderer[rendererProp] = (...args2) => {
            let ret = rendererFunc.apply(renderer, args2);
            if (ret === false) {
              ret = prevRenderer.apply(renderer, args2);
            }
            return ret || "";
          };
        }
        opts.renderer = renderer;
      }
      if (pack.tokenizer) {
        const tokenizer = this.defaults.tokenizer || new _Tokenizer(this.defaults);
        for (const prop in pack.tokenizer) {
          if (!(prop in tokenizer)) {
            throw new Error(`tokenizer '${prop}' does not exist`);
          }
          if (["options", "rules", "lexer"].includes(prop)) {
            continue;
          }
          const tokenizerProp = prop;
          const tokenizerFunc = pack.tokenizer[tokenizerProp];
          const prevTokenizer = tokenizer[tokenizerProp];
          tokenizer[tokenizerProp] = (...args2) => {
            let ret = tokenizerFunc.apply(tokenizer, args2);
            if (ret === false) {
              ret = prevTokenizer.apply(tokenizer, args2);
            }
            return ret;
          };
        }
        opts.tokenizer = tokenizer;
      }
      if (pack.hooks) {
        const hooks = this.defaults.hooks || new _Hooks();
        for (const prop in pack.hooks) {
          if (!(prop in hooks)) {
            throw new Error(`hook '${prop}' does not exist`);
          }
          if (["options", "block"].includes(prop)) {
            continue;
          }
          const hooksProp = prop;
          const hooksFunc = pack.hooks[hooksProp];
          const prevHook = hooks[hooksProp];
          if (_Hooks.passThroughHooks.has(prop)) {
            hooks[hooksProp] = (arg) => {
              if (this.defaults.async) {
                return Promise.resolve(hooksFunc.call(hooks, arg)).then((ret2) => {
                  return prevHook.call(hooks, ret2);
                });
              }
              const ret = hooksFunc.call(hooks, arg);
              return prevHook.call(hooks, ret);
            };
          } else {
            hooks[hooksProp] = (...args2) => {
              let ret = hooksFunc.apply(hooks, args2);
              if (ret === false) {
                ret = prevHook.apply(hooks, args2);
              }
              return ret;
            };
          }
        }
        opts.hooks = hooks;
      }
      if (pack.walkTokens) {
        const walkTokens2 = this.defaults.walkTokens;
        const packWalktokens = pack.walkTokens;
        opts.walkTokens = function(token) {
          let values = [];
          values.push(packWalktokens.call(this, token));
          if (walkTokens2) {
            values = values.concat(walkTokens2.call(this, token));
          }
          return values;
        };
      }
      this.defaults = __spreadValues(__spreadValues({}, this.defaults), opts);
    });
    return this;
  }
  setOptions(opt) {
    this.defaults = __spreadValues(__spreadValues({}, this.defaults), opt);
    return this;
  }
  lexer(src, options2) {
    return _Lexer.lex(src, options2 != null ? options2 : this.defaults);
  }
  parser(tokens, options2) {
    return _Parser.parse(tokens, options2 != null ? options2 : this.defaults);
  }
  parseMarkdown(blockType) {
    const parse = (src, options2) => {
      const origOpt = __spreadValues({}, options2);
      const opt = __spreadValues(__spreadValues({}, this.defaults), origOpt);
      const throwError = this.onError(!!opt.silent, !!opt.async);
      if (this.defaults.async === true && origOpt.async === false) {
        return throwError(new Error("marked(): The async option was set to true by an extension. Remove async: false from the parse options object to return a Promise."));
      }
      if (typeof src === "undefined" || src === null) {
        return throwError(new Error("marked(): input parameter is undefined or null"));
      }
      if (typeof src !== "string") {
        return throwError(new Error("marked(): input parameter is of type " + Object.prototype.toString.call(src) + ", string expected"));
      }
      if (opt.hooks) {
        opt.hooks.options = opt;
        opt.hooks.block = blockType;
      }
      const lexer2 = opt.hooks ? opt.hooks.provideLexer() : blockType ? _Lexer.lex : _Lexer.lexInline;
      const parser2 = opt.hooks ? opt.hooks.provideParser() : blockType ? _Parser.parse : _Parser.parseInline;
      if (opt.async) {
        return Promise.resolve(opt.hooks ? opt.hooks.preprocess(src) : src).then((src2) => lexer2(src2, opt)).then((tokens) => opt.hooks ? opt.hooks.processAllTokens(tokens) : tokens).then((tokens) => opt.walkTokens ? Promise.all(this.walkTokens(tokens, opt.walkTokens)).then(() => tokens) : tokens).then((tokens) => parser2(tokens, opt)).then((html2) => opt.hooks ? opt.hooks.postprocess(html2) : html2).catch(throwError);
      }
      try {
        if (opt.hooks) {
          src = opt.hooks.preprocess(src);
        }
        let tokens = lexer2(src, opt);
        if (opt.hooks) {
          tokens = opt.hooks.processAllTokens(tokens);
        }
        if (opt.walkTokens) {
          this.walkTokens(tokens, opt.walkTokens);
        }
        let html2 = parser2(tokens, opt);
        if (opt.hooks) {
          html2 = opt.hooks.postprocess(html2);
        }
        return html2;
      } catch (e) {
        return throwError(e);
      }
    };
    return parse;
  }
  onError(silent, async) {
    return (e) => {
      e.message += "\nPlease report this to https://github.com/markedjs/marked.";
      if (silent) {
        const msg = "<p>An error occurred:</p><pre>" + escape(e.message + "", true) + "</pre>";
        if (async) {
          return Promise.resolve(msg);
        }
        return msg;
      }
      if (async) {
        return Promise.reject(e);
      }
      throw e;
    };
  }
};
var markedInstance = new Marked();
function marked(src, opt) {
  return markedInstance.parse(src, opt);
}
marked.options = marked.setOptions = function(options2) {
  markedInstance.setOptions(options2);
  marked.defaults = markedInstance.defaults;
  changeDefaults(marked.defaults);
  return marked;
};
marked.getDefaults = _getDefaults;
marked.defaults = _defaults;
marked.use = function(...args) {
  markedInstance.use(...args);
  marked.defaults = markedInstance.defaults;
  changeDefaults(marked.defaults);
  return marked;
};
marked.walkTokens = function(tokens, callback) {
  return markedInstance.walkTokens(tokens, callback);
};
marked.parseInline = markedInstance.parseInline;
marked.Parser = _Parser;
marked.parser = _Parser.parse;
marked.Renderer = _Renderer;
marked.TextRenderer = _TextRenderer;
marked.Lexer = _Lexer;
marked.lexer = _Lexer.lex;
marked.Tokenizer = _Tokenizer;
marked.Hooks = _Hooks;
marked.parse = marked;
var options = marked.options;
var setOptions = marked.setOptions;
var use = marked.use;
var walkTokens = marked.walkTokens;
var parseInline = marked.parseInline;
var parser = _Parser.parse;
var lexer = _Lexer.lex;

// src/MarkdownRenderer.ts
var import_obsidian = require("obsidian");
var MarkdownRenderer = class _MarkdownRenderer extends import_obsidian.Component {
  constructor(container, content, app) {
    super();
    this.container = container;
    this.content = content;
    this.app = app;
  }
  static renderMarkdown(content, container, sourcePath, component) {
    return __async(this, null, function* () {
      const renderer = new _MarkdownRenderer(container, content, component.app);
      yield renderer.render();
    });
  }
  render() {
    return __async(this, null, function* () {
      try {
        this.container.empty();
        this.container.addClass("markdown-rendered");
        const rendered = yield marked.parse(this.content, { async: true });
        this.container.innerHTML = rendered;
      } catch (error) {
        console.error("Error rendering markdown:", error);
        this.container.setText("Error rendering content: " + error.message);
      }
    });
  }
  /**
   * Get content from the current editor
   */
  static getCurrentFileContent(app) {
    try {
      const activeLeaf = app.workspace.activeLeaf;
      if (!activeLeaf) return null;
      const view = activeLeaf.view;
      if (!view || !("editor" in view)) return null;
      return view.editor.getValue();
    } catch (error) {
      console.error("Error getting file content:", error);
      return null;
    }
  }
};

// src/ChatView.ts
var VIEW_TYPE_CHAT = "chat-view";
var ConfirmModal = class extends import_obsidian2.Modal {
  constructor(app, message, onConfirm) {
    super(app);
    this.message = message;
    this.onConfirm = onConfirm;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("confirm-modal");
    contentEl.createEl("p", { text: this.message, cls: "confirm-message" });
    const buttonContainer = contentEl.createDiv({ cls: "confirm-button-container" });
    const confirmBtn = buttonContainer.createEl("button", { text: "Confirm", cls: "confirm-button" });
    const cancelBtn = buttonContainer.createEl("button", { text: "Cancel", cls: "cancel-button" });
    confirmBtn.onclick = () => {
      this.close();
      this.onConfirm();
    };
    cancelBtn.onclick = () => {
      this.close();
    };
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var ChatHistoryModal = class extends import_obsidian2.Modal {
  constructor(app, histories, onSelect, plugin) {
    super(app);
    this.histories = histories;
    this.onSelect = onSelect;
    this.plugin = plugin;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("chat-history-modal");
    const headerContainer = contentEl.createDiv({ cls: "history-header-container" });
    headerContainer.createEl("h2", { text: "Chat History" });
    this.addExportButton(headerContainer, this.histories);
    const searchInput = this.addSearchBar(contentEl);
    this.setupModalKeyboardShortcuts(searchInput);
    if (this.histories.length === 0) {
      contentEl.createEl("p", { text: "No chat history found." });
      return;
    }
    const historyList = contentEl.createDiv({ cls: "history-list" });
    const pinnedHistories = this.histories.filter((h) => h.pinned);
    if (pinnedHistories.length > 0) {
      const pinnedHeader = historyList.createDiv({ cls: "pinned-section" });
      pinnedHeader.createEl("h3", { text: "Pinned Conversations", cls: "pinned-header" });
      pinnedHistories.forEach((history) => {
        this.createHistoryItem(historyList, history);
      });
    }
    const conversationsByDate = /* @__PURE__ */ new Map();
    this.histories.filter((h) => !h.pinned).forEach((history) => {
      var _a;
      const date = new Date(history.date);
      const dateKey = `${date.getFullYear()}-${date.getMonth() + 1}-${date.getDate()}`;
      if (!conversationsByDate.has(dateKey)) {
        conversationsByDate.set(dateKey, []);
      }
      (_a = conversationsByDate.get(dateKey)) == null ? void 0 : _a.push(history);
    });
    const sortedDates = Array.from(conversationsByDate.keys()).sort((a, b) => new Date(b).getTime() - new Date(a).getTime());
    sortedDates.forEach((dateKey) => {
      const conversations = conversationsByDate.get(dateKey);
      if (!conversations || conversations.length === 0) return;
      const dateObj = new Date(dateKey);
      const dateHeader = historyList.createDiv({ cls: "history-date-header" });
      dateHeader.setText(dateObj.toLocaleDateString(void 0, {
        weekday: "long",
        year: "numeric",
        month: "long",
        day: "numeric"
      }));
      conversations.forEach((history) => {
        this.createHistoryItem(historyList, history);
      });
    });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
  addExportButton(container, histories) {
    if (histories.length === 0) return;
    const exportButtonContainer = container.createDiv({ cls: "export-button-container" });
    const exportButton = exportButtonContainer.createEl("button", {
      text: "Export All Conversations",
      cls: "export-button"
    });
    exportButton.addEventListener("click", () => __async(this, null, function* () {
      try {
        const markdownContent = this.generateMarkdownExport(histories);
        const textArea = document.createElement("textarea");
        textArea.value = markdownContent;
        document.body.appendChild(textArea);
        textArea.select();
        document.execCommand("copy");
        document.body.removeChild(textArea);
        const blob = new Blob([markdownContent], { type: "text/markdown" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = `chat-history-export-${(/* @__PURE__ */ new Date()).toISOString().slice(0, 10)}.md`;
        document.body.appendChild(a);
        a.click();
        setTimeout(() => {
          document.body.removeChild(a);
          URL.revokeObjectURL(url);
        }, 100);
        new import_obsidian2.Notice("Chat history exported and copied to clipboard", 2e3);
      } catch (error) {
        console.error("Failed to export chat history:", error);
        new import_obsidian2.Notice("Failed to export chat history", 2e3);
      }
    }));
  }
  generateMarkdownExport(histories) {
    const sortedHistories = [...histories].sort((a, b) => b.date - a.date);
    let markdownContent = `# Chat History Export
Exported on ${(/* @__PURE__ */ new Date()).toLocaleString()}

`;
    sortedHistories.forEach((history, index) => {
      markdownContent += `## Conversation ${index + 1}: ${history.title}
`;
      markdownContent += `Date: ${new Date(history.date).toLocaleString()}

`;
      history.messages.forEach((message) => {
        const role = message.role === "user" ? "\u{1F464} User" : "\u{1F916} AI";
        markdownContent += `### ${role}

${message.content}

`;
      });
      markdownContent += `---

`;
    });
    return markdownContent;
  }
  addSearchBar(container) {
    const searchContainer = container.createDiv({ cls: "history-search-container" });
    const searchInput = searchContainer.createEl("input", {
      type: "text",
      placeholder: "Search conversations...",
      cls: "history-search-input"
    });
    const clearButton = searchContainer.createEl("button", {
      cls: "history-search-clear",
      attr: { "aria-label": "Clear search" }
    });
    (0, import_obsidian2.setIcon)(clearButton, "x");
    clearButton.style.display = "none";
    searchInput.addEventListener("input", () => {
      const query = searchInput.value.toLowerCase().trim();
      clearButton.style.display = query ? "flex" : "none";
      this.filterHistoryItems(query);
    });
    clearButton.addEventListener("click", () => {
      searchInput.value = "";
      clearButton.style.display = "none";
      this.filterHistoryItems("");
    });
    return searchInput;
  }
  filterHistoryItems(query) {
    const pinnedSection = this.contentEl.querySelector(".pinned-section");
    const dateHeaders = this.contentEl.querySelectorAll(".history-date-header");
    const historyItems = this.contentEl.querySelectorAll(".history-item");
    if (!query) {
      if (pinnedSection) {
        pinnedSection.style.display = "block";
      }
      dateHeaders.forEach((header) => {
        header.style.display = "block";
      });
      historyItems.forEach((item) => {
        item.style.display = "flex";
      });
      return;
    }
    const headersWithVisibleItems = /* @__PURE__ */ new Set();
    let hasPinnedVisible = false;
    historyItems.forEach((item) => {
      var _a, _b;
      const titleEl = item.querySelector(".history-title");
      const previewEl = item.querySelector(".history-preview-content");
      const title = titleEl ? ((_a = titleEl.textContent) == null ? void 0 : _a.toLowerCase()) || "" : "";
      const preview = previewEl ? ((_b = previewEl.textContent) == null ? void 0 : _b.toLowerCase()) || "" : "";
      const matches = title.includes(query) || preview.includes(query);
      item.style.display = matches ? "flex" : "none";
      if (matches) {
        if (item.classList.contains("pinned-conversation")) {
          hasPinnedVisible = true;
        } else {
          const dateHeader = this.findClosestDateHeader(item);
          if (dateHeader) {
            headersWithVisibleItems.add(dateHeader.textContent || "");
          }
        }
      }
    });
    if (pinnedSection) {
      pinnedSection.style.display = hasPinnedVisible ? "block" : "none";
    }
    dateHeaders.forEach((header) => {
      const headerText = header.textContent || "";
      header.style.display = headersWithVisibleItems.has(headerText) ? "block" : "none";
    });
  }
  // Helper method to find the corresponding date header for an item
  findClosestDateHeader(element) {
    let current = element.previousElementSibling;
    while (current) {
      if (current.classList.contains("history-date-header")) {
        return current;
      }
      current = current.previousElementSibling;
    }
    return null;
  }
  setupModalKeyboardShortcuts(searchInput) {
    setTimeout(() => searchInput.focus(), 50);
    this.contentEl.addEventListener("keydown", (event) => {
      var _a;
      if (event.key === "f" && (event.ctrlKey || event.metaKey) || event.key === "/" && !event.isComposing && !(event.target instanceof HTMLInputElement)) {
        event.preventDefault();
        searchInput.focus();
      }
      if (event.key === "Enter" && event.target instanceof HTMLElement) {
        const historyItem = event.target.closest(".history-item");
        if (historyItem) {
          event.preventDefault();
          const clickEvent = new MouseEvent("click", {
            bubbles: true,
            cancelable: true,
            view: window
          });
          (_a = historyItem.querySelector(".history-item-content")) == null ? void 0 : _a.dispatchEvent(clickEvent);
        }
      }
    });
  }
  addRenameButton(actionsDiv, history, item) {
    const renameBtn = actionsDiv.createEl("button", {
      cls: "history-rename-button",
      attr: {
        "aria-label": "Rename conversation",
        "title": "Rename conversation"
      }
    });
    (0, import_obsidian2.setIcon)(renameBtn, "edit-2");
    renameBtn.addEventListener("click", (e) => {
      e.stopPropagation();
      const titleEl = item.querySelector(".history-title");
      if (!titleEl) return;
      const currentTitle = titleEl.textContent || "";
      const inputEl = document.createElement("input");
      inputEl.type = "text";
      inputEl.value = currentTitle;
      inputEl.className = "history-rename-input";
      titleEl.empty();
      titleEl.appendChild(inputEl);
      inputEl.focus();
      inputEl.select();
      const handleRename = () => __async(this, null, function* () {
        const newTitle = inputEl.value.trim() || currentTitle;
        titleEl.empty();
        titleEl.setText(newTitle);
        history.title = newTitle;
        if (this.plugin) {
          try {
            const historyDir = this.plugin.settings.chatHistoryPath;
            const filePath = `${historyDir}/chat-${history.id}.json`;
            yield this.app.vault.adapter.write(
              filePath,
              JSON.stringify(history, null, 2)
            );
            new import_obsidian2.Notice("Conversation renamed", 2e3);
          } catch (error) {
            console.error("Failed to rename conversation:", error);
            new import_obsidian2.Notice("Failed to rename conversation", 2e3);
          }
        }
      });
      inputEl.addEventListener("keydown", (e2) => {
        if (e2.key === "Enter") {
          e2.preventDefault();
          handleRename();
        } else if (e2.key === "Escape") {
          e2.preventDefault();
          titleEl.empty();
          titleEl.setText(currentTitle);
        }
      });
      inputEl.addEventListener("blur", handleRename);
    });
    return renameBtn;
  }
  addPinButton(actionsDiv, history, item) {
    const pinBtn = actionsDiv.createEl("button", {
      cls: `history-pin-button ${history.pinned ? "pinned" : ""}`,
      attr: {
        "aria-label": history.pinned ? "Unpin conversation" : "Pin conversation",
        "title": history.pinned ? "Unpin conversation" : "Pin conversation"
      }
    });
    (0, import_obsidian2.setIcon)(pinBtn, history.pinned ? "pin-off" : "pin");
    pinBtn.addEventListener("click", (e) => __async(this, null, function* () {
      e.stopPropagation();
      history.pinned = !history.pinned;
      pinBtn.className = `history-pin-button ${history.pinned ? "pinned" : ""}`;
      pinBtn.setAttribute("aria-label", history.pinned ? "Unpin conversation" : "Pin conversation");
      pinBtn.setAttribute("title", history.pinned ? "Unpin conversation" : "Pin conversation");
      pinBtn.empty();
      (0, import_obsidian2.setIcon)(pinBtn, history.pinned ? "pin-off" : "pin");
      if (history.pinned) {
        item.classList.add("pinned-conversation");
      } else {
        item.classList.remove("pinned-conversation");
      }
      if (this.plugin) {
        try {
          const historyDir = this.plugin.settings.chatHistoryPath;
          const filePath = `${historyDir}/chat-${history.id}.json`;
          yield this.app.vault.adapter.write(
            filePath,
            JSON.stringify(history, null, 2)
          );
          this.reorderHistoryItems();
          new import_obsidian2.Notice(history.pinned ? "Conversation pinned" : "Conversation unpinned", 2e3);
        } catch (error) {
          console.error("Failed to update pin status:", error);
          new import_obsidian2.Notice("Failed to update pin status", 2e3);
        }
      }
    }));
    return pinBtn;
  }
  reorderHistoryItems() {
    const historyList = this.contentEl.querySelector(".history-list");
    if (!historyList) return;
    const pinnedSection = this.contentEl.querySelector(".pinned-section");
    if (!pinnedSection) {
      const hasPinnedItems = this.histories.some((h) => h.pinned);
      if (hasPinnedItems) {
        const pinnedHeader = this.contentEl.createDiv({ cls: "pinned-section" });
        pinnedHeader.createEl("h3", { text: "Pinned Conversations", cls: "pinned-header" });
        historyList.insertBefore(pinnedHeader, historyList.firstChild);
      }
    } else {
      const hasPinnedItems = this.histories.some((h) => h.pinned);
      if (!hasPinnedItems) {
        pinnedSection.remove();
      }
    }
    const searchInput = this.contentEl.querySelector(".history-search-input");
    if (searchInput) {
      const currentQuery = searchInput.value;
      this.filterHistoryItems(currentQuery);
    }
  }
  createHistoryItem(container, history) {
    const item = container.createDiv({
      cls: `history-item ${history.pinned ? "pinned-conversation" : ""}`
    });
    const contentDiv = item.createDiv({ cls: "history-item-content" });
    const titleEl = contentDiv.createDiv({ cls: "history-title" });
    titleEl.setText(history.title);
    const date = new Date(history.date);
    const metaEl = contentDiv.createDiv({ cls: "history-meta" });
    metaEl.setText(`${history.messages.length} messages \u2022 ${date.toLocaleTimeString()}`);
    if (history.messages.length > 0) {
      const lastMessage = history.messages[history.messages.length - 1];
      const previewEl = contentDiv.createDiv({ cls: "history-preview" });
      const roleEl = previewEl.createSpan({ cls: "history-preview-role" });
      roleEl.setText(lastMessage.role === "user" ? "You: " : "AI: ");
      const contentPreview = lastMessage.content.replace(/\n/g, " ").substring(0, 60) + (lastMessage.content.length > 60 ? "..." : "");
      const contentEl = previewEl.createSpan({ cls: "history-preview-content" });
      contentEl.setText(contentPreview);
    }
    contentDiv.addEventListener("click", () => {
      this.onSelect(history);
      this.close();
    });
    const actionsDiv = item.createDiv({ cls: "history-item-actions" });
    this.addPinButton(actionsDiv, history, item);
    this.addRenameButton(actionsDiv, history, item);
    const deleteBtn = actionsDiv.createEl("button", {
      cls: "history-delete-button",
      attr: {
        "aria-label": "Delete conversation",
        "title": "Delete conversation"
      }
    });
    (0, import_obsidian2.setIcon)(deleteBtn, "trash");
    deleteBtn.addEventListener("click", (e) => __async(this, null, function* () {
      e.stopPropagation();
      new ConfirmModal(
        this.app,
        "Are you sure you want to delete this conversation?",
        () => __async(this, null, function* () {
          if (this.plugin) {
            try {
              const historyDir = this.plugin.settings.chatHistoryPath;
              const filePath = `${historyDir}/chat-${history.id}.json`;
              yield this.app.vault.adapter.remove(filePath);
              const index = this.histories.findIndex((h) => h.id === history.id);
              if (index >= 0) {
                this.histories.splice(index, 1);
              }
              item.remove();
              this.reorderHistoryItems();
              new import_obsidian2.Notice("Conversation deleted", 2e3);
            } catch (error) {
              console.error("Failed to delete conversation:", error);
              new import_obsidian2.Notice("Failed to delete conversation", 2e3);
            }
          }
        })
      ).open();
    }));
    return item;
  }
};
var ChatView = class extends import_obsidian2.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this.messages = [];
    this.currentMode = "chat";
    this.requestId = null;
    this.knowledgeBaseCache = /* @__PURE__ */ new Map();
    this.MAX_RETRIES = 3;
    this.RETRY_DELAY = 1e3;
    this.MAX_TOKENS = 4096;
    this.RENDER_THROTTLE = 30;
    // New history button
    this.lastHistorySave = 0;
    this.isEndingConversation = false;
    this.conversationId = null;
    this.lastNoticedFile = null;
    this.plugin = plugin;
    this.requestId = this.plugin.requestId;
  }
  load() {
  }
  unload() {
  }
  getViewType() {
    return VIEW_TYPE_CHAT;
  }
  getDisplayText() {
    return "AI Chat";
  }
  getIcon() {
    return "message-square";
  }
  onOpen() {
    return __async(this, null, function* () {
      this.contentEl.addClass("chat-view-container");
      this.tabsContainer = this.contentEl.createDiv({ cls: "chat-tabs" });
      this.createTabs();
      this.viewContainer = this.contentEl.createDiv({ cls: "view-container" });
      this.initializeChatView();
    });
  }
  createTabs() {
    const chatTab = this.tabsContainer.createDiv({
      cls: `chat-tab ${this.currentMode === "chat" ? "active" : ""}`
    });
    chatTab.innerHTML = '<svg viewBox="0 0 100 100" class="chat-icon"><path d="M20,20v45h10v15l15-15h35V20H20z M25,25h50v35H42.5L35,67.5V60H25V25z"/></svg>';
    const searchTab = this.tabsContainer.createDiv({
      cls: `chat-tab ${this.currentMode === "search" ? "active" : ""}`
    });
    searchTab.innerHTML = '<svg viewBox="0 0 100 100" class="search-icon"><path d="M80,75 L65,60 C70,54 73,46 73,38 C73,22 60,9 44,9 C28,9 15,22 15,38 C15,54 28,67 44,67 C52,67 60,64 66,59 L81,74 L80,75 Z M44,62 C31,62 20,51 20,38 C20,25 31,14 44,14 C57,14 68,25 68,38 C68,51 57,62 44,62 Z"/></svg>';
    chatTab.onclick = () => this.switchMode("chat");
    searchTab.onclick = () => this.switchMode("search");
  }
  switchMode(mode) {
    return __async(this, null, function* () {
      if (this.currentMode === "chat" && mode === "search" && this.messages.length > 0) {
        this.isEndingConversation = true;
        yield this.saveChatHistory();
      }
      this.currentMode = mode;
      const tabs = this.tabsContainer.querySelectorAll(".chat-tab");
      tabs.forEach((tab) => tab.classList.remove("active"));
      const activeTab = this.tabsContainer.querySelector(`.chat-tab:nth-child(${mode === "chat" ? 1 : 2})`);
      if (activeTab) {
        activeTab.classList.add("active");
      }
      this.viewContainer.empty();
      if (mode === "chat") {
        yield this.initializeChatView();
      } else {
        yield this.initializeSearchView();
      }
    });
  }
  initializeChatView() {
    return __async(this, null, function* () {
      this.chatContainer = this.viewContainer.createDiv({ cls: "chat-container" });
      this.chatHistoryButton = this.chatContainer.createDiv({ cls: "chat-history-button" });
      (0, import_obsidian2.setIcon)(this.chatHistoryButton, "history");
      this.chatHistoryButton.setAttribute("aria-label", "View chat history");
      this.chatHistoryButton.addEventListener("click", () => this.showChatHistory());
      const newChatButton = this.chatContainer.createDiv({ cls: "new-chat-button" });
      (0, import_obsidian2.setIcon)(newChatButton, "plus-circle");
      newChatButton.setAttribute("aria-label", "Start new chat");
      newChatButton.addEventListener("click", () => this.startNewChat());
      this.messagesContainer = this.chatContainer.createDiv({ cls: "messages-container" });
      this.inputContainer = this.chatContainer.createDiv({ cls: "input-container" });
      const inputWrapper = this.inputContainer.createDiv({ cls: "input-wrapper" });
      this.currentInput = inputWrapper.createEl("textarea", {
        cls: "chat-input",
        attr: { placeholder: "Type your message... (Press Enter to send) \u23CE" }
      });
      const functionIconsContainer = this.inputContainer.createDiv({ cls: "function-icons-container" });
      if (!this.plugin.settings.functions || this.plugin.settings.functions.length === 0) {
        console.log("Initializing functions array from defaults");
        this.plugin.settings.functions = [...DEFAULT_SETTINGS.functions];
        if (this.plugin.settings.customFunctions && this.plugin.settings.customFunctions.length > 0) {
          this.plugin.settings.functions.push(...this.plugin.settings.customFunctions);
        }
        this.plugin.saveSettings();
      }
      console.log("Available functions:", this.plugin.settings.functions.map((f) => f.name).join(", "));
      if (!this.plugin.settings.functions.some((f) => f.name === "Polish")) {
        console.log("Polish function missing, adding it");
        this.plugin.settings.functions.push({
          name: "Polish",
          prompt: "Please polish and refine the following text to improve clarity, flow, and style while preserving the original meaning and language. Enhance the expression, eliminate redundancies, and make it more engaging. Return the polished version only, without explanations:",
          icon: "bird",
          tooltip: "Polish and refine text",
          isBuiltIn: true
        });
        this.plugin.saveSettings();
      }
      this.plugin.settings.functions.forEach((func) => {
        console.log(`Creating button for function: ${func.name}, icon: ${func.icon}`);
        const iconButton = functionIconsContainer.createEl("button", {
          cls: `function-icon-button ${func.isBuiltIn ? "built-in" : "custom-function"}`,
          attr: { "aria-label": `${func.name} ${func.tooltip ? `(${func.tooltip})` : ""}` }
        });
        try {
          (0, import_obsidian2.setIcon)(iconButton, func.icon);
        } catch (e) {
          (0, import_obsidian2.setIcon)(iconButton, "bot");
          console.warn(`Invalid icon '${func.icon}' for function '${func.name}'`);
        }
        const tooltipEl = iconButton.createSpan({ cls: "function-icon-tooltip" });
        tooltipEl.setText(func.tooltip || func.name);
        if (func.isBuiltIn) {
          switch (func.name) {
            case "Organize":
              iconButton.onclick = () => this.handleOrganize();
              break;
            case "Grammar":
              iconButton.onclick = () => this.handleGrammar();
              break;
            case "Generate":
              iconButton.onclick = () => this.handleGenerate();
              break;
            case "Dialogue":
              iconButton.onclick = () => this.handleDialogue();
              break;
            case "Summarize":
              iconButton.onclick = () => this.handleSummarize();
              break;
            case "Polish":
              iconButton.onclick = () => this.handlePolish();
              break;
            default:
              iconButton.onclick = () => this.handleCustomFunction(func);
          }
        } else {
          iconButton.onclick = () => this.handleCustomFunction(func);
        }
      });
      this.setupKeyboardShortcuts();
      if (this.messages.length > 0) {
        this.renderChatHistory();
      }
    });
  }
  initializeSearchView() {
    return __async(this, null, function* () {
      const searchContainer = this.viewContainer.createDiv({ cls: "search-container" });
      const inputContainer = searchContainer.createDiv({ cls: "search-input-container" });
      const dirSelector = inputContainer.createEl("select", {
        cls: "search-dir-selector",
        attr: {
          "aria-label": "Select directory to search in"
        }
      });
      dirSelector.createEl("option", {
        text: "All Files",
        value: ""
      });
      const rootFolder = this.app.vault.getRoot();
      const folders = rootFolder.children.filter((child) => child instanceof import_obsidian2.TFolder).sort((a, b) => a.name.localeCompare(b.name));
      folders.forEach((folder) => {
        dirSelector.createEl("option", {
          text: folder.name,
          value: folder.path
        });
      });
      const searchInputRow = inputContainer.createDiv({ cls: "search-input-row" });
      const searchInput = searchInputRow.createEl("input", {
        cls: "search-input",
        attr: {
          placeholder: "Enter your search query...",
          "aria-label": "Search query",
          type: "search"
        }
      });
      const searchButton = searchInputRow.createEl("button", {
        cls: "search-button",
        text: "Search"
      });
      const resultsContainer = searchContainer.createDiv({ cls: "search-results" });
      const progressContainer = searchContainer.createDiv({ cls: "search-progress" });
      const progressBar = progressContainer.createDiv({ cls: "search-progress-bar" });
      const progressText = progressContainer.createDiv({ cls: "search-progress-text" });
      const countText = progressContainer.createDiv({ cls: "count-text" });
      progressContainer.style.display = "none";
      const handleSearch = () => __async(this, null, function* () {
        const query = searchInput.value.trim();
        if (!query) {
          resultsContainer.empty();
          resultsContainer.createDiv({
            cls: "error-message",
            text: "Please enter a search query."
          });
          return;
        }
        progressContainer.style.display = "block";
        progressText.textContent = "Initializing search...";
        progressBar.style.width = "0%";
        countText.textContent = "";
        resultsContainer.empty();
        try {
          const selectedDir = dirSelector.value;
          const files = yield this.plugin.getKnowledgeBaseNotes(selectedDir);
          const now = Date.now();
          const CACHE_DURATION = 30 * 60 * 1e3;
          if (files.length === 0) {
            progressContainer.style.display = "none";
            resultsContainer.createDiv({
              cls: "error-message",
              text: selectedDir ? `No files found in directory: ${selectedDir}` : "No files found in knowledge base."
            });
            return;
          }
          let processed = 0;
          const results = [];
          const totalFiles = files.length;
          countText.textContent = `Found ${totalFiles} files to process`;
          for (const file of files) {
            const content = yield this.app.vault.read(file);
            const currentHash = yield this.calculateFileHash(content);
            const cached = this.knowledgeBaseCache.get(file.path);
            if (cached && now - cached.timestamp < CACHE_DURATION && cached.hash === currentHash) {
              results.push({
                file,
                similarity: cached.similarity,
                content: cached.content
              });
              processed++;
              continue;
            }
            const similarity = yield this.plugin.calculateSimilarity(query, content);
            results.push({ file, similarity, content });
            this.knowledgeBaseCache.set(file.path, {
              similarity,
              content,
              timestamp: now,
              hash: currentHash
            });
            processed++;
            const progress = processed / files.length * 100;
            progressBar.style.width = `${progress}%`;
            progressText.textContent = `Processing ${processed}/${files.length} files...`;
            countText.textContent = `Found ${files.length} files, processed ${processed}`;
          }
          progressText.textContent = "Generating summary...";
          progressBar.style.width = "100%";
          countText.textContent = `Processing summary for top ${Math.min(5, results.length)} results...`;
          const topResults = results.sort((a, b) => b.similarity - a.similarity).slice(0, 5);
          yield this.displaySearchResults(resultsContainer, topResults);
          progressContainer.style.display = "none";
        } catch (error) {
          progressContainer.style.display = "none";
          resultsContainer.createDiv({
            cls: "error-message",
            text: `Error: ${error.message}`
          });
        }
      });
      searchInput.addEventListener("keydown", (e) => __async(this, null, function* () {
        if (e.key === "Enter") {
          yield handleSearch();
        }
      }));
      searchButton.addEventListener("click", handleSearch);
      searchInput.focus();
    });
  }
  addMessage(role, content) {
    return __async(this, null, function* () {
      this.messages.push({ role, content });
      const messageDiv = this.messagesContainer.createDiv({
        cls: role === "user" ? "user-message" : "ai-message"
      });
      const contentDiv = messageDiv.createDiv({ cls: "message-content" });
      const metadata = contentDiv.createDiv({ cls: "message-metadata" });
      metadata.setText((/* @__PURE__ */ new Date()).toLocaleTimeString());
      const textDiv = contentDiv.createDiv({ cls: "message-text" });
      yield MarkdownRenderer.renderMarkdown(
        content,
        textDiv,
        "",
        this.plugin
      );
      if (role === "assistant") {
        const actionContainer = contentDiv.createDiv({ cls: "message-actions hover-only" });
        const copyButton = actionContainer.createEl("button", {
          cls: "message-action-button copy-button",
          attr: { "aria-label": "Copy message" }
        });
        (0, import_obsidian2.setIcon)(copyButton, "copy");
        copyButton.onclick = () => __async(this, null, function* () {
          try {
            yield navigator.clipboard.writeText(content);
            new import_obsidian2.Notice("Copied to clipboard", 2e3);
          } catch (err) {
            console.error("Failed to copy content:", err);
            new import_obsidian2.Notice("Failed to copy content");
          }
        });
        const insertButton = actionContainer.createEl("button", {
          cls: "message-action-button insert-button",
          attr: { "aria-label": "Insert into editor" }
        });
        (0, import_obsidian2.setIcon)(insertButton, "plus");
        insertButton.onclick = () => {
          const activeLeaf = this.app.workspace.activeLeaf;
          if (!activeLeaf) {
            new import_obsidian2.Notice("Please open a markdown file first");
            return;
          }
          const view = activeLeaf.view;
          if (!(view instanceof import_obsidian2.MarkdownView)) {
            new import_obsidian2.Notice("Please open a markdown file first");
            return;
          }
          const editor = view.editor;
          const cursor = editor.getCursor();
          editor.replaceRange(content + "\n", cursor);
          editor.focus();
          new import_obsidian2.Notice("Content inserted into editor", 2e3);
        };
        const applyButton = actionContainer.createEl("button", {
          cls: "message-action-button apply-button",
          attr: { "aria-label": "Apply changes to original text" }
        });
        (0, import_obsidian2.setIcon)(applyButton, "check");
        applyButton.onclick = () => {
          const editor = this.getEditor();
          if (!editor) {
            new import_obsidian2.Notice("Please open a markdown file first");
            return;
          }
          let originalText = "";
          let isSelection = false;
          if (editor.somethingSelected()) {
            originalText = editor.getSelection();
            isSelection = true;
          } else {
            originalText = editor.getValue();
          }
          new PolishResultModal(this.plugin.app, this.plugin, originalText, content, (updatedContent) => {
            if (editor) {
              if (isSelection) {
                editor.replaceSelection(updatedContent);
              } else {
                editor.setValue(updatedContent);
              }
              new import_obsidian2.Notice("Changes applied to text!", 2e3);
            }
          }).open();
        };
      }
      this.messagesContainer.scrollTo({
        top: this.messagesContainer.scrollHeight,
        behavior: "smooth"
      });
    });
  }
  // Improved method to get the editor, trying to find an open markdown file
  // even if the chat view is currently active
  getEditor() {
    const activeLeaf = this.app.workspace.activeLeaf;
    if (activeLeaf && activeLeaf.view instanceof import_obsidian2.MarkdownView) {
      const fileName = activeLeaf.getDisplayText();
      this.lastNoticedFile = fileName;
      return activeLeaf.view.editor;
    }
    const mdLeaves = this.app.workspace.getLeavesOfType("markdown");
    if (mdLeaves.length > 0) {
      const mdView = mdLeaves[0].view;
      const fileName = mdLeaves[0].getDisplayText();
      if (mdView && mdView.editor) {
        if (this.lastNoticedFile !== fileName) {
          new import_obsidian2.Notice(`Using the file "${fileName}" for content`, 2e3);
          this.lastNoticedFile = fileName;
        }
        return mdView.editor;
      }
    }
    const leaves = this.app.workspace.getLeavesOfType("");
    for (const leaf of leaves) {
      if (leaf.view && "getViewType" in leaf.view && leaf.view.getViewType() === "markdown" && "editor" in leaf.view) {
        const fileName = leaf.getDisplayText();
        new import_obsidian2.Notice(`Using the file "${fileName}" for content`, 2e3);
        this.lastNoticedFile = fileName;
        return leaf.view.editor;
      }
    }
    return null;
  }
  // Method to get the selected text from the editor
  getSelectedText() {
    return __async(this, null, function* () {
      const editor = this.getEditor();
      if (!editor) return "";
      return editor.somethingSelected() ? editor.getSelection() : "";
    });
  }
  // Method to get the content of the current file
  getCurrentFileContent() {
    return __async(this, null, function* () {
      const editor = this.getEditor();
      if (!editor) return "";
      return editor.getValue();
    });
  }
  // Helper method to send a message to the chat with a function prompt
  sendFunctionPromptToChat(prompt, content = "") {
    return __async(this, null, function* () {
      if (content) {
        this.sendMessage(prompt, content);
        new import_obsidian2.Notice(`Applied function to ${(yield this.getSelectedText()) ? "selected text" : "current document"}`, 2e3);
      } else {
        const editor = this.getEditor();
        let documentContent = "";
        let isSelection = false;
        if (editor) {
          if (editor.somethingSelected()) {
            documentContent = editor.getSelection();
            isSelection = true;
          } else {
            documentContent = editor.getValue();
          }
        }
        if (documentContent) {
          this.sendMessage(prompt, documentContent);
          const source = isSelection ? "selected text" : "current document";
          new import_obsidian2.Notice(`Applied function to ${source}`, 2e3);
        } else {
          this.currentInput.value = prompt + "\n\n(Paste your text here or open a file first)";
          this.currentInput.focus();
          const placeholderPos = this.currentInput.value.indexOf("(Paste your text here");
          if (placeholderPos > -1) {
            this.currentInput.setSelectionRange(placeholderPos, placeholderPos + "(Paste your text here or open a file first)".length);
          }
        }
      }
    });
  }
  // Updated handler methods to use a consistent approach
  handleSummarize() {
    return __async(this, null, function* () {
      const content = yield this.getCurrentFileContent();
      const selectedText = yield this.getSelectedText();
      const summarizeFunc = this.plugin.settings.functions.find((f) => f.name === "Summarize");
      const prompt = summarizeFunc ? summarizeFunc.prompt : "";
      if (!content) {
        this.sendFunctionPromptToChat(prompt);
        return;
      }
      this.sendFunctionPromptToChat(prompt, selectedText || content);
    });
  }
  // Updated method to check if we can use an editor
  shouldUseEditorMode() {
    const editor = this.getEditor();
    if (!editor) {
      new import_obsidian2.Notice("No active editor found. Please open a file first.", 2e3);
      return false;
    }
    return true;
  }
  // Add this method to handle the Polish function
  handlePolish() {
    return __async(this, null, function* () {
      const content = yield this.getCurrentFileContent();
      const selectedText = yield this.getSelectedText();
      const polishFunc = this.plugin.settings.functions.find((f) => f.name === "Polish");
      const prompt = polishFunc ? polishFunc.prompt : "";
      if (!content) {
        console.log("Polish function: No active file content found");
        this.sendFunctionPromptToChat(prompt);
        return;
      }
      console.log("Polish function: Using " + (selectedText ? "selected text" : "entire document"));
      this.sendFunctionPromptToChat(prompt, selectedText || content);
    });
  }
  handleOrganize() {
    return __async(this, null, function* () {
      const content = yield this.getCurrentFileContent();
      const selectedText = yield this.getSelectedText();
      const organizeFunc = this.plugin.settings.functions.find((f) => f.name === "Organize");
      const prompt = organizeFunc ? organizeFunc.prompt : "";
      if (!content) {
        this.sendFunctionPromptToChat(prompt);
        return;
      }
      this.sendFunctionPromptToChat(prompt, selectedText || content);
    });
  }
  handleGrammar() {
    return __async(this, null, function* () {
      const content = yield this.getCurrentFileContent();
      const selectedText = yield this.getSelectedText();
      const grammarFunc = this.plugin.settings.functions.find((f) => f.name === "Grammar");
      const prompt = grammarFunc ? grammarFunc.prompt : "";
      if (!content) {
        this.sendFunctionPromptToChat(prompt);
        return;
      }
      this.sendFunctionPromptToChat(prompt, selectedText || content);
    });
  }
  // Handler for custom functions
  handleCustomFunction(func) {
    return __async(this, null, function* () {
      const content = yield this.getCurrentFileContent();
      const selectedText = yield this.getSelectedText();
      if (!content) {
        this.sendFunctionPromptToChat(func.prompt);
        return;
      }
      this.sendFunctionPromptToChat(func.prompt, selectedText || content);
    });
  }
  // Handler for built-in generate content function
  handleGenerate() {
    return __async(this, null, function* () {
      const content = yield this.getCurrentFileContent();
      const selectedText = yield this.getSelectedText();
      const generateFunc = this.plugin.settings.functions.find((f) => f.isBuiltIn && f.name === "Generate");
      const prompt = generateFunc ? generateFunc.prompt : "";
      if (!content) {
        this.sendFunctionPromptToChat(prompt);
        return;
      }
      this.sendFunctionPromptToChat(prompt, selectedText || content);
    });
  }
  // Handler for built-in dialogue function
  handleDialogue() {
    return __async(this, null, function* () {
      const content = yield this.getCurrentFileContent();
      const selectedText = yield this.getSelectedText();
      const dialogueFunc = this.plugin.settings.functions.find((f) => f.isBuiltIn && f.name === "Dialogue");
      const prompt = dialogueFunc ? dialogueFunc.prompt : "";
      if (!content) {
        this.sendFunctionPromptToChat(prompt);
        return;
      }
      this.sendFunctionPromptToChat(prompt, selectedText || content);
    });
  }
  handleSend() {
    return __async(this, null, function* () {
      const content = this.currentInput.value.trim();
      if (!content) return;
      this.currentInput.value = "";
      yield this.addMessage("user", content);
      const messageDiv = this.messagesContainer.createDiv({
        cls: "ai-message"
      });
      const contentDiv = messageDiv.createDiv({ cls: "message-content" });
      const metadata = contentDiv.createDiv({ cls: "message-metadata" });
      metadata.setText((/* @__PURE__ */ new Date()).toLocaleTimeString());
      const textDiv = contentDiv.createDiv({ cls: "message-text" });
      try {
        if (!this.requestId) {
          this.requestId = crypto.randomUUID();
          this.plugin.requestId = this.requestId;
        }
        let streamedContent = "";
        let lastRenderTime = Date.now();
        let retries = 0;
        while (retries < this.MAX_RETRIES) {
          try {
            const response = yield this.plugin.callAIChat([
              ...this.messages,
              { role: "user", content }
            ], (chunk) => __async(this, null, function* () {
              if (!chunk) return;
              streamedContent += chunk;
              const now = Date.now();
              if (now - lastRenderTime >= this.RENDER_THROTTLE) {
                let renderRetries = 0;
                const MAX_RENDER_RETRIES = 3;
                while (renderRetries < MAX_RENDER_RETRIES) {
                  try {
                    textDiv.empty();
                    yield MarkdownRenderer.renderMarkdown(
                      streamedContent,
                      textDiv,
                      "",
                      this.plugin
                    );
                    this.scrollToBottom();
                    break;
                  } catch (e) {
                    console.warn(`Error rendering markdown (attempt ${renderRetries + 1}/${MAX_RENDER_RETRIES}):`, e);
                    if (renderRetries === MAX_RENDER_RETRIES - 1) {
                      textDiv.setText(streamedContent);
                    }
                    renderRetries++;
                    yield new Promise((resolve) => setTimeout(resolve, 100));
                  }
                }
                lastRenderTime = now;
              }
            }));
            this.messages.push({ role: "assistant", content: response });
            const actionContainer = contentDiv.createDiv({ cls: "message-actions hover-only" });
            const copyButton = actionContainer.createEl("button", {
              cls: "message-action-button copy-button",
              attr: { "aria-label": "Copy message" }
            });
            (0, import_obsidian2.setIcon)(copyButton, "copy");
            copyButton.onclick = () => __async(this, null, function* () {
              try {
                yield navigator.clipboard.writeText(response);
                new import_obsidian2.Notice("Copied to clipboard", 2e3);
              } catch (err) {
                console.error("Failed to copy content:", err);
                new import_obsidian2.Notice("Failed to copy content");
              }
            });
            const insertButton = actionContainer.createEl("button", {
              cls: "message-action-button insert-button",
              attr: { "aria-label": "Insert into editor" }
            });
            (0, import_obsidian2.setIcon)(insertButton, "plus");
            insertButton.onclick = () => {
              const activeLeaf = this.app.workspace.activeLeaf;
              if (!activeLeaf) {
                new import_obsidian2.Notice("Please open a markdown file first");
                return;
              }
              const view = activeLeaf.view;
              if (!(view instanceof import_obsidian2.MarkdownView)) {
                new import_obsidian2.Notice("Please open a markdown file first");
                return;
              }
              const editor = view.editor;
              const cursor = editor.getCursor();
              editor.replaceRange(response + "\n", cursor);
              editor.focus();
              new import_obsidian2.Notice("Content inserted into editor", 2e3);
            };
            const applyButton = actionContainer.createEl("button", {
              cls: "message-action-button apply-button",
              attr: { "aria-label": "Apply changes to original text" }
            });
            (0, import_obsidian2.setIcon)(applyButton, "check");
            applyButton.onclick = () => {
              const editor = this.getEditor();
              if (!editor) {
                new import_obsidian2.Notice("Please open a markdown file first");
                return;
              }
              let originalText = "";
              let isSelection = false;
              if (editor.somethingSelected()) {
                originalText = editor.getSelection();
                isSelection = true;
              } else {
                originalText = editor.getValue();
              }
              new PolishResultModal(this.plugin.app, this.plugin, originalText, response, (updatedContent) => {
                if (editor) {
                  if (isSelection) {
                    editor.replaceSelection(updatedContent);
                  } else {
                    editor.setValue(updatedContent);
                  }
                  new import_obsidian2.Notice("Changes applied to text!", 2e3);
                }
              }).open();
            };
            break;
          } catch (error) {
            console.error(`AI request failed (retry ${retries + 1}/${this.MAX_RETRIES}):`, error);
            if (retries === this.MAX_RETRIES - 1) {
              throw new Error("Failed to get AI response after multiple retries");
            }
            retries++;
            yield new Promise((resolve) => setTimeout(resolve, this.RETRY_DELAY * Math.pow(2, retries)));
          }
        }
      } catch (error) {
        console.error("Error in chat:", error);
        let errorMessage = "Sorry, an error occurred. Please try again.";
        if (error && error.message) {
          if (error.message.includes("images") || error.message.includes("unsupported content")) {
            errorMessage = "Error: Your message contains images or unsupported content that the AI cannot process. Please remove any images and try again.";
          } else if (error.message.includes("rate limit") || error.message.includes("429")) {
            errorMessage = "Error: Rate limit exceeded. Please wait a moment before trying again.";
          } else if (error.message.includes("Invalid API key") || error.message.includes("401")) {
            errorMessage = "Error: Invalid API key. Please check your API key in settings.";
          } else if (error.message.includes("Failed to get AI response after multiple retries")) {
            errorMessage = "Error: Failed to get a response after multiple attempts. Please check your internet connection and try again.";
          }
        }
        textDiv.empty();
        const errorContainer = textDiv.createDiv({ cls: "error-container" });
        const warningIcon = errorContainer.createDiv({ cls: "error-icon" });
        (0, import_obsidian2.setIcon)(warningIcon, "alert-triangle");
        const errorText = errorContainer.createDiv({ cls: "error-text" });
        errorText.setText(errorMessage);
        const retryButton = errorContainer.createEl("button", {
          cls: "compact-retry-button",
          text: "Retry Last Message"
        });
        retryButton.addEventListener("click", () => {
          messageDiv.remove();
          this.currentInput.value = content;
          this.currentInput.focus();
        });
      }
      if (this.shouldSaveHistory()) {
        yield this.saveChatHistory();
      }
    });
  }
  displaySearchResults(resultsContainer, topResults) {
    return __async(this, null, function* () {
      const contextsWithRefs = topResults.map((result, index) => {
        const cleanContent = result.content.replace(/\n+/g, " ").slice(0, 1e3);
        return `Document [${index + 1}] (${result.file.basename}):
${cleanContent}...`;
      }).join("\n\n");
      const summaryPrompt = `${this.plugin.settings.promptSummary}

${contextsWithRefs}`;
      const summary = yield this.plugin.getAIResponse(summaryPrompt);
      const summaryDiv = resultsContainer.createDiv({ cls: "search-summary" });
      yield MarkdownRenderer.renderMarkdown(summary, summaryDiv, "", this.plugin);
      const refsDiv = resultsContainer.createDiv({ cls: "search-references" });
      refsDiv.createEl("h3", { text: "References" });
      topResults.forEach((result, index) => {
        const refDiv = refsDiv.createDiv({ cls: "search-reference-item" });
        const link2 = refDiv.createEl("a", {
          text: `[${index + 1}] ${result.file.basename}`,
          cls: "search-reference-link"
        });
        link2.addEventListener("click", () => {
          this.app.workspace.getLeaf().openFile(result.file);
        });
      });
    });
  }
  calculateFileHash(content) {
    return __async(this, null, function* () {
      const encoder = new TextEncoder();
      const data = encoder.encode(content);
      const hashBuffer = yield crypto.subtle.digest("SHA-256", data);
      return Array.from(new Uint8Array(hashBuffer)).map((b) => b.toString(16).padStart(2, "0")).join("");
    });
  }
  estimateTokenCount(text) {
    return Math.ceil(text.length / 4);
  }
  scrollToBottom(smooth = true) {
    if (this.messagesContainer) {
      void this.messagesContainer.offsetHeight;
      const isAtBottom = this.messagesContainer.scrollHeight - this.messagesContainer.scrollTop - this.messagesContainer.clientHeight < 100;
      const behavior = smooth && !isAtBottom ? "smooth" : "auto";
      this.messagesContainer.scrollTo({
        top: this.messagesContainer.scrollHeight,
        behavior
      });
    }
  }
  onClose() {
    return __async(this, null, function* () {
    });
  }
  setupKeyboardShortcuts() {
    this.currentInput.addEventListener("keydown", (event) => __async(this, null, function* () {
      if (event.key === "Enter" && !event.shiftKey && !event.altKey && !event.ctrlKey && !event.metaKey) {
        event.preventDefault();
        yield this.handleSend();
      }
      if (event.key === "Enter" && event.shiftKey) {
        return;
      }
      if (event.key === "Enter" && event.altKey) {
        event.preventDefault();
        const start = this.currentInput.selectionStart;
        const end = this.currentInput.selectionEnd;
        this.currentInput.value = this.currentInput.value.substring(0, start) + "\n" + this.currentInput.value.substring(end);
        this.currentInput.selectionStart = this.currentInput.selectionEnd = start + 1;
      }
      if (event.key === "Escape") {
        event.preventDefault();
        this.currentInput.value = "";
        this.currentInput.focus();
      }
      if (event.key.toLowerCase() === "l" && (event.ctrlKey || event.metaKey)) {
        event.preventDefault();
        this.clearChat();
      }
    }));
  }
  clearChat() {
    if (this.messagesContainer) {
      this.messagesContainer.empty();
      this.messages = [];
      new import_obsidian2.Notice("Chat cleared");
    }
  }
  sendMessage(prompt, content) {
    this.currentInput.value = `${prompt}

${content}`;
    this.handleSend();
  }
  // Add this method to save the current chat history
  saveChatHistory() {
    return __async(this, null, function* () {
      if (this.messages.length === 0) return;
      try {
        if (!this.conversationId) {
          this.conversationId = crypto.randomUUID();
        }
        const history = {
          id: this.conversationId,
          title: this.getHistoryTitle(),
          date: Date.now(),
          messages: [...this.messages],
          requestId: this.requestId
        };
        const historyDir = this.plugin.settings.chatHistoryPath;
        const folderExists = yield this.ensureFolderExists(historyDir);
        if (!folderExists) {
          throw new Error(`Failed to create chat history directory: ${historyDir}`);
        }
        const fileName = `chat-${this.conversationId}.json`;
        const filePath = `${historyDir}/${fileName}`;
        yield this.plugin.app.vault.adapter.write(filePath, JSON.stringify(history, null, 2));
        this.lastHistorySave = Date.now();
        console.log(`Chat history saved: ${filePath} with ${this.messages.length} messages`);
        return true;
      } catch (error) {
        return this.handleHistoryError("save chat history", error);
      }
    });
  }
  // Helper to ensure a folder exists
  ensureFolderExists(path) {
    return __async(this, null, function* () {
      const { vault } = this.plugin.app;
      const folderExists = yield vault.adapter.exists(path);
      if (!folderExists) {
        try {
          yield vault.createFolder(path);
          return true;
        } catch (error) {
          console.error(`Failed to create folder ${path}:`, error);
          return false;
        }
      }
      return true;
    });
  }
  // Get a title for the chat history based on first user message
  getHistoryTitle() {
    const firstUserMsg = this.messages.find((m) => m.role === "user");
    if (!firstUserMsg) return "Chat Session";
    const title = firstUserMsg.content.substring(0, 30).trim();
    return title + (firstUserMsg.content.length > 30 ? "..." : "");
  }
  // Show the chat history modal
  showChatHistory() {
    return __async(this, null, function* () {
      this.isEndingConversation = true;
      try {
        const histories = yield this.loadChatHistories();
        new ChatHistoryModal(this.plugin.app, histories, (history) => {
          this.loadChatFromHistory(history);
        }, this.plugin).open();
      } catch (error) {
        console.error("Failed to load chat histories:", error);
        new import_obsidian2.Notice("Failed to load chat histories", 2e3);
      }
    });
  }
  // Load all chat histories
  loadChatHistories() {
    return __async(this, null, function* () {
      try {
        const historyDir = this.plugin.settings.chatHistoryPath;
        const folderExists = yield this.ensureFolderExists(historyDir);
        if (!folderExists) {
          throw new Error(`Chat history directory does not exist: ${historyDir}`);
        }
        const files = yield this.plugin.app.vault.adapter.list(historyDir);
        const histories = [];
        for (const file of files.files) {
          if (file.endsWith(".json")) {
            try {
              const content = yield this.plugin.app.vault.adapter.read(file);
              const historyData = JSON.parse(content);
              if (!historyData.requestId) {
                historyData.requestId = null;
              }
              const history = historyData;
              histories.push(history);
            } catch (error) {
              console.error(`Failed to read chat history ${file}:`, error);
            }
          }
        }
        return histories.sort((a, b) => b.date - a.date);
      } catch (error) {
        return this.handleHistoryError("load chat histories", error);
      }
    });
  }
  // Load a specific chat history
  loadChatFromHistory(history) {
    if (this.messages.length > 0) {
      this.saveChatHistory();
    }
    this.clearChat();
    this.conversationId = history.id;
    this.messages = [...history.messages];
    if (history.requestId) {
      this.requestId = history.requestId;
      this.plugin.requestId = history.requestId;
    }
    this.renderChatHistory();
    new import_obsidian2.Notice(`Loaded chat: ${history.title}`, 2e3);
  }
  // Fix the renderChatHistory method in ChatView
  renderChatHistory() {
    if (!this.messagesContainer) return;
    this.messagesContainer.empty();
    for (const message of this.messages) {
      const messageEl = this.messagesContainer.createDiv({
        cls: `message ${message.role}-message`
      });
      const contentDiv = messageEl.createDiv({ cls: "message-content" });
      if (message.role === "assistant") {
        MarkdownRenderer.renderMarkdown(message.content, contentDiv, "", this.plugin);
        const actionContainer = messageEl.createDiv({ cls: "message-actions hover-only" });
        const copyButton = actionContainer.createEl("button", {
          cls: "message-action-button copy-button",
          attr: { "aria-label": "Copy message" }
        });
        (0, import_obsidian2.setIcon)(copyButton, "copy");
        copyButton.onclick = () => __async(this, null, function* () {
          try {
            yield navigator.clipboard.writeText(message.content);
            new import_obsidian2.Notice("Copied to clipboard", 2e3);
          } catch (err) {
            console.error("Failed to copy content:", err);
            new import_obsidian2.Notice("Failed to copy content", 2e3);
          }
        });
        const insertButton = actionContainer.createEl("button", {
          cls: "message-action-button insert-button",
          attr: { "aria-label": "Insert into editor" }
        });
        (0, import_obsidian2.setIcon)(insertButton, "plus");
        insertButton.onclick = () => {
          const activeLeaf = this.app.workspace.activeLeaf;
          if (!activeLeaf) {
            new import_obsidian2.Notice("Please open a markdown file first");
            return;
          }
          const view = activeLeaf.view;
          if (!(view instanceof import_obsidian2.MarkdownView)) {
            new import_obsidian2.Notice("Please open a markdown file first");
            return;
          }
          const editor = view.editor;
          const cursor = editor.getCursor();
          editor.replaceRange(message.content + "\n", cursor);
          editor.focus();
          new import_obsidian2.Notice("Content inserted into editor", 2e3);
        };
        const applyButton = actionContainer.createEl("button", {
          cls: "message-action-button apply-button",
          attr: { "aria-label": "Apply changes to original text" }
        });
        (0, import_obsidian2.setIcon)(applyButton, "check");
        applyButton.onclick = () => {
          const editor = this.getEditor();
          if (!editor) {
            new import_obsidian2.Notice("Please open a markdown file first");
            return;
          }
          let originalText = "";
          let isSelection = false;
          if (editor.somethingSelected()) {
            originalText = editor.getSelection();
            isSelection = true;
          } else {
            originalText = editor.getValue();
          }
          new PolishResultModal(this.plugin.app, this.plugin, originalText, message.content, (updatedContent) => {
            if (editor) {
              if (isSelection) {
                editor.replaceSelection(updatedContent);
              } else {
                editor.setValue(updatedContent);
              }
              new import_obsidian2.Notice("Changes applied to text!", 2e3);
            }
          }).open();
        };
      } else {
        contentDiv.setText(message.content);
      }
    }
    if (this.messagesContainer.scrollHeight) {
      this.messagesContainer.scrollTo({
        top: this.messagesContainer.scrollHeight,
        behavior: "smooth"
      });
    }
  }
  startNewChat() {
    return __async(this, null, function* () {
      this.isEndingConversation = true;
      if (this.messages.length > 0) {
        yield this.saveChatHistory();
      }
      this.clearChat();
      this.conversationId = null;
      this.requestId = crypto.randomUUID();
      this.plugin.requestId = this.requestId;
      new import_obsidian2.Notice("Started new chat", 2e3);
    });
  }
  // Update shouldSaveHistory to include a check for ending a conversation
  shouldSaveHistory() {
    if (this.isEndingConversation) {
      this.isEndingConversation = false;
      return true;
    }
    if (this.messages.length % 5 === 0 && this.messages.length > 0) {
      return true;
    }
    const lastSaveTime = this.lastHistorySave || 0;
    const TEN_MINUTES = 10 * 60 * 1e3;
    if (this.messages.length > 0 && Date.now() - lastSaveTime > TEN_MINUTES) {
      return true;
    }
    return false;
  }
  // Add this method to improve error handling for chat history operations
  handleHistoryError(operation, error) {
    console.error(`Error during ${operation}:`, error);
    let errorMessage = `Failed to ${operation}`;
    if (error instanceof Error) {
      if (error.message.includes("ENOENT") || error.message.includes("not found")) {
        errorMessage = `Chat history directory not found. Please check your settings.`;
      } else if (error.message.includes("permission")) {
        errorMessage = `Permission denied. Cannot access chat history files.`;
      } else if (error.message.includes("JSON")) {
        errorMessage = `Invalid chat history file format.`;
      }
    }
    new import_obsidian2.Notice(errorMessage, 3e3);
    switch (operation) {
      case "load chat histories":
        return [];
      case "save chat history":
      case "delete chat history":
      default:
        return false;
    }
  }
};

// src/main.ts
var EMBEDDING_MODELS = {
  "embedding-2": { maxTokens: 512, dimensions: null },
  "embedding-3": { maxTokens: 3072, dimensions: 1024 }
};
var DEFAULT_SETTINGS = {
  apiKey: "",
  model: "gpt-4",
  provider: "openai",
  embeddingModel: "embedding-3",
  embeddingDimensions: 1024,
  knowledgeBasePath: "AI_KnowledgeBase",
  promptOrganize: 'Please organize the content of the following article logically, following an introduction-body-conclusion structure. Use Markdown format, ensuring a smooth flow between sections. Output in the same language as the input text:\n1. Use `#` and `##` for main and secondary headings, marking primary sections and sub-sections, respectively.\n2. If appropriate, divide content into list form or use block quotes (`>`) to present specific points.\n3. Avoid repetitive content, highlight key information, and ensure the article structure is clearer and easier to read.\n4. Summarize the core points of the article in the conclusion.\n5. Do not include any lines that start with "=".\nHere is the content that needs to be organized:',
  promptCheckGrammar: "Please check the grammar, typos, and punctuation in the following text. Never delete any content, and provide the corrected text in the same language. For any errors in the original text, please list them at the end of the corrected version:",
  promptGenerateContent: "Generate content based on the following prompt, maintaining the same language as the prompt: ",
  promptDialogue: "Engage in a Socratic dialogue based on the following text, using the same language as the input: ",
  chatModel: "glm-4-air",
  promptSummary: `Analyze and summarize the following documents in the same language as the source documents:

1. Concise Summary: Synthesize the main content and key information
2. Document Insights: List key insights and important information from each document
3. Document Connections: Analyze logical relationships and connections between documents
4. References: Use numbers [n] to cite sources, using Obsidian link syntax [[filename]]

Guidelines:
- Maintain professionalism and logical flow
- Highlight important information and key concepts
- Ensure accurate citations and correct link format
- Use clear hierarchical structure for content presentation
- Use proper Markdown formatting for better readability`,
  customFunctions: [],
  functions: [
    {
      name: "Organize",
      icon: "file-text",
      prompt: 'Please organize the content of the following article logically, following an introduction-body-conclusion structure. Use Markdown format, ensuring a smooth flow between sections. Output in the same language as the input text:\n1. Use `#` and `##` for main and secondary headings, marking primary sections and sub-sections, respectively.\n2. If appropriate, divide content into list form or use block quotes (`>`) to present specific points.\n3. Avoid repetitive content, highlight key information, and ensure the article structure is clearer and easier to read.\n4. Summarize the core points of the article in the conclusion.\n5. Do not include any lines that start with "=".\nHere is the content that needs to be organized:',
      tooltip: "Organize text structure",
      isBuiltIn: true
    },
    {
      name: "Grammar",
      icon: "check-square",
      prompt: "Please check the grammar, typos, and punctuation in the following text. Never delete any content, and provide the corrected text in the same language. For any errors in the original text, please list them at the end of the corrected version:",
      tooltip: "Check grammar and spelling",
      isBuiltIn: true
    },
    {
      name: "Generate",
      icon: "sparkles",
      prompt: "Generate content based on the following prompt, maintaining the same language as the prompt: ",
      tooltip: "Generate content",
      isBuiltIn: true
    },
    {
      name: "Dialogue",
      icon: "message-circle",
      prompt: "Engage in a Socratic dialogue based on the following text, using the same language as the input: ",
      tooltip: "Start a dialogue",
      isBuiltIn: true
    },
    {
      name: "Summarize",
      icon: "bookmark",
      prompt: `Analyze and summarize the following documents in the same language as the source documents:

1. Concise Summary: Synthesize the main content and key information
2. Document Insights: List key insights and important information from each document
3. Document Connections: Analyze logical relationships and connections between documents
4. References: Use numbers [n] to cite sources, using Obsidian link syntax [[filename]]

Guidelines:
- Maintain professionalism and logical flow
- Highlight important information and key concepts
- Ensure accurate citations and correct link format
- Use clear hierarchical structure for content presentation
- Use proper Markdown formatting for better readability`,
      tooltip: "Summarize content",
      isBuiltIn: true
    },
    {
      name: "Polish",
      icon: "bird",
      prompt: `Please polish and refine the following text to improve clarity, flow, and style while preserving the original meaning and language. Enhance the expression, eliminate redundancies, and make it more engaging. Return the polished version only, without explanations:`,
      tooltip: "Polish and refine text",
      isBuiltIn: true
    }
  ],
  chatHistoryPath: "AI_ChatHistory",
  editorModeEnabled: true
};
var MODEL_TOKEN_LIMITS = {
  "gpt-3.5-turbo": 4096,
  "gpt-4": 8192,
  "gpt-4-turbo": 8192,
  "text-davinci-003": 4096,
  "GLM-3-Turbo": 8192,
  "GLM-4": 32768,
  "GLM-4-Air": 8192,
  "GLM-4-Long": 32768
};
function encryptString(text, salt) {
  try {
    const textToChars = (text2) => text2.split("").map((c) => c.charCodeAt(0));
    const byteHex = (n) => ("0" + Number(n).toString(16)).substr(-2);
    const applySaltToChar = (code) => textToChars(salt).reduce((a, b) => a ^ b, code);
    return text.split("").map((c) => c.charCodeAt(0)).map(applySaltToChar).map(byteHex).join("");
  } catch (e) {
    console.error("Encryption error:", e);
    return "";
  }
}
function decryptString(encoded, salt) {
  var _a;
  try {
    const textToChars = (text) => text.split("").map((c) => c.charCodeAt(0));
    const applySaltToChar = (code) => textToChars(salt).reduce((a, b) => a ^ b, code);
    return ((_a = encoded.match(/.{1,2}/g)) == null ? void 0 : _a.map((hex) => parseInt(hex, 16)).map(applySaltToChar).map((charCode) => String.fromCharCode(charCode)).join("")) || encoded;
  } catch (e) {
    console.error("Decryption failed:", e);
    return encoded;
  }
}
var ZHIPUAI_MODELS = {
  CHAT: {
    "GLM-3-Turbo": { maxTokens: 32e3, description: "Fast, efficient for general tasks" },
    "GLM-4": { maxTokens: 128e3, description: "Advanced reasoning and analysis" },
    "GLM-4-Air": { maxTokens: 128e3, description: "Advanced reasoning and analysis", isAIR: true },
    "GLM-4-Long": { maxTokens: 128e3, description: "Long context support" }
  },
  EMBEDDING: {
    "embedding-2": { maxTokens: 512, dimensions: null },
    "embedding-3": { maxTokens: 3072, dimensions: 1024 }
  }
};
var AIPilot = class extends import_obsidian3.Plugin {
  constructor(app, manifest) {
    super(app, manifest);
    this.requestId = null;
    this.salt = "AIPilot-v1";
    this.lastApiCall = 0;
    this.MIN_API_INTERVAL = 100;
    // 100ms between calls
    this.embeddingCache = /* @__PURE__ */ new Map();
    this.CACHE_DURATION = 1e3 * 60 * 60;
    // 1 hour
    this.currentInput = null;
    this.app = app;
  }
  onload() {
    return __async(this, null, function* () {
      yield this.loadSettings();
      this.loadStyles();
      this.addSettingTab(new AITextSettingTab(this.app, this));
      this.registerView(
        VIEW_TYPE_CHAT,
        (leaf) => new ChatView(leaf, this)
      );
      this.addCommand({
        id: "open-chat-view",
        name: "Open AI Chat",
        callback: () => {
          this.activateView();
        }
      });
      this.addRibbonIcon("message-square", "Open AI Chat", () => {
        this.activateView();
      });
      this.addRibbonIcon("bird", "Polish Text", (evt) => {
        const mdView = this.app.workspace.getActiveViewOfType(import_obsidian3.MarkdownView);
        if (mdView) {
          this.polishText(mdView.editor);
        } else {
          new import_obsidian3.Notice("No active editor found.");
        }
      });
      this.addRibbonIcon("eraser", "Clean Polish Markup", (evt) => {
        const mdView = this.app.workspace.getActiveViewOfType(import_obsidian3.MarkdownView);
        if (mdView) {
          this.cleanPolishMarkup(mdView.editor);
        } else {
          new import_obsidian3.Notice("No active editor found.");
        }
      });
      this.addCommands();
      this.initializeRequestId();
      this.addRibbonIcon("search", "Search Knowledge Base", () => {
        this.searchKnowledgeBase();
      });
    });
  }
  loadStyles() {
    const styleEl = document.createElement("style");
    styleEl.id = "aipilot-styles";
    styleEl.textContent = styles_default;
    document.head.appendChild(styleEl);
  }
  onunload() {
    const styleEl = document.getElementById("aipilot-styles");
    if (styleEl) styleEl.remove();
  }
  loadSettings() {
    return __async(this, null, function* () {
      const data = yield this.loadData();
      this.settings = Object.assign({}, DEFAULT_SETTINGS, data);
      if (this.settings.apiKey) {
        this.settings.apiKey = decryptString(this.settings.apiKey, this.salt);
      }
    });
  }
  saveSettings() {
    return __async(this, null, function* () {
      const dataToSave = __spreadValues({}, this.settings);
      if (dataToSave.apiKey) {
        dataToSave.apiKey = encryptString(dataToSave.apiKey, this.salt);
      }
      yield this.saveData(dataToSave);
    });
  }
  initializeRequestId() {
    if (!this.requestId) {
      this.requestId = crypto.randomUUID();
    }
  }
  showFeatureModal() {
    new FeatureSelectionModal(this.app, this).open();
  }
  addCommands() {
    this.addCommand({
      id: "organize-text",
      name: "Organize text",
      editorCallback: (editor, view) => this.organizeText(editor)
    });
    this.addCommand({
      id: "check-grammar",
      name: "Check grammar",
      editorCallback: (editor, view) => this.checkGrammar(editor)
    });
    this.addCommand({
      id: "generate-content",
      name: "Generate content",
      editorCallback: (editor) => __async(this, null, function* () {
        const content = editor.getValue();
        const result = yield this.generateAIContent(content);
        if (result) {
          editor.setValue(result);
        }
      })
    });
    this.addCommand({
      id: "engage-in-dialogue",
      name: "Engage in Dialogue",
      editorCallback: (editor, view) => this.engageInDialogue(editor)
    });
    this.addCommand({
      id: "polish-text",
      name: "Polish Text",
      editorCallback: (editor, view) => this.polishText(editor)
    });
    this.addCommand({
      id: "clean-polish-markup",
      name: "Clean Polish Markup",
      editorCallback: (editor, view) => this.cleanPolishMarkup(editor),
      hotkeys: [{ modifiers: ["Mod", "Shift"], key: "p" }]
    });
    this.addCommand({
      id: "custom-prompt",
      name: "Custom Prompt",
      editorCallback: (editor, view) => this.handleCustomPrompt(editor)
    });
    this.addCommand({
      id: "search-knowledge-base",
      name: "Search Knowledge Base",
      callback: () => __async(this, null, function* () {
        const modal = new SearchPromptModal(this.app);
        const query = yield modal.openAndGetValue();
        if (!query) return;
        const loadingModal = new LoadingModal2(this.app, true);
        loadingModal.open();
        try {
          const files = yield this.getKnowledgeBaseNotes();
          const results = [];
          let processed = 0;
          for (const file of files) {
            const content = yield this.app.vault.read(file);
            const similarity = this.calculateSimilarity(query, content);
            results.push({ file, similarity });
            processed++;
            loadingModal.setProgress(processed / files.length, processed, files.length);
          }
          const topResults = results.sort((a, b) => b.similarity - a.similarity).slice(0, 5);
          loadingModal.close();
          new SearchResultsModal(this.app, topResults).open();
        } catch (error) {
          new import_obsidian3.Notice("Error searching knowledge base: " + error.message);
          loadingModal.close();
        }
      })
    });
  }
  // Approximate token estimation function
  estimateTokenCount(text) {
    const englishLength = text.replace(/[\u4e00-\u9fff]/g, "").length;
    const chineseLength = text.length - englishLength;
    return Math.ceil(englishLength / 4 + chineseLength / 2);
  }
  callAI(content, promptPrefix = "") {
    return __async(this, null, function* () {
      const { model } = this.settings;
      const maxTokens = MODEL_TOKEN_LIMITS[model] || 4096;
      let maxTokensForContent = maxTokens - this.estimateTokenCount(promptPrefix);
      const MIN_TOKENS_FOR_CONTENT = 500;
      if (maxTokensForContent < MIN_TOKENS_FOR_CONTENT) {
        maxTokensForContent = MIN_TOKENS_FOR_CONTENT;
      }
      const tokenCount = this.estimateTokenCount(content);
      if (tokenCount > maxTokensForContent) {
        const chunks = this.chunkContent(content, maxTokensForContent);
        const results = [];
        new import_obsidian3.Notice(`The text is too long and will be processed in ${chunks.length} parts.`);
        for (const chunk of chunks) {
          const result = yield this.callAIChunk(chunk, promptPrefix);
          results.push(result.trim());
        }
        return results.join("\n\n");
      } else {
        return yield this.callAIChunk(content, promptPrefix);
      }
    });
  }
  callAIChunk(content, promptPrefix) {
    return __async(this, null, function* () {
      var _a, _b, _c, _d, _e, _f, _g;
      const { apiKey, model, provider } = this.settings;
      let url = "";
      let data = {};
      const prompt = `${promptPrefix}${content}

Note: This is part of a larger text. Ensure continuity with the previous sections.`;
      const chatModels = ["gpt-4", "gpt-4-turbo", "gpt-3.5-turbo", "GLM-3-Turbo", "GLM-4", "GLM-4-Air", "GLM-4-Long"];
      if (provider === "openai") {
        if (chatModels.includes(model)) {
          url = "https://api.openai.com/v1/chat/completions";
          data = {
            model,
            messages: [{ role: "user", content: prompt }],
            request_id: this.requestId
          };
        } else {
          url = "https://api.openai.com/v1/completions";
          data = {
            model,
            prompt,
            max_tokens: 1e3,
            request_id: this.requestId
          };
        }
      } else if (provider === "zhipuai") {
        url = "https://open.bigmodel.cn/api/paas/v4/chat/completions";
        data = {
          model,
          messages: [{ role: "user", content: prompt }],
          stream: false,
          request_id: this.requestId
        };
      } else if (provider === "groq") {
        url = "https://api.groq.com/openai/v1/chat/completions";
        data = {
          model,
          messages: [{ role: "user", content: prompt }],
          request_id: this.requestId
        };
      }
      try {
        const response = yield (0, import_obsidian3.requestUrl)({
          url,
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "Authorization": `Bearer ${apiKey}`
          },
          body: JSON.stringify(data),
          contentType: "application/json"
        });
        const responseData = response.json;
        if (provider === "openai" && chatModels.includes(model)) {
          return ((_b = (_a = responseData.choices[0]) == null ? void 0 : _a.message) == null ? void 0 : _b.content) || "No response";
        } else if (provider === "openai") {
          return ((_c = responseData.choices[0]) == null ? void 0 : _c.text) || "No response";
        } else {
          return ((_e = (_d = responseData.choices[0]) == null ? void 0 : _d.message) == null ? void 0 : _e.content) || "No response";
        }
      } catch (error) {
        console.error("Error calling AI:", error);
        if (((_f = error.response) == null ? void 0 : _f.status) === 401) {
          new import_obsidian3.Notice("Invalid API key. Please check your settings.");
        } else if (((_g = error.response) == null ? void 0 : _g.status) === 429) {
          new import_obsidian3.Notice("Rate limit exceeded. Please try again later.");
        } else {
          new import_obsidian3.Notice("Error: " + (error.message || "Unknown error occurred"));
        }
        return "Error fetching AI response";
      }
    });
  }
  chunkContent(content, maxTokens) {
    const paragraphs = content.split(/\n\s*\n/);
    const chunks = [];
    let currentChunk = "";
    let currentTokens = 0;
    for (let i = 0; i < paragraphs.length; i++) {
      const paragraph2 = paragraphs[i];
      const paragraphTokens = this.estimateTokenCount(paragraph2);
      if (currentTokens + paragraphTokens > maxTokens) {
        if (currentChunk) {
          chunks.push(currentChunk.trim());
          currentChunk = "";
          currentTokens = 0;
        }
      }
      currentChunk += paragraph2 + "\n\n";
      currentTokens += paragraphTokens;
    }
    if (currentChunk) {
      chunks.push(currentChunk.trim());
    }
    return chunks;
  }
  callAIChat(messages, onUpdate) {
    return __async(this, null, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x;
      const { apiKey, model, provider } = this.settings;
      const maxTokens = MODEL_TOKEN_LIMITS[model] || 4096;
      const MAX_RETRIES = 3;
      const RETRY_DELAY = 1e3;
      let totalTokens = 0;
      for (const msg of messages) {
        totalTokens += this.estimateTokenCount(msg.content);
      }
      if (totalTokens > maxTokens) {
        messages = this.trimMessages(messages, maxTokens);
      }
      let url = "";
      let data = {};
      if (provider === "openai") {
        url = "https://api.openai.com/v1/chat/completions";
        data = {
          model,
          messages,
          request_id: this.requestId,
          stream: true
        };
      } else if (provider === "zhipuai") {
        url = "https://open.bigmodel.cn/api/paas/v4/chat/completions";
        data = {
          model,
          messages,
          stream: true,
          request_id: this.requestId
        };
      } else if (provider === "groq") {
        url = "https://api.groq.com/openai/v1/chat/completions";
        data = {
          model,
          messages,
          request_id: this.requestId,
          stream: true
        };
      }
      let retryCount = 0;
      while (retryCount < MAX_RETRIES) {
        try {
          const response = yield fetch(url, {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              "Authorization": `Bearer ${apiKey}`
            },
            body: JSON.stringify(data)
          });
          if (!response.ok) {
            const errorDetails = yield response.text().catch(() => "");
            const errorStatus = response.status;
            if (errorStatus === 400) {
              const hasImageContent = messages.some((msg) => {
                const content = msg.content || "";
                return content.includes("![") || content.includes("<img") || content.includes("data:image/") || content.includes("http://") && (content.includes(".png") || content.includes(".jpg") || content.includes(".jpeg") || content.includes(".gif"));
              });
              if (hasImageContent) {
                throw new Error(`The request contains images or unsupported content. Please remove images and try again.`);
              }
            }
            throw new Error(`HTTP error! status: ${errorStatus} ${errorDetails ? "- " + errorDetails.substring(0, 100) : ""}`);
          }
          if (!response.body) {
            throw new Error("Response body is null");
          }
          const reader = response.body.getReader();
          const decoder = new TextDecoder();
          let fullContent = "";
          let buffer = "";
          let lastChunkTime = Date.now();
          const TIMEOUT = 3e4;
          try {
            while (true) {
              const { value, done } = yield reader.read();
              if (done) break;
              const now = Date.now();
              if (now - lastChunkTime > TIMEOUT) {
                throw new Error("Stream timeout");
              }
              lastChunkTime = now;
              buffer += decoder.decode(value, { stream: true });
              const lines = buffer.split("\n");
              buffer = lines.pop() || "";
              for (const line of lines) {
                const trimmedLine = line.trim();
                if (!trimmedLine || trimmedLine === "data: [DONE]") continue;
                if (trimmedLine.startsWith("data: ")) {
                  try {
                    const data2 = trimmedLine.slice(6);
                    if (data2 === "[DONE]") continue;
                    const json = JSON.parse(data2);
                    let content = "";
                    if (provider === "openai") {
                      content = ((_c = (_b = (_a = json.choices) == null ? void 0 : _a[0]) == null ? void 0 : _b.delta) == null ? void 0 : _c.content) || "";
                    } else if (provider === "zhipuai") {
                      content = ((_f = (_e = (_d = json.choices) == null ? void 0 : _d[0]) == null ? void 0 : _e.delta) == null ? void 0 : _f.content) || ((_i = (_h = (_g = json.choices) == null ? void 0 : _g[0]) == null ? void 0 : _h.message) == null ? void 0 : _i.content) || "";
                    } else if (provider === "groq") {
                      content = ((_l = (_k = (_j = json.choices) == null ? void 0 : _j[0]) == null ? void 0 : _k.delta) == null ? void 0 : _l.content) || "";
                    }
                    if (content) {
                      fullContent += content;
                      if (onUpdate) {
                        try {
                          yield onUpdate(content);
                        } catch (e) {
                          console.warn("Error in onUpdate callback:", e);
                        }
                      }
                    }
                  } catch (e) {
                    console.warn("Error parsing streaming response:", e, trimmedLine);
                  }
                }
              }
            }
            if (buffer) {
              const trimmedBuffer = buffer.trim();
              if (trimmedBuffer && trimmedBuffer !== "data: [DONE]" && trimmedBuffer.startsWith("data: ")) {
                try {
                  const data2 = trimmedBuffer.slice(6);
                  if (data2 !== "[DONE]") {
                    const json = JSON.parse(data2);
                    let content = "";
                    if (provider === "openai") {
                      content = ((_o = (_n = (_m = json.choices) == null ? void 0 : _m[0]) == null ? void 0 : _n.delta) == null ? void 0 : _o.content) || "";
                    } else if (provider === "zhipuai") {
                      content = ((_r = (_q = (_p = json.choices) == null ? void 0 : _p[0]) == null ? void 0 : _q.delta) == null ? void 0 : _r.content) || ((_u = (_t = (_s = json.choices) == null ? void 0 : _s[0]) == null ? void 0 : _t.message) == null ? void 0 : _u.content) || "";
                    } else if (provider === "groq") {
                      content = ((_x = (_w = (_v = json.choices) == null ? void 0 : _v[0]) == null ? void 0 : _w.delta) == null ? void 0 : _x.content) || "";
                    }
                    if (content) {
                      fullContent += content;
                      if (onUpdate) {
                        try {
                          yield onUpdate(content);
                        } catch (e) {
                          console.warn("Error in onUpdate callback:", e);
                        }
                      }
                    }
                  }
                } catch (e) {
                  console.warn("Error parsing final buffer:", e);
                }
              }
            }
            return fullContent || "No response";
          } finally {
            reader.releaseLock();
          }
        } catch (error) {
          console.error(`Error calling AI (attempt ${retryCount + 1}/${MAX_RETRIES}):`, error);
          if (retryCount === MAX_RETRIES - 1) {
            if (error.status === 401) {
              new import_obsidian3.Notice("Invalid API key. Please check your settings.");
            } else if (error.status === 429) {
              new import_obsidian3.Notice("Rate limit exceeded. Please try again later.");
            } else {
              new import_obsidian3.Notice("Error: " + (error.message || "Unknown error occurred"));
            }
            throw error;
          }
          yield new Promise((resolve) => setTimeout(resolve, RETRY_DELAY));
          retryCount++;
        }
      }
      throw new Error("Max retries exceeded");
    });
  }
  trimMessages(messages, maxTokens) {
    while (this.estimateTokenCount(JSON.stringify(messages)) > maxTokens) {
      messages.shift();
    }
    return messages;
  }
  organizeText(editor) {
    return __async(this, null, function* () {
      if (!editor) {
        const mdView = this.app.workspace.getActiveViewOfType(import_obsidian3.MarkdownView);
        if (mdView) {
          editor = mdView.editor;
        } else {
          new import_obsidian3.Notice("No active editor found.");
          return;
        }
      }
      this.initializeRequestId();
      const selectedText = editor.getSelection();
      if (!selectedText) {
        new ConfirmModal2(this.app, "No text selected. Apply organization to the entire document?", () => __async(this, null, function* () {
          const content = editor.getValue();
          yield this.processOrganize(content, editor);
        })).open();
      } else {
        yield this.processOrganize(selectedText, editor);
      }
    });
  }
  processOrganize(content, editor) {
    return __async(this, null, function* () {
      const loadingModal = new LoadingModal2(this.app, true);
      loadingModal.open();
      const prompt = `${this.settings.promptOrganize}${content}

Note: This is part of a larger text. Ensure continuity with the previous sections.`;
      const organizedText = yield this.callAI(content, prompt);
      loadingModal.close();
      new AIContentModal(this.app, this, organizedText, editor, (updatedContent) => {
        if (editor.somethingSelected()) {
          editor.replaceSelection(updatedContent);
        } else {
          editor.setValue(updatedContent);
        }
      }).open();
    });
  }
  checkGrammar(editor) {
    return __async(this, null, function* () {
      if (!editor) {
        const mdView = this.app.workspace.getActiveViewOfType(import_obsidian3.MarkdownView);
        if (mdView) {
          editor = mdView.editor;
        } else {
          new import_obsidian3.Notice("No active editor found.");
          return;
        }
      }
      this.initializeRequestId();
      const selectedText = editor.getSelection();
      if (!selectedText) {
        new ConfirmModal2(this.app, "No text selected. Apply grammar check to the entire document?", () => __async(this, null, function* () {
          const content = editor.getValue();
          yield this.processGrammar(content, editor);
        })).open();
      } else {
        yield this.processGrammar(selectedText, editor);
      }
    });
  }
  processGrammar(content, editor) {
    return __async(this, null, function* () {
      const loadingModal = new LoadingModal2(this.app, true);
      loadingModal.open();
      const grammarCheckedText = yield this.callAI(content, this.settings.promptCheckGrammar);
      loadingModal.close();
      new AIContentModal(this.app, this, grammarCheckedText, editor, (updatedContent) => {
        if (editor.somethingSelected()) {
          editor.replaceSelection(updatedContent);
        } else {
          editor.setValue(updatedContent);
        }
      }).open();
    });
  }
  generateAIContent(prompt) {
    return __async(this, null, function* () {
      const activeView = this.app.workspace.getActiveViewOfType(import_obsidian3.MarkdownView);
      if (!activeView) {
        throw new Error("No active markdown file");
      }
      const editor = activeView.editor;
      let selectedText = editor.getSelection();
      if (!selectedText && !prompt) {
        throw new Error("No text selected and no prompt provided");
      }
      const textToProcess = prompt || selectedText;
      try {
        const response = yield this.getAIResponse(textToProcess);
        return response;
      } catch (error) {
        console.error("Error generating AI content:", error);
        throw error;
      }
    });
  }
  getAIResponse(message, history) {
    return __async(this, null, function* () {
      if (history) {
        return this.callAIChat([...history, { role: "user", content: message }]);
      }
      return this.callAI(message);
    });
  }
  engageInDialogue(editor) {
    return __async(this, null, function* () {
      if (!editor) {
        const mdView = this.app.workspace.getActiveViewOfType(import_obsidian3.MarkdownView);
        if (mdView) {
          editor = mdView.editor;
        } else {
          new import_obsidian3.Notice("No active editor found.");
          return;
        }
      }
      this.initializeRequestId();
      const selectedText = editor.getSelection();
      if (!selectedText) {
        new ConfirmModal2(this.app, "No text selected. Apply dialogue to the entire document?", () => __async(this, null, function* () {
          const content = editor.getValue();
          yield this.processDialogue(content, editor);
        })).open();
      } else {
        yield this.processDialogue(selectedText, editor);
      }
    });
  }
  processDialogue(content, editor) {
    return __async(this, null, function* () {
      const loadingModal = new LoadingModal2(this.app, true);
      loadingModal.open();
      const dialoguePrompt = `${this.settings.promptDialogue}${content}`;
      const aiResponse = yield this.callAI(dialoguePrompt);
      loadingModal.close();
      const history = [
        { role: "user", content },
        { role: "assistant", content: aiResponse }
      ];
      new ChatModal(this.app, this, history, editor).open();
    });
  }
  handleCustomPrompt(editor) {
    return __async(this, null, function* () {
      if (!editor) {
        const mdView = this.app.workspace.getActiveViewOfType(import_obsidian3.MarkdownView);
        if (mdView) {
          editor = mdView.editor;
        } else {
          new import_obsidian3.Notice("No active editor found.");
          return;
        }
      }
      this.initializeRequestId();
      const selectedText = editor.getSelection();
      let contentToProcess;
      new CustomPromptInputModal(this.app, (inputPrompt) => __async(this, null, function* () {
        if (!inputPrompt) {
          new import_obsidian3.Notice("No prompt entered.", 2e3);
          return;
        }
        if (selectedText) {
          contentToProcess = `${inputPrompt} ${selectedText}`;
        } else {
          new ConfirmModal2(this.app, "No text selected. Apply organization to the entire document?", () => __async(this, null, function* () {
            contentToProcess = editor.getValue();
          })).open();
        }
        yield this.processCustomPrompt(contentToProcess, editor);
      })).open();
    });
  }
  processCustomPrompt(content, editor) {
    return __async(this, null, function* () {
      const loadingModal = new LoadingModal2(this.app, true);
      loadingModal.open();
      const customResponse = yield this.callAI(content);
      loadingModal.close();
      new AIContentModal(this.app, this, customResponse, editor, (updatedContent) => {
        if (editor.somethingSelected()) {
          editor.replaceSelection(updatedContent);
        } else {
          editor.setValue(updatedContent);
        }
      }).open();
    });
  }
  // 获取知识库文件
  getKnowledgeBaseNotes(selectedDir) {
    return __async(this, null, function* () {
      const path = this.settings.knowledgeBasePath;
      let files = [];
      if (!path) {
        const getAllFiles = (folder) => {
          for (const child of folder.children) {
            if (child instanceof import_obsidian3.TFile && child.extension === "md") {
              files.push(child);
            } else if (child instanceof import_obsidian3.TFolder) {
              getAllFiles(child);
            }
          }
        };
        const rootFolder = this.app.vault.getRoot();
        getAllFiles(rootFolder);
      } else {
        const folder = this.app.vault.getAbstractFileByPath(path);
        if (!folder || !(folder instanceof import_obsidian3.TFolder)) {
          console.log("Knowledge base folder not found:", path);
          return [];
        }
        const searchFolder = (folder2) => {
          for (const child of folder2.children) {
            if (child instanceof import_obsidian3.TFile && child.extension === "md") {
              files.push(child);
            } else if (child instanceof import_obsidian3.TFolder) {
              searchFolder(child);
            }
          }
        };
        searchFolder(folder);
      }
      if (selectedDir) {
        files = files.filter((file) => file.path.startsWith(selectedDir));
      }
      return files;
    });
  }
  // 计算文本相似度
  calculateSimilarity(query, content) {
    const queryWords = new Set(query.split(/\s+/).filter((word) => word.length > 2));
    const contentWords = new Set(content.split(/\s+/).filter((word) => word.length > 2));
    let matches = 0;
    for (const word of queryWords) {
      if (contentWords.has(word)) matches++;
    }
    return matches / Math.max(queryWords.size, 1);
  }
  // 获取文本向量
  getEmbedding(text) {
    return __async(this, null, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _i;
      const { provider, apiKey, embeddingModel } = this.settings;
      try {
        if (provider === "zhipuai") {
          if (!(text == null ? void 0 : text.trim())) {
            throw new Error("Empty text cannot be embedded");
          }
          const MAX_CHARS = 3e3;
          if (text.length > MAX_CHARS) {
            const truncated = text.substring(0, MAX_CHARS);
            const lastPeriod = truncated.lastIndexOf(".");
            const lastNewline = truncated.lastIndexOf("\n");
            const breakPoint = Math.max(lastPeriod, lastNewline);
            text = breakPoint > 0 ? truncated.substring(0, breakPoint + 1) : truncated;
          }
          const requestBody = {
            model: embeddingModel,
            input: text,
            dimensions: embeddingModel === "embedding-3" ? 1024 : void 0
          };
          console.log("ZhipuAI Embedding Request:", {
            url: "https://open.bigmodel.cn/api/paas/v4/embeddings",
            model: embeddingModel,
            textLength: text.length,
            requestBody
          });
          const response = yield (0, import_obsidian3.requestUrl)({
            url: "https://open.bigmodel.cn/api/paas/v4/embeddings",
            method: "POST",
            headers: {
              "Authorization": `Bearer ${apiKey}`,
              "Content-Type": "application/json"
            },
            body: JSON.stringify(requestBody)
          });
          console.log("ZhipuAI Embedding Response:", {
            status: response.status,
            statusText: response.status,
            responseBody: response.json
          });
          if (response.status !== 200) {
            const errorMessage = ((_b = (_a = response.json) == null ? void 0 : _a.error) == null ? void 0 : _b.message) || response.text;
            throw new Error(`API returned status ${response.status}: ${errorMessage}`);
          }
          if (!((_e = (_d = (_c = response.json) == null ? void 0 : _c.data) == null ? void 0 : _d[0]) == null ? void 0 : _e.embedding)) {
            console.error("Invalid API response:", response.json);
            throw new Error("Invalid embedding response from ZhipuAI");
          }
          return response.json.data[0].embedding;
        } else if (provider === "openai") {
          const response = yield this.rateLimitedRequest(() => __async(this, null, function* () {
            return yield (0, import_obsidian3.requestUrl)({
              url: "https://api.openai.com/v1/embeddings",
              method: "POST",
              headers: {
                "Authorization": `Bearer ${apiKey}`,
                "Content-Type": "application/json"
              },
              body: JSON.stringify({
                model: embeddingModel,
                input: text
              })
            });
          }));
          if (!((_g = (_f = response.json.data) == null ? void 0 : _f[0]) == null ? void 0 : _g.embedding)) {
            throw new Error("Invalid embedding response from OpenAI");
          }
          return response.json.data[0].embedding;
        } else if (provider === "groq") {
          const response = yield this.rateLimitedRequest(() => __async(this, null, function* () {
            return yield (0, import_obsidian3.requestUrl)({
              url: "https://api.groq.com/openai/v1/embeddings",
              method: "POST",
              headers: {
                "Authorization": `Bearer ${apiKey}`,
                "Content-Type": "application/json"
              },
              body: JSON.stringify({
                model: embeddingModel,
                input: text
              })
            });
          }));
          if (!((_i = (_h = response.json.data) == null ? void 0 : _h[0]) == null ? void 0 : _i.embedding)) {
            throw new Error("Invalid embedding response from Groq");
          }
          return response.json.data[0].embedding;
        }
        throw new Error("Unsupported provider for embeddings");
      } catch (error) {
        console.error("Error getting embedding:", error);
        throw error;
      }
    });
  }
  rateLimitedRequest(requestFn) {
    return __async(this, null, function* () {
      const now = Date.now();
      const timeSinceLastCall = now - this.lastApiCall;
      if (timeSinceLastCall < this.MIN_API_INTERVAL) {
        yield new Promise((resolve) => setTimeout(resolve, this.MIN_API_INTERVAL - timeSinceLastCall));
      }
      this.lastApiCall = Date.now();
      return requestFn();
    });
  }
  getCachedEmbedding(text) {
    return __async(this, null, function* () {
      const cached = this.embeddingCache.get(text);
      const now = Date.now();
      if (cached && now - cached.timestamp < this.CACHE_DURATION) {
        return cached.vector;
      }
      const vector = yield this.getEmbedding(text);
      this.embeddingCache.set(text, {
        vector,
        timestamp: now
      });
      return vector;
    });
  }
  activateView() {
    return __async(this, null, function* () {
      const workspace = this.app.workspace;
      let leaf = workspace.getLeavesOfType(VIEW_TYPE_CHAT)[0];
      if (!leaf) {
        const rightLeaf = workspace.getRightLeaf(false);
        if (!rightLeaf) return;
        leaf = rightLeaf;
        yield leaf.setViewState({
          type: VIEW_TYPE_CHAT,
          active: true
        });
      }
      workspace.revealLeaf(leaf);
    });
  }
  searchKnowledgeBase() {
    return __async(this, null, function* () {
      const modal = new SearchPromptModal(this.app);
      const query = yield modal.openAndGetValue();
      if (!query) return;
      const loadingModal = new LoadingModal2(this.app, true);
      loadingModal.open();
      try {
        const files = yield this.getKnowledgeBaseNotes();
        const results = [];
        let processed = 0;
        for (const file of files) {
          const content = yield this.app.vault.read(file);
          const similarity = this.calculateSimilarity(query, content);
          results.push({ file, similarity });
          processed++;
          loadingModal.setProgress(processed / files.length, processed, files.length);
        }
        const topResults = results.sort((a, b) => b.similarity - a.similarity).slice(0, 5);
        loadingModal.close();
        new SearchResultsModal(this.app, topResults).open();
      } catch (error) {
        new import_obsidian3.Notice("Error searching knowledge base: " + error.message);
        loadingModal.close();
      }
    });
  }
  handleSelection(editor) {
    return __async(this, null, function* () {
      const selectedText = editor.getSelection();
      if (!selectedText) return;
      const history = [
        { role: "user", content: selectedText },
        { role: "assistant", content: "I'll help you with that." }
      ];
      new ChatModal(this.app, this, history, editor).open();
    });
  }
  processFileReferences(message) {
    return __async(this, null, function* () {
      const matches = message.match(/@\[\[(.*?)\]\]/g);
      if (!matches) return message;
      let processedMessage = message;
      for (const match of matches) {
        const filePath = match.slice(3, -2);
        const file = this.app.vault.getAbstractFileByPath(filePath);
        if (file instanceof import_obsidian3.TFile) {
          try {
            const content = yield this.app.vault.read(file);
            processedMessage = processedMessage.replace(match, `

=== Content from ${filePath} ===
${content}
=== End of ${filePath} ===

`);
          } catch (error) {
            console.error(`Error reading file ${filePath}:`, error);
            new import_obsidian3.Notice(`Failed to read file ${filePath}`);
          }
        }
      }
      return processedMessage;
    });
  }
  getTopRelevantNotes(query, limit = 5) {
    return __async(this, null, function* () {
      const files = yield this.getKnowledgeBaseNotes();
      const results = [];
      for (const file of files) {
        try {
          const content = yield this.app.vault.read(file);
          const similarity = this.calculateSimilarity(query.toLowerCase(), content.toLowerCase());
          if (similarity > 0) {
            const snippet = this.getRelevantSnippet(content, query);
            results.push({ file, similarity, content: snippet });
          }
        } catch (error) {
          console.error(`Error processing file ${file.path}:`, error);
        }
      }
      return results.sort((a, b) => b.similarity - a.similarity).slice(0, limit);
    });
  }
  getRelevantSnippet(content, query, snippetLength = 300) {
    const lowerContent = content.toLowerCase();
    const lowerQuery = query.toLowerCase();
    const index = lowerContent.indexOf(lowerQuery);
    if (index === -1) {
      const queryWords = query.toLowerCase().split(/\s+/);
      for (const word of queryWords) {
        const wordIndex = lowerContent.indexOf(word);
        if (wordIndex !== -1) {
          return this.extractSnippet(content, wordIndex, snippetLength);
        }
      }
      return content.slice(0, snippetLength) + "...";
    }
    return this.extractSnippet(content, index, snippetLength);
  }
  extractSnippet(content, index, snippetLength) {
    const start = Math.max(0, index - snippetLength / 2);
    const end = Math.min(content.length, index + snippetLength / 2);
    let snippet = content.slice(start, end);
    if (start > 0) snippet = "..." + snippet;
    if (end < content.length) snippet = snippet + "...";
    return snippet;
  }
  renderMarkdown(content, container) {
    return __async(this, null, function* () {
      yield import_obsidian3.MarkdownRenderer.renderMarkdown(content, container, "", this);
    });
  }
  polishText(editor) {
    return __async(this, null, function* () {
      if (!editor) {
        const mdView = this.app.workspace.getActiveViewOfType(import_obsidian3.MarkdownView);
        if (mdView) {
          editor = mdView.editor;
        } else {
          new import_obsidian3.Notice("No active editor found.");
          return;
        }
      }
      this.initializeRequestId();
      const selectedText = editor.getSelection();
      if (!selectedText) {
        new ConfirmModal2(this.app, "No text selected. Apply polishing to the entire document?", () => __async(this, null, function* () {
          const content = editor.getValue();
          yield this.processPolish(content, editor);
        })).open();
      } else {
        yield this.processPolish(selectedText, editor);
      }
    });
  }
  processPolish(content, editor) {
    return __async(this, null, function* () {
      const loadingModal = new LoadingModal2(this.app, true);
      loadingModal.open();
      const polishFunc = this.settings.functions.find((f) => f.isBuiltIn && f.name === "Polish");
      const polishPrompt = polishFunc ? polishFunc.prompt : "Please polish and refine the following text:";
      const polishedText = yield this.callAI(content, polishPrompt);
      loadingModal.close();
      if (!editor.somethingSelected()) {
        const diffResult = this.generateDiffHtml(content, polishedText);
        editor.setValue(diffResult);
        new import_obsidian3.Notice("Polish results applied with diff markers. Use Ctrl+Shift+P (or Cmd+Shift+P) to remove all markup.", 7e3);
      } else {
        new PolishResultModal(this.app, this, content, polishedText, (updatedContent) => {
          editor.replaceSelection(updatedContent);
        }).open();
      }
    });
  }
  // Helper method to generate text with diff markers for direct editing
  generateDiffHtml(original, polished) {
    const originalLines = original.split("\n");
    const polishedLines = polished.split("\n");
    const result = [];
    const maxLength = Math.max(originalLines.length, polishedLines.length);
    for (let i = 0; i < maxLength; i++) {
      const originalLine = i < originalLines.length ? originalLines[i] : "";
      const polishedLine = i < polishedLines.length ? polishedLines[i] : "";
      if (originalLine === polishedLine) {
        result.push(polishedLine);
      } else if (originalLine.trim() === "") {
        result.push(`**${polishedLine}**`);
      } else if (polishedLine.trim() === "") {
        result.push(`~~${originalLine}~~`);
      } else {
        result.push(`~~${originalLine}~~
**${polishedLine}**`);
      }
    }
    return result.join("\n");
  }
  // Add this new method to clean Polish markup
  cleanPolishMarkup(editor) {
    return __async(this, null, function* () {
      if (!editor) return;
      const content = editor.getValue();
      let cleanedContent = content.replace(/~~([^~]*?)~~(\n)?/g, "");
      cleanedContent = cleanedContent.replace(/\*\*([^*]*?)\*\*/g, "$1");
      cleanedContent = cleanedContent.replace(/\n\n+/g, "\n\n");
      editor.setValue(cleanedContent);
      new import_obsidian3.Notice("Polish markup removed");
    });
  }
};
var CustomPromptInputModal = class extends import_obsidian3.Modal {
  constructor(app, onSubmit) {
    super(app);
    this.onSubmit = onSubmit;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("modal-content");
    contentEl.createEl("h2", { text: "Enter Your Custom Prompt" });
    const promptInput = contentEl.createEl("textarea", {
      placeholder: "Type your custom prompt here...",
      cls: "custom-prompt-input"
    });
    const buttonContainer = contentEl.createDiv({ cls: "button-container" });
    const submitBtn = buttonContainer.createEl("button", { text: "Submit" });
    const cancelBtn = buttonContainer.createEl("button", { text: "Cancel" });
    submitBtn.onclick = () => {
      const inputValue = promptInput.value.trim();
      if (inputValue) {
        this.onSubmit(inputValue);
        this.close();
      } else {
        new import_obsidian3.Notice("Please enter a prompt.");
      }
    };
    cancelBtn.onclick = () => {
      this.close();
    };
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var FeatureSelectionModal = class extends import_obsidian3.Modal {
  constructor(app, plugin) {
    super(app);
    this.plugin = plugin;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", { text: "Select AI Function" });
    const buttonContainer = contentEl.createDiv({ cls: "button-container" });
    const buttons = [
      { text: "Organize Text", action: () => this.plugin.organizeText() },
      { text: "Check Grammar", action: () => this.plugin.checkGrammar() },
      { text: "Generate Content", action: () => this.plugin.generateAIContent() },
      { text: "Engage in Dialogue", action: () => this.plugin.engageInDialogue() },
      { text: "Search Knowledge Base", action: () => __async(this, null, function* () {
        return yield this.plugin.searchKnowledgeBase();
      }) },
      { text: "Custom Prompt", action: () => this.plugin.handleCustomPrompt() }
    ];
    buttons.forEach(({ text, action }) => {
      const btn = buttonContainer.createEl("button", {
        text,
        cls: "feature-button"
      });
      btn.onclick = () => __async(this, null, function* () {
        this.close();
        yield action();
      });
    });
  }
  onClose() {
    this.contentEl.empty();
  }
};
var LoadingModal2 = class extends import_obsidian3.Modal {
  constructor(app, isProgress = false) {
    super(app);
    this.isProgress = isProgress;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    if (this.isProgress) {
      contentEl.addClass("loading-modal");
      contentEl.createEl("h2", { text: "Searching..." });
      this.statusEl = contentEl.createEl("p", { text: "Initializing..." });
      this.countEl = contentEl.createEl("p", { cls: "count-text" });
      this.progressEl = contentEl.createEl("p", { cls: "progress-text" });
    } else {
      contentEl.createEl("h2", { text: "Processing..." });
      contentEl.createEl("div", { text: "Please wait while the AI processes your text.", cls: "loading-text" });
      this.spinnerEl = contentEl.createDiv({ cls: "spinner" });
      for (let i = 0; i < 3; i++) {
        this.spinnerEl.createDiv({ cls: "bounce" + (i + 1) });
      }
    }
  }
  setProgress(progress, current, total) {
    if (!this.isProgress) return;
    const percentage = Math.round(progress * 100);
    this.progressEl.setText(`Progress: ${percentage}%`);
    this.countEl.setText(`Processing file ${current} of ${total}`);
  }
  setStatus(status) {
    if (!this.isProgress) return;
    this.statusEl.setText(status);
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var AIContentModal = class extends import_obsidian3.Modal {
  constructor(app, plugin, content, editor, onApply) {
    super(app);
    this.undoStack = [];
    this.plugin = plugin;
    this.content = content;
    this.editor = editor;
    this.onApply = onApply;
  }
  onOpen() {
    return __async(this, null, function* () {
      const { contentEl } = this;
      contentEl.empty();
      contentEl.createEl("h2", { text: "AI Generated Content" });
      const messageContainer = contentEl.createDiv({ cls: "message-container" });
      const msgDiv = messageContainer.createDiv({ cls: "ai-message" });
      const sanitizedContent = this.sanitizeContent(this.content);
      yield MarkdownRenderer.renderMarkdown(sanitizedContent, msgDiv, "", this.plugin);
      const actionContainer = msgDiv.createDiv({ cls: "message-actions hover-only" });
      const copyBtn = actionContainer.createEl("button", {
        cls: "message-action-button copy-button",
        attr: { "aria-label": "Copy content" }
      });
      (0, import_obsidian3.setIcon)(copyBtn, "copy");
      copyBtn.onclick = () => __async(this, null, function* () {
        try {
          yield navigator.clipboard.writeText(this.content);
          new import_obsidian3.Notice("Content copied to clipboard!", 2e3);
        } catch (err) {
          console.error("Failed to copy content:", err);
          new import_obsidian3.Notice("Failed to copy content");
        }
      });
      const insertBtn = actionContainer.createEl("button", {
        cls: "message-action-button insert-button",
        attr: { "aria-label": "Insert content" }
      });
      (0, import_obsidian3.setIcon)(insertBtn, "plus");
      insertBtn.onclick = () => {
        if (this.editor) {
          const startPos = this.editor.getCursor();
          const insertedContent = this.content;
          this.editor.replaceRange(insertedContent, startPos);
          const endOffset = this.editor.posToOffset(startPos) + insertedContent.length;
          const endPos = this.editor.offsetToPos(endOffset);
          this.undoStack.push({ from: startPos, to: endPos, text: "" });
          new import_obsidian3.Notice("Content inserted at cursor position!", 2e3);
        } else {
          new import_obsidian3.Notice("No active editor found.", 2e3);
        }
      };
    });
  }
  onClose() {
    this.contentEl.empty();
  }
  // Add this new method to sanitize content
  sanitizeContent(content) {
    return content.split("\n").map((line) => {
      if (line.trimStart().startsWith("=")) {
        return "\\" + line;
      }
      return line;
    }).join("\n");
  }
};
var ChatModal = class extends import_obsidian3.Modal {
  constructor(app, plugin, initialHistory = [], editor = null) {
    super(app);
    this.messageContainer = null;
    this.currentInput = null;
    this.history = [];
    this.plugin = plugin;
    this.history = initialHistory;
    this.editor = editor;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    const chatContainer = contentEl.createDiv({ cls: "chat-container" });
    const messageContainer = chatContainer.createDiv({ cls: "message-container" });
    this.messageContainer = messageContainer;
    this.renderChatHistory(messageContainer);
    const inputContainer = chatContainer.createDiv({ cls: "input-container" });
    const textarea = inputContainer.createEl("textarea", {
      cls: "chat-input",
      attr: { placeholder: "Type your message..." }
    });
    this.currentInput = textarea;
    const sendButton = inputContainer.createEl("button", { cls: "send-button" });
    (0, import_obsidian3.setIcon)(sendButton, "paper-plane");
    sendButton.onclick = () => this.handleSend();
  }
  handleSend() {
    return __async(this, null, function* () {
      var _a;
      if (!this.currentInput || !this.currentInput.value.trim()) return;
      const userMessage = this.currentInput.value.trim();
      this.currentInput.value = "";
      this.history.push({ role: "user", content: userMessage });
      yield this.renderMessage(userMessage, "user");
      try {
        const messageEl = (_a = this.messageContainer) == null ? void 0 : _a.createDiv({ cls: "message assistant-message" });
        const contentDiv = messageEl == null ? void 0 : messageEl.createDiv({ cls: "message-content" });
        const textDiv = contentDiv == null ? void 0 : contentDiv.createDiv({ cls: "message-text" });
        if (!messageEl || !contentDiv || !textDiv) {
          throw new Error("Failed to create message elements");
        }
        let streamedContent = "";
        const response = yield this.plugin.callAIChat(this.history, (chunk) => __async(this, null, function* () {
          streamedContent += chunk;
          yield MarkdownRenderer.renderMarkdown(streamedContent, textDiv, "", this.plugin);
          if (this.messageContainer && this.messageContainer.scrollHeight) {
            this.messageContainer.scrollTo({
              top: this.messageContainer.scrollHeight,
              behavior: "smooth"
            });
          }
        }));
        const actionContainer = messageEl.createDiv({ cls: "message-actions hover-only" });
        const copyButton = actionContainer.createEl("button", {
          cls: "message-action-button copy-button",
          attr: { "aria-label": "Copy message" }
        });
        (0, import_obsidian3.setIcon)(copyButton, "copy");
        copyButton.onclick = () => __async(this, null, function* () {
          try {
            yield navigator.clipboard.writeText(response);
            new import_obsidian3.Notice("Copied to clipboard", 2e3);
          } catch (err) {
            console.error("Failed to copy content:", err);
            new import_obsidian3.Notice("Failed to copy content", 2e3);
          }
        });
        const insertButton = actionContainer.createEl("button", {
          cls: "message-action-button insert-button",
          attr: { "aria-label": "Insert into editor" }
        });
        (0, import_obsidian3.setIcon)(insertButton, "plus");
        insertButton.onclick = () => {
          const activeLeaf = this.app.workspace.activeLeaf;
          if (!activeLeaf) {
            new import_obsidian3.Notice("Please open a markdown file first", 2e3);
            return;
          }
          const view = activeLeaf.view;
          if (!(view instanceof import_obsidian3.MarkdownView)) {
            new import_obsidian3.Notice("Please open a markdown file first", 2e3);
            return;
          }
          const editor = view.editor;
          const cursor = editor.getCursor();
          editor.replaceRange(response + "\n", cursor);
          editor.focus();
          new import_obsidian3.Notice("Content inserted into editor", 2e3);
        };
        this.history.push({ role: "assistant", content: response });
      } catch (error) {
        console.error("Error in chat:", error);
        new import_obsidian3.Notice("Error getting AI response: " + error.message, 2e3);
      }
    });
  }
  renderMessage(content, role) {
    return __async(this, null, function* () {
      if (!this.messageContainer) return;
      const messageEl = this.messageContainer.createDiv({ cls: `message ${role}-message` });
      const contentDiv = messageEl.createDiv({ cls: "message-content" });
      if (role === "assistant") {
        yield MarkdownRenderer.renderMarkdown(content, contentDiv, "", this.plugin);
        const actionContainer = messageEl.createDiv({ cls: "message-actions hover-only" });
        const copyButton = actionContainer.createEl("button", { cls: "message-action-button copy-button" });
        (0, import_obsidian3.setIcon)(copyButton, "copy");
        copyButton.setAttribute("aria-label", "Copy message");
        copyButton.onclick = () => __async(this, null, function* () {
          try {
            yield navigator.clipboard.writeText(content);
            new import_obsidian3.Notice("Copied to clipboard", 2e3);
          } catch (err) {
            console.error("Failed to copy content:", err);
            new import_obsidian3.Notice("Failed to copy content", 2e3);
          }
        });
        const insertButton = actionContainer.createEl("button", { cls: "message-action-button insert-button" });
        (0, import_obsidian3.setIcon)(insertButton, "plus");
        insertButton.setAttribute("aria-label", "Insert into editor");
        insertButton.onclick = () => {
          const activeLeaf = this.app.workspace.activeLeaf;
          if (!activeLeaf) {
            new import_obsidian3.Notice("Please open a markdown file first", 2e3);
            return;
          }
          const view = activeLeaf.view;
          if (!(view instanceof import_obsidian3.MarkdownView)) {
            new import_obsidian3.Notice("Please open a markdown file first", 2e3);
            return;
          }
          const editor = view.editor;
          const cursor = editor.getCursor();
          editor.replaceRange(content + "\n", cursor);
          editor.focus();
          new import_obsidian3.Notice("Content inserted into editor", 2e3);
        };
      } else {
        contentDiv.setText(content);
      }
      const container = this.messageContainer;
      if (container && container.scrollHeight) {
        container.scrollTo({
          top: container.scrollHeight,
          behavior: "smooth"
        });
      }
    });
  }
  renderChatHistory(container) {
    return __async(this, null, function* () {
      container.empty();
      this.messageContainer = container;
      for (const msg of this.history) {
        yield this.renderMessage(msg.content, msg.role);
      }
    });
  }
};
var SearchPromptModal = class extends import_obsidian3.Modal {
  constructor(app) {
    super(app);
    this.result = null;
    this.resolvePromise = () => {
    };
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("search-prompt-modal");
    contentEl.createEl("h2", { text: "Search Knowledge Base" });
    const inputEl = contentEl.createEl("input", {
      type: "text",
      placeholder: "Enter your search query...",
      cls: "search-prompt-input"
    });
    const buttonContainer = contentEl.createDiv({ cls: "search-prompt-buttons" });
    const searchBtn = buttonContainer.createEl("button", {
      text: "Search",
      cls: "search-button"
    });
    const cancelBtn = buttonContainer.createEl("button", {
      text: "Cancel",
      cls: "cancel-button"
    });
    inputEl.focus();
    searchBtn.onclick = () => {
      this.result = inputEl.value;
      this.close();
    };
    cancelBtn.onclick = () => {
      this.result = null;
      this.close();
    };
    inputEl.onkeydown = (e) => {
      if (e.key === "Enter") {
        this.result = inputEl.value;
        this.close();
      }
    };
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
    if (this.resolvePromise) {
      this.resolvePromise(this.result);
    }
  }
  openAndGetValue() {
    return __async(this, null, function* () {
      this.open();
      return new Promise((resolve) => {
        this.resolvePromise = resolve;
      });
    });
  }
};
var ConfirmModal2 = class extends import_obsidian3.Modal {
  constructor(app, message, onConfirm) {
    super(app);
    this.message = message;
    this.onConfirm = onConfirm;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("confirm-modal");
    contentEl.createEl("p", { text: this.message, cls: "confirm-message" });
    const buttonContainer = contentEl.createDiv({ cls: "confirm-button-container" });
    const confirmBtn = buttonContainer.createEl("button", { text: "Confirm", cls: "confirm-button" });
    const cancelBtn = buttonContainer.createEl("button", { text: "Cancel", cls: "cancel-button" });
    confirmBtn.onclick = () => {
      this.close();
      this.onConfirm();
    };
    cancelBtn.onclick = () => {
      this.close();
    };
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var SearchResultsModal = class extends import_obsidian3.Modal {
  constructor(app, results) {
    super(app);
    this.results = results;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("search-results-modal");
    contentEl.createEl("h2", { text: "Search Results" });
    const resultsContainer = contentEl.createDiv({ cls: "results-container" });
    this.results.forEach((result) => {
      const resultEl = resultsContainer.createDiv({ cls: "result-item" });
      resultEl.createEl("span", { text: `${result.file.basename} - Similarity: ${result.similarity.toFixed(2)}` });
      resultEl.addEventListener("click", () => __async(this, null, function* () {
        const leaf = this.app.workspace.getLeaf(false);
        if (leaf && result.file) {
          try {
            yield leaf.openFile(result.file);
          } catch (error) {
            console.error("Error opening file:", error);
            new import_obsidian3.Notice("Failed to open file", 2e3);
          }
        } else {
          new import_obsidian3.Notice("Could not open file", 2e3);
        }
      }));
    });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var AITextSettingTab = class extends import_obsidian3.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "API Settings" });
    new import_obsidian3.Setting(containerEl).setName("API Key").setDesc("Enter your API key").addText((text) => text.setPlaceholder("Enter your API key").setValue(this.plugin.settings.apiKey).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.apiKey = value;
      yield this.plugin.saveSettings();
    })));
    new import_obsidian3.Setting(containerEl).setName("API Provider").setDesc("Select your AI provider").addDropdown((dropdown) => dropdown.addOption("openai", "OpenAI").addOption("zhipuai", "ZhipuAI").addOption("groq", "Groq").setValue(this.plugin.settings.provider).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.provider = value;
      yield this.plugin.saveSettings();
      this.display();
    })));
    if (this.plugin.settings.provider === "openai") {
      new import_obsidian3.Setting(containerEl).setName("Model").setDesc("Select OpenAI model").addDropdown((dropdown) => dropdown.addOption("gpt-3.5-turbo", "GPT-3.5 Turbo").addOption("gpt-4", "GPT-4").addOption("gpt-4-turbo", "GPT-4 Turbo").setValue(this.plugin.settings.model).onChange((value) => __async(this, null, function* () {
        this.plugin.settings.model = value;
        yield this.plugin.saveSettings();
      })));
    } else if (this.plugin.settings.provider === "zhipuai") {
      new import_obsidian3.Setting(containerEl).setName("Chat Model").setDesc("Select ZhipuAI model").addDropdown((dropdown) => {
        Object.keys(ZHIPUAI_MODELS.CHAT).forEach((modelName) => {
          dropdown.addOption(modelName, modelName);
        });
        return dropdown.setValue(this.plugin.settings.chatModel).onChange((value) => __async(this, null, function* () {
          this.plugin.settings.chatModel = value;
          this.plugin.settings.model = value;
          yield this.plugin.saveSettings();
        }));
      });
    } else if (this.plugin.settings.provider === "groq") {
      new import_obsidian3.Setting(containerEl).setName("Model").setDesc("Select Groq model").addDropdown((dropdown) => dropdown.addOption("llama2-70b-4096", "Llama-2 70B").addOption("mixtral-8x7b-32768", "Mixtral 8x7B").setValue(this.plugin.settings.model).onChange((value) => __async(this, null, function* () {
        this.plugin.settings.model = value;
        yield this.plugin.saveSettings();
      })));
    }
    new import_obsidian3.Setting(containerEl).setName("Embedding Model").setDesc("Select embedding model").addDropdown((dropdown) => {
      Object.keys(EMBEDDING_MODELS).forEach((modelName) => {
        dropdown.addOption(modelName, modelName);
      });
      return dropdown.setValue(this.plugin.settings.embeddingModel).onChange((value) => __async(this, null, function* () {
        this.plugin.settings.embeddingModel = value;
        const dimensions = EMBEDDING_MODELS[value].dimensions;
        if (dimensions) {
          this.plugin.settings.embeddingDimensions = dimensions;
        }
        yield this.plugin.saveSettings();
      }));
    });
    new import_obsidian3.Setting(containerEl).setName("Knowledge Base Path").setDesc("Enter the path to your knowledge base folder").addText((text) => text.setPlaceholder("AI_KnowledgeBase").setValue(this.plugin.settings.knowledgeBasePath).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.knowledgeBasePath = value;
      yield this.plugin.saveSettings();
    })));
    new import_obsidian3.Setting(containerEl).setName("Chat History Path").setDesc("Enter the path to store your chat history files").addText((text) => text.setPlaceholder("AI_ChatHistory").setValue(this.plugin.settings.chatHistoryPath).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.chatHistoryPath = value;
      yield this.plugin.saveSettings();
    })));
    containerEl.createEl("h2", { text: "Functions" });
    containerEl.createEl("p", {
      text: "Configure all available functions that appear as icons in the chat view.",
      cls: "setting-item-description"
    });
    if (!this.plugin.settings.functions || this.plugin.settings.functions.length === 0) {
      this.plugin.settings.functions = [...DEFAULT_SETTINGS.functions];
      if (this.plugin.settings.customFunctions && this.plugin.settings.customFunctions.length > 0) {
        this.plugin.settings.functions.push(...this.plugin.settings.customFunctions);
      }
    }
    this.migratePromptsToFunctions();
    const functionsContainer = containerEl.createDiv({ cls: "functions-container" });
    this.displayFunctions(functionsContainer);
    new import_obsidian3.Setting(containerEl).addButton((button) => button.setButtonText("Add New Function").setCta().onClick(() => {
      new CustomFunctionModal(this.app, null, (customFunc) => __async(this, null, function* () {
        this.plugin.settings.functions.push(customFunc);
        if (!this.plugin.settings.customFunctions) {
          this.plugin.settings.customFunctions = [];
        }
        this.plugin.settings.customFunctions.push(customFunc);
        yield this.plugin.saveSettings();
        this.display();
      })).open();
    }));
  }
  // Migrate old prompt templates to the new functions array for backward compatibility
  migratePromptsToFunctions() {
    if (this.plugin.settings.functions) {
      const organizeFunc = this.plugin.settings.functions.find((f) => f.isBuiltIn && f.name === "Organize");
      if (organizeFunc && this.plugin.settings.promptOrganize) {
        organizeFunc.prompt = this.plugin.settings.promptOrganize;
      }
      const grammarFunc = this.plugin.settings.functions.find((f) => f.isBuiltIn && f.name === "Grammar");
      if (grammarFunc && this.plugin.settings.promptCheckGrammar) {
        grammarFunc.prompt = this.plugin.settings.promptCheckGrammar;
      }
      const generateFunc = this.plugin.settings.functions.find((f) => f.isBuiltIn && f.name === "Generate");
      if (generateFunc && this.plugin.settings.promptGenerateContent) {
        generateFunc.prompt = this.plugin.settings.promptGenerateContent;
      }
      const dialogueFunc = this.plugin.settings.functions.find((f) => f.isBuiltIn && f.name === "Dialogue");
      if (dialogueFunc && this.plugin.settings.promptDialogue) {
        dialogueFunc.prompt = this.plugin.settings.promptDialogue;
      }
      const summaryFunc = this.plugin.settings.functions.find((f) => f.isBuiltIn && f.name === "Summarize");
      if (summaryFunc && this.plugin.settings.promptSummary) {
        summaryFunc.prompt = this.plugin.settings.promptSummary;
      }
    }
  }
  displayFunctions(container) {
    container.empty();
    if (!this.plugin.settings.functions || this.plugin.settings.functions.length === 0) {
      container.createEl("p", {
        text: "No functions configured yet.",
        cls: "no-functions"
      });
      return;
    }
    const builtInFunctions = this.plugin.settings.functions.filter((f) => f.isBuiltIn);
    const customFunctions = this.plugin.settings.functions.filter((f) => !f.isBuiltIn);
    if (builtInFunctions.length > 0) {
      const builtInSection = container.createDiv({ cls: "function-section" });
      builtInSection.createEl("h3", { text: "Built-in Functions" });
      builtInFunctions.forEach((func, index) => {
        this.createFunctionItem(builtInSection, func, index, true);
      });
    }
    if (customFunctions.length > 0) {
      const customSection = container.createDiv({ cls: "function-section" });
      customSection.createEl("h3", { text: "Custom Functions" });
      customFunctions.forEach((func, index) => {
        this.createFunctionItem(customSection, func, builtInFunctions.length + index, false);
      });
    }
  }
  createFunctionItem(container, func, index, isBuiltIn) {
    const funcDiv = container.createDiv({ cls: `function-item ${isBuiltIn ? "built-in" : "custom"}` });
    const previewDiv = funcDiv.createDiv({ cls: "function-preview" });
    const iconContainer = previewDiv.createDiv({ cls: "function-icon" });
    try {
      (0, import_obsidian3.setIcon)(iconContainer, func.icon);
    } catch (e) {
      (0, import_obsidian3.setIcon)(iconContainer, "bot");
    }
    previewDiv.createEl("span", { text: func.name, cls: "function-name" });
    if (func.tooltip) {
      previewDiv.createEl("span", { text: func.tooltip, cls: "function-tooltip" });
    }
    const actionsDiv = funcDiv.createDiv({ cls: "function-actions" });
    const editButton = actionsDiv.createEl("button", {
      cls: "function-edit",
      attr: {
        "aria-label": "Edit function",
        "title": "Edit function"
      }
    });
    (0, import_obsidian3.setIcon)(editButton, "edit");
    editButton.addEventListener("click", () => {
      new CustomFunctionModal(this.app, func, (updatedFunc) => __async(this, null, function* () {
        updatedFunc.isBuiltIn = isBuiltIn;
        this.plugin.settings.functions[index] = updatedFunc;
        if (isBuiltIn) {
          if (func.name === "Organize") this.plugin.settings.promptOrganize = updatedFunc.prompt;
          else if (func.name === "Grammar") this.plugin.settings.promptCheckGrammar = updatedFunc.prompt;
          else if (func.name === "Generate") this.plugin.settings.promptGenerateContent = updatedFunc.prompt;
          else if (func.name === "Dialogue") this.plugin.settings.promptDialogue = updatedFunc.prompt;
          else if (func.name === "Summarize") this.plugin.settings.promptSummary = updatedFunc.prompt;
        } else {
          const customIndex = this.plugin.settings.customFunctions.findIndex((f) => f.name === func.name && f.icon === func.icon);
          if (customIndex >= 0) {
            this.plugin.settings.customFunctions[customIndex] = updatedFunc;
          }
        }
        yield this.plugin.saveSettings();
        this.display();
      })).open();
    });
    if (!isBuiltIn) {
      const deleteButton = actionsDiv.createEl("button", {
        cls: "function-delete",
        attr: {
          "aria-label": "Delete function",
          "title": "Delete function"
        }
      });
      (0, import_obsidian3.setIcon)(deleteButton, "trash");
      deleteButton.addEventListener("click", () => __async(this, null, function* () {
        this.plugin.settings.functions.splice(index, 1);
        const customIndex = this.plugin.settings.customFunctions.findIndex((f) => f.name === func.name && f.icon === func.icon);
        if (customIndex >= 0) {
          this.plugin.settings.customFunctions.splice(customIndex, 1);
        }
        yield this.plugin.saveSettings();
        this.display();
      }));
    }
  }
};
var CustomFunctionModal = class extends import_obsidian3.Modal {
  constructor(app, customFunc, onSubmit) {
    super(app);
    this.customFunc = customFunc;
    this.onSubmit = onSubmit;
  }
  onOpen() {
    var _a, _b, _c, _d, _e;
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("custom-function-modal");
    contentEl.createEl("h2", { text: this.customFunc ? "Edit Custom Function" : "Add Custom Function" });
    const nameDiv = contentEl.createDiv({ cls: "setting-item" });
    nameDiv.createEl("label", { text: "Function Name", cls: "setting-item-name" });
    this.nameInput = nameDiv.createEl("input", {
      type: "text",
      cls: "setting-item-input",
      value: ((_a = this.customFunc) == null ? void 0 : _a.name) || "",
      attr: { placeholder: "Enter function name" }
    });
    const iconDiv = contentEl.createDiv({ cls: "setting-item" });
    const iconLabel = iconDiv.createEl("label", { text: "Icon", cls: "setting-item-name" });
    const iconHelp = iconDiv.createEl("div", { cls: "setting-item-description" });
    iconHelp.innerHTML = 'Enter an icon name from <a href="https://lucide.dev/icons/" target="_blank">Lucide Icons</a> (e.g., "book", "pen", "code")';
    const iconRow = iconDiv.createDiv({ cls: "icon-row" });
    this.iconInput = iconRow.createEl("input", {
      type: "text",
      cls: "setting-item-input",
      value: ((_b = this.customFunc) == null ? void 0 : _b.icon) || "",
      attr: { placeholder: "Enter icon name" }
    });
    this.iconPreview = iconRow.createDiv({ cls: "icon-preview" });
    if ((_c = this.customFunc) == null ? void 0 : _c.icon) {
      try {
        (0, import_obsidian3.setIcon)(this.iconPreview, this.customFunc.icon);
      } catch (e) {
        this.iconPreview.setText("Invalid icon");
      }
    }
    this.iconInput.addEventListener("input", () => {
      this.iconPreview.empty();
      if (this.iconInput.value) {
        try {
          (0, import_obsidian3.setIcon)(this.iconPreview, this.iconInput.value);
        } catch (e) {
          this.iconPreview.setText("Invalid icon");
        }
      }
    });
    const tooltipDiv = contentEl.createDiv({ cls: "setting-item" });
    tooltipDiv.createEl("label", { text: "Tooltip (Optional)", cls: "setting-item-name" });
    this.tooltipInput = tooltipDiv.createEl("input", {
      type: "text",
      cls: "setting-item-input",
      value: ((_d = this.customFunc) == null ? void 0 : _d.tooltip) || "",
      attr: { placeholder: "Enter tooltip text" }
    });
    const promptDiv = contentEl.createDiv({ cls: "setting-item" });
    promptDiv.createEl("label", { text: "Prompt Template", cls: "setting-item-name" });
    promptDiv.createEl("div", {
      text: "Enter the prompt to send to the AI. The selected text will be appended to this prompt.",
      cls: "setting-item-description"
    });
    const promptValue = ((_e = this.customFunc) == null ? void 0 : _e.prompt) || "";
    this.promptInput = promptDiv.createEl("textarea", {
      cls: "setting-item-input prompt-input",
      value: promptValue,
      attr: {
        placeholder: "Enter prompt template...",
        rows: "6"
      }
    });
    const buttonDiv = contentEl.createDiv({ cls: "custom-function-button-container" });
    const cancelButton = buttonDiv.createEl("button", { text: "Cancel" });
    cancelButton.addEventListener("click", () => {
      this.close();
    });
    const submitButton = buttonDiv.createEl("button", { text: this.customFunc ? "Update" : "Create", cls: "mod-cta" });
    submitButton.addEventListener("click", () => {
      const name = this.nameInput.value.trim();
      const icon = this.iconInput.value.trim();
      const prompt = this.promptInput.value;
      if (!name) {
        new import_obsidian3.Notice("Please enter a function name");
        return;
      }
      if (!icon) {
        new import_obsidian3.Notice("Please enter an icon name");
        return;
      }
      if (!prompt) {
        new import_obsidian3.Notice("Please enter a prompt template");
        return;
      }
      const functionData = {
        name,
        icon,
        prompt: String(prompt),
        // Cast to string to ensure proper storage
        tooltip: this.tooltipInput.value.trim() || void 0
      };
      this.onSubmit(functionData);
      this.close();
    });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var PolishResultModal = class extends import_obsidian3.Modal {
  constructor(app, plugin, originalText, polishedText, onApply) {
    super(app);
    this.plugin = plugin;
    this.originalText = originalText;
    this.polishedText = polishedText;
    this.onApply = onApply;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.addClass("polish-result-modal");
    contentEl.createEl("h2", { text: "Polish Result" });
    contentEl.createEl("p", {
      text: "Review the changes: deleted text has strikethrough, added text is highlighted in purple.",
      cls: "polish-description"
    });
    this.resultEl = contentEl.createDiv({ cls: "polish-result-container" });
    this.highlightChanges();
    const buttonContainer = contentEl.createDiv({ cls: "polish-button-container" });
    const applyButton = buttonContainer.createEl("button", {
      text: "Apply Changes",
      cls: "mod-cta"
    });
    applyButton.addEventListener("click", () => {
      this.onApply(this.polishedText);
      this.close();
    });
    const cancelButton = buttonContainer.createEl("button", {
      text: "Cancel"
    });
    cancelButton.addEventListener("click", () => {
      this.close();
    });
  }
  // Method to highlight the differences between original and polished text
  highlightChanges() {
    const diffHtml = this.generateInlineDiff(this.originalText, this.polishedText);
    this.resultEl.innerHTML = diffHtml;
  }
  // Generate a more accurate inline diff with strikethrough for deletions and highlighting for additions
  generateInlineDiff(original, polished) {
    const originalWords = this.tokenize(original);
    const polishedWords = this.tokenize(polished);
    const lcs = this.findLongestCommonSubsequence(originalWords, polishedWords);
    let html2 = "";
    let i = 0, j = 0;
    for (const common of lcs) {
      while (i < originalWords.length && originalWords[i] !== common) {
        html2 += `<span class="polish-deleted">${this.escapeHtml(originalWords[i])}</span> `;
        i++;
      }
      while (j < polishedWords.length && polishedWords[j] !== common) {
        html2 += `<span class="polish-highlight">${this.escapeHtml(polishedWords[j])}</span> `;
        j++;
      }
      html2 += this.escapeHtml(common) + " ";
      i++;
      j++;
    }
    while (i < originalWords.length) {
      html2 += `<span class="polish-deleted">${this.escapeHtml(originalWords[i])}</span> `;
      i++;
    }
    while (j < polishedWords.length) {
      html2 += `<span class="polish-highlight">${this.escapeHtml(polishedWords[j])}</span> `;
      j++;
    }
    return html2;
  }
  // Split text into words for diffing
  tokenize(text) {
    return text.split(/\s+/).filter((word) => word.length > 0);
  }
  // A simple longest common subsequence algorithm
  findLongestCommonSubsequence(a, b) {
    const table = Array(a.length + 1).fill(0).map(() => Array(b.length + 1).fill(0));
    for (let i2 = 1; i2 <= a.length; i2++) {
      for (let j2 = 1; j2 <= b.length; j2++) {
        if (a[i2 - 1] === b[j2 - 1]) {
          table[i2][j2] = table[i2 - 1][j2 - 1] + 1;
        } else {
          table[i2][j2] = Math.max(table[i2][j2 - 1], table[i2 - 1][j2]);
        }
      }
    }
    const result = [];
    let i = a.length, j = b.length;
    while (i > 0 && j > 0) {
      if (a[i - 1] === b[j - 1]) {
        result.unshift(a[i - 1]);
        i--;
        j--;
      } else if (table[i][j - 1] > table[i - 1][j]) {
        j--;
      } else {
        i--;
      }
    }
    return result;
  }
  // Escape HTML special characters to prevent XSS
  escapeHtml(text) {
    const div = document.createElement("div");
    div.textContent = text;
    return div.innerHTML;
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
